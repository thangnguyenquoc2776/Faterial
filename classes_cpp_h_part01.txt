Folder .
File CMakeLists.txt
cmake_minimum_required(VERSION 3.20)

# ================== Project meta ==================
set(APP_NAME Faterial)
project(${APP_NAME} C CXX)

# ================== MSVC runtime & common defs ==================
if (MSVC)
    # /MD (Release) và /MDd (Debug)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL" CACHE STRING "" FORCE)
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS NOMINMAX)
    add_compile_options(/MP)
endif()

# ================== Cocos2d-x engine ==================
if(NOT DEFINED BUILD_ENGINE_DONE)
    set(COCOS2DX_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cocos2d)
    set(CMAKE_MODULE_PATH ${COCOS2DX_ROOT_PATH}/cmake/Modules/)
    include(CocosBuildSet)
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos ${ENGINE_BINARY_PATH}/cocos/core)
endif()

# ================== Resources ==================
set(GAME_RES_FOLDER "${CMAKE_CURRENT_SOURCE_DIR}/Resources")
if(APPLE OR WINDOWS)
    cocos_mark_multi_resources(common_res_files RES_TO "Resources" FOLDERS ${GAME_RES_FOLDER})
endif()

# ================== Game headers & sources ==================
set(GAME_HEADER
    # core
    Classes/core/AppDelegate.h
    Classes/core/CrashGuard.h

    # physics
    Classes/physics/PhysicsDefs.h

    # ui
    Classes/ui/HUDLayer.h

    # scenes
    Classes/scenes/MenuScene.h
    Classes/scenes/GameScene.h

    # game base
    Classes/game/Entity.h
    Classes/game/Player.h
    Classes/game/Enemy.h

    # enemies / bosses / objects
    Classes/game/enemies/Goomba.h
    Classes/game/enemies/Spiker.h
    Classes/game/bosses/BossGolem.h
    Classes/game/objects/Coin.h
    Classes/game/objects/Star.h
    Classes/game/objects/Upgrade.h
    Classes/game/objects/Crate.h
    Classes/game/objects/Gate.h
    Classes/game/objects/PressurePlate.h

    # weapon (NEW)
    Classes/game/weapon/Bullet.h
    Classes/game/weapon/Slash.h
)

set(GAME_SRC
    # core
    Classes/core/AppDelegate.cpp

    # ui
    Classes/ui/HUDLayer.cpp

    # scenes
    Classes/scenes/MenuScene.cpp
    Classes/scenes/GameScene.cpp

    # game base
    Classes/game/Entity.cpp
    Classes/game/Player.cpp
    Classes/game/Enemy.cpp

    # enemies / bosses / objects
    Classes/game/enemies/Goomba.cpp
    Classes/game/enemies/Spiker.cpp
    Classes/game/bosses/BossGolem.cpp
    Classes/game/objects/Coin.cpp
    Classes/game/objects/Star.cpp
    Classes/game/objects/Upgrade.cpp
    Classes/game/objects/Crate.cpp
    Classes/game/objects/Gate.cpp
    Classes/game/objects/PressurePlate.cpp

    # weapon (NEW)
    Classes/game/weapon/Bullet.cpp
    Classes/game/weapon/Slash.cpp
)

# ================== Platform glue ==================
if(ANDROID)
    list(APPEND GAME_SRC proj.android/app/jni/hellocpp/main.cpp)
elseif(LINUX)
    list(APPEND GAME_SRC proj.linux/main.cpp)
elseif(WINDOWS)
    list(APPEND GAME_HEADER
        proj.win32/main.h
        proj.win32/resource.h
    )
    list(APPEND GAME_SRC
        proj.win32/main.cpp
        proj.win32/game.rc
        ${common_res_files}
    )
elseif(APPLE)
    if(IOS)
        list(APPEND GAME_HEADER
            proj.ios_mac/ios/AppController.h
            proj.ios_mac/ios/RootViewController.h
        )
        set(APP_UI_RES
            proj.ios_mac/ios/LaunchScreen.storyboard
            proj.ios_mac/ios/LaunchScreenBackground.png
            proj.ios_mac/ios/Images.xcassets
        )
        list(APPEND GAME_SRC
            proj.ios_mac/ios/main.m
            proj.ios_mac/ios/AppController.mm
            proj.ios_mac/ios/RootViewController.mm
            proj.ios_mac/ios/Prefix.pch
            ${APP_UI_RES}
        )
    elseif(MACOSX)
        set(APP_UI_RES
            proj.ios_mac/mac/Icon.icns
            proj.ios_mac/mac/Info.plist
        )
        list(APPEND GAME_SRC
            proj.ios_mac/mac/main.cpp
            proj.ios_mac/mac/Prefix.pch
            ${APP_UI_RES}
        )
    endif()
    list(APPEND GAME_SRC ${common_res_files})
endif()

# ================== Target (tạo trước, rồi mới target_*) ==================
set(all_code_files ${GAME_HEADER} ${GAME_SRC})

if(NOT ANDROID)
    add_executable(${APP_NAME} ${all_code_files})
else()
    add_library(${APP_NAME} SHARED ${all_code_files})
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos/platform/android ${ENGINE_BINARY_PATH}/cocos/platform)
    target_link_libraries(${APP_NAME} PRIVATE -Wl,--whole-archive cpp_android_spec -Wl,--no-whole-archive)
endif()

# ================== Include paths ==================
target_include_directories(${APP_NAME}
    PRIVATE Classes
    PRIVATE Classes/core
    PRIVATE Classes/physics
    PRIVATE Classes/ui
    PRIVATE Classes/scenes
    PRIVATE Classes/game
    PRIVATE Classes/game/enemies
    PRIVATE Classes/game/bosses
    PRIVATE Classes/game/objects
    PRIVATE Classes/game/weapon        # << NEW
    PRIVATE ${COCOS2DX_ROOT_PATH}/cocos/audio/include/  # AudioEngine
)

# ================== Link engine + system libs ==================
target_link_libraries(${APP_NAME} PRIVATE cocos2d)

if (MSVC)
    target_link_options(${APP_NAME} PRIVATE /NODEFAULTLIB:LIBCMT /IGNORE:4098)
    target_link_libraries(${APP_NAME} PRIVATE winmm DbgHelp legacy_stdio_definitions)
endif()

# ================== App config & copy resources ==================
setup_cocos_app_config(${APP_NAME})

if(APPLE)
    set_target_properties(${APP_NAME} PROPERTIES RESOURCE "${APP_UI_RES}")
    if(MACOSX)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/mac/Info.plist")
    elseif(IOS)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/ios/Info.plist")
        set_xcode_property(${APP_NAME} ASSETCATALOG_COMPILER_APPICON_NAME "AppIcon")
    endif()
elseif(WINDOWS)
    cocos_copy_target_dll(${APP_NAME})
endif()

if(LINUX OR WINDOWS)
    cocos_get_resource_path(APP_RES_DIR ${APP_NAME})
    cocos_copy_target_res(${APP_NAME} LINK_TO ${APP_RES_DIR} FOLDERS ${GAME_RES_FOLDER})
endif()

# Tuỳ chọn:
# set_property(TARGET ${APP_NAME} PROPERTY CXX_STANDARD 17)
# set_property(TARGET ${APP_NAME} PROPERTY CXX_STANDARD_REQUIRED ON)


Folder Classes
File main.cpp
#include "core/AppDelegate.h"
#include "cocos2d.h"

USING_NS_CC;

int main(int argc, char** argv) {
    AppDelegate app;
    return Application::getInstance()->run();
}


Folder Classes/core
File AppDelegate.cpp
// AppDelegate.cpp
#include "core/AppDelegate.h"
#include "base/CCDirector.h"
#include "platform/CCGLView.h"
#include "scenes/MenuScene.h"
USING_NS_CC;

AppDelegate::AppDelegate() {}
AppDelegate::~AppDelegate() {}

void AppDelegate::initGLContextAttrs(){
    GLContextAttrs a{8,8,8,8,24,8};
    GLView::setGLContextAttrs(a);
}

bool AppDelegate::applicationDidFinishLaunching(){
    auto* director = Director::getInstance();
    auto* glview = director->getOpenGLView();
    if(!glview){
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
        glview = GLViewImpl::createWithRect("Faterial", Rect(0,0,1920,1080));
#else
        glview = GLViewImpl::create("Faterial");
#endif
        director->setOpenGLView(glview);
    }
    director->setAnimationInterval(1.0f/60.0f);
#if COCOS2D_DEBUG
    director->setDisplayStats(true);
#endif
    glview->setDesignResolutionSize(1280, 720, ResolutionPolicy::NO_BORDER);
    director->runWithScene(MenuScene::createScene());
    return true;
}
void AppDelegate::applicationDidEnterBackground(){ Director::getInstance()->stopAnimation(); }
void AppDelegate::applicationWillEnterForeground(){ Director::getInstance()->startAnimation(); }

File AppDelegate.h
// AppDelegate.h
#pragma once
#include "cocos2d.h"
class AppDelegate : private cocos2d::Application {
public:
    AppDelegate();
    virtual ~AppDelegate();
    virtual void initGLContextAttrs();
    virtual bool applicationDidFinishLaunching();
    virtual void applicationDidEnterBackground();
    virtual void applicationWillEnterForeground();
};

File CrashGuard.h
#pragma once
#include <cstdio>
#define CG_LOGF(path, fmt, ...) \
  do { FILE* f=nullptr; fopen_s(&f, (path), "a"); if(f){std::fprintf(f, fmt "\n", ##__VA_ARGS__); std::fclose(f);} } while(0)


Folder Classes/game
File Enemy.cpp
#include "game/Enemy.h"
#include "game/Player.h"
#include <algorithm>    // std::max, std::min
#include "physics/PhysicsDefs.h"

USING_NS_CC;

Enemy* Enemy::create(){
    auto p = new(std::nothrow) Enemy();
    if(p && p->init()){ p->autorelease(); return p; }
    CC_SAFE_DELETE(p);
    return nullptr;
}

bool Enemy::init(){
    if(!Sprite::init()) return false;
    // body hiển thị cơ bản
    setTextureRect(Rect(0,0,42,42));
    setColor(Color3B::RED);

    // HP
    _hp = _hpMax = 3;
    _hpBar = DrawNode::create();
    addChild(_hpBar, 5);
    _updateHpBar();

    scheduleUpdate();
    return true;
}

void Enemy::enablePhysics(const Vec2& pos, const Size& sz){
    if(_body) return;
    _body = PhysicsBody::createBox(sz, PhysicsMaterial(0.2f,0.f,0.9f));
    _body->setDynamic(true);
    _body->setRotationEnable(false);
    _body->setCategoryBitmask(phys::CAT_ENEMY);
    _body->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_CRATE);
    _body->setContactTestBitmask(phys::all());
    setPhysicsBody(_body);
    setPosition(pos);
}

void Enemy::setPatrol(const Vec2& a, const Vec2& b){
    _pA=a; _pB=b; _right = (b.x>=a.x);
}

void Enemy::_stepPatrol(){
    if(!_body) return;
    float dir = _right ? 1.f : -1.f;
    auto v = _body->getVelocity();
    v.x = dir * _speed;
    _body->setVelocity(v);

    float x = getPositionX();
    if(_right && x >= _pB.x) _right=false;
    else if(!_right && x <= _pA.x) _right=true;
}

void Enemy::_stepChase(){
    if(!_body || !_target){ _chasing=false; return; }

    float tx = _target->getPositionX();
    float x = getPositionX();
    float dir = (tx > x) ? 1.f : -1.f;
    auto v = _body->getVelocity();
    v.x = dir * (_speed*1.25f);
    _body->setVelocity(v);

    // thoát truy đuổi khi quá xa
    if(fabsf(tx - x) > _leaveRange) _chasing=false;
}

void Enemy::update(float){
    if(!_body) return;

    if(_target){
        float d = fabsf(_target->getPositionX() - getPositionX());
        if(!_chasing && d <= _enterRange) _chasing = true;
        if(_chasing) _stepChase();
        else         _stepPatrol();
    }else{
        _stepPatrol();
    }
}

// ===== HP bar =====
void Enemy::_updateHpBar(){
    if(!_hpBar) return;
    _hpBar->clear();

    float w = 42.f, h = 5.f;
    float ratio = 0.f;
    if(_hpMax > 0){
        ratio = std::max(0.f, std::min(1.f, (float)_hp / (float)_hpMax));
    }
    Vec2 base(-w*0.5f, 28.f);
    _hpBar->drawSolidRect(base, base + Vec2(w, h), Color4F(0.2f,0.2f,0.2f,0.9f));
    _hpBar->drawSolidRect(base, base + Vec2(w*ratio, h), Color4F(1,0.2f,0.2f,1));
}

// ===== Combat =====
void Enemy::takeHit(int dmg){
    _hp -= dmg;
    runAction(Sequence::create(
        TintTo::create(0.05f,255,120,120),
        TintTo::create(0.05f,255,255,255),
        nullptr
    ));
    _updateHpBar();
    if(_hp <= 0){
        removeFromParent();
    }
}

File Enemy.h
#pragma once

#include "cocos2d.h"
#include "physics/PhysicsDefs.h"
class Player;

class Enemy : public cocos2d::Sprite {
public:
    static Enemy* create();
    bool init() override;

    // Physics & hành vi
    void enablePhysics(const cocos2d::Vec2& pos, const cocos2d::Size& sz);
    void setPatrol(const cocos2d::Vec2& a, const cocos2d::Vec2& b);
    void setSpeed(float s){ _speed = s; }

    // Combat
    virtual void takeHit(int dmg);           // << CHỈ 1 HÀM DUY NHẤT
    void setTarget(Player* p){ _target = p; }
    int  hp() const { return _hp; }

    void update(float dt) override;

protected:
    cocos2d::PhysicsBody* _body = nullptr;
    cocos2d::Vec2 _pA{0,0}, _pB{200,0};
    float _speed = 80.f;
    int   _hp = 3;
    int   _hpMax = 3;

    bool  _right = true;

    // chase
    Player* _target = nullptr;
    float   _enterRange = 220.f;
    float   _leaveRange = 320.f;
    bool    _chasing = false;

    void _stepPatrol();
    void _stepChase();

    // HP bar
    cocos2d::DrawNode* _hpBar = nullptr;
    void _updateHpBar();
};

File Entity.cpp
#include "game/Entity.h"
// Hiện giờ mọi thứ đã làm trong header (inline) để đơn giản hoá.
// Nếu cần mở rộng logic chung cho mọi Entity, thêm ở đây.

File Entity.h
#pragma once
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"

class Entity : public cocos2d::Node {
public:
    CREATE_FUNC(Entity);

    // Node::init() không có tham số
    bool init() override { return cocos2d::Node::init(); }

    // Tag gameplay mở rộng (khác với Node::setTag(int))
    void setTagEx(phys::Tag t) { _gtag = t; }
    phys::Tag getTagEx() const { return _gtag; }

protected:
    phys::Tag _gtag = phys::Tag::NONE;
};

File Player.cpp
#include "game/Player.h"
#include "physics/PhysicsDefs.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"


USING_NS_CC;

static constexpr float kPlayerRadius = 14.f;

Player* Player::createDefault(const Vec2& startPos) {
    auto p = new (std::nothrow) Player();
    if (p && p->initWithDefault(startPos)) {
        p->autorelease();
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

bool Player::initWithDefault(const Vec2& startPos) {
    if (!Entity::init()) return false;

    // Sprite tròn màu (placeholder)
    _sprite = Sprite::create();
    const float d = kPlayerRadius * 2.f;
    auto draw = DrawNode::create();
    draw->drawSolidCircle(Vec2::ZERO, kPlayerRadius, 0, 32, Color4F(0.2f,0.7f,1.f,1.f));
    _sprite->addChild(draw);
    this->addChild(_sprite);

    // Physics body
    auto body = PhysicsBody::createCircle(kPlayerRadius,
        PhysicsMaterial(0.2f, 0.0f, 0.8f));
    body->setDynamic(true);
    body->setRotationEnable(false);
    body->setLinearDamping(4.0f);
    body->setCategoryBitmask(phys::CAT_PLAYER);
    body->setCollisionBitmask(0xFFFF);
    body->setContactTestBitmask(phys::MASK_PLAYER);
    body->setTag(phys::asInt(phys::Tag::PLAYER));
    this->setPhysicsBody(body);

    this->setPosition(startPos);
    this->scheduleUpdate();
    setTagEx(phys::asInt(phys::Tag::PLAYER));
    return true;
}

void Player::onEnter() {
    Entity::onEnter();
    bindKeyboard();
}
void Player::onExit() {
    unbindKeyboard();
    Entity::onExit();
}

void Player::bindKeyboard() {
    if (_kb) return;
    _kb = EventListenerKeyboard::create();
    _kb->onKeyPressed  = [this](EventKeyboard::KeyCode k, Event* ){ onKeyPressed(k); };
    _kb->onKeyReleased = [this](EventKeyboard::KeyCode k, Event* ){ onKeyReleased(k); };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(_kb, this);
}
void Player::unbindKeyboard() {
    if (_kb) {
        _eventDispatcher->removeEventListener(_kb);
        _kb = nullptr;
    }
}

void Player::onKeyPressed(EventKeyboard::KeyCode key) {
    switch (key) {
        case EventKeyboard::KeyCode::KEY_W: _holdW=true; break;
        case EventKeyboard::KeyCode::KEY_A: _holdA=true; break;
        case EventKeyboard::KeyCode::KEY_S: _holdS=true; break;
        case EventKeyboard::KeyCode::KEY_D: _holdD=true; break;
        case EventKeyboard::KeyCode::KEY_UP_ARROW:    _holdUp=true; break;
        case EventKeyboard::KeyCode::KEY_LEFT_ARROW:  _holdLeft=true; break;
        case EventKeyboard::KeyCode::KEY_DOWN_ARROW:  _holdDown=true; break;
        case EventKeyboard::KeyCode::KEY_RIGHT_ARROW: _holdRight=true; break;

        case EventKeyboard::KeyCode::KEY_SHIFT: _holdingRun=true; break;

        case EventKeyboard::KeyCode::KEY_J: pressFire();  break;
        case EventKeyboard::KeyCode::KEY_K: pressSlash(); break;
        default: break;
    }
}
void Player::onKeyReleased(EventKeyboard::KeyCode key) {
    switch (key) {
        case EventKeyboard::KeyCode::KEY_W: _holdW=false; break;
        case EventKeyboard::KeyCode::KEY_A: _holdA=false; break;
        case EventKeyboard::KeyCode::KEY_S: _holdS=false; break;
        case EventKeyboard::KeyCode::KEY_D: _holdD=false; break;
        case EventKeyboard::KeyCode::KEY_UP_ARROW:    _holdUp=false; break;
        case EventKeyboard::KeyCode::KEY_LEFT_ARROW:  _holdLeft=false; break;
        case EventKeyboard::KeyCode::KEY_DOWN_ARROW:  _holdDown=false; break;
        case EventKeyboard::KeyCode::KEY_RIGHT_ARROW: _holdRight=false; break;

        case EventKeyboard::KeyCode::KEY_SHIFT: _holdingRun=false; break;
        default: break;
    }
}

void Player::update(float dt) {
    // cooldowns
    if (_cdBullet > 0.f) _cdBullet = std::max(0.f, _cdBullet - dt);
    if (_cdSlash  > 0.f) _cdSlash  = std::max(0.f, _cdSlash  - dt);

    refreshMoveDir();
    applyMove(dt);

    // Quay mặt theo hướng đang di chuyển (nếu có)
    if (!_moveDir.isZero()) faceByDir(_moveDir);
}

void Player::refreshMoveDir() {
    Vec2 d(0,0);
    if (_holdA || _holdLeft)  d.x -= 1.f;
    if (_holdD || _holdRight) d.x += 1.f;
    if (_holdS || _holdDown)  d.y -= 1.f;
    if (_holdW || _holdUp)    d.y += 1.f;

    if (!d.isZero()) _moveDir = d.getNormalized();
    else             _moveDir = Vec2::ZERO;
}

void Player::applyMove(float /*dt*/) {
    auto* body = this->getPhysicsBody();
    if (!body) return;

    if (_moveDir.isZero()) {
        // phanh nhẹ bằng damping
        body->setVelocity(Vec2::ZERO);
        return;
    }
    const float v = currentMoveSpeed();
    body->setVelocity(_moveDir * v);
}

void Player::pressFire() { tryFire(); }
void Player::pressSlash(){ trySlash(); }

void Player::tryFire() {
    if (_cdBullet > 0.f) return;

    // Nếu đứng yên, bắn theo hướng nhìn trước đó
    float angleDeg = _lastFacingDeg;
    if (!_moveDir.isZero()) angleDeg = dirToAngleDeg(_moveDir);

    const float speed = 780.f;
    Vec2 spawn = this->getPosition() + Vec2::forAngle(CC_DEGREES_TO_RADIANS(angleDeg)) * (kPlayerRadius + 6.f);

    if (auto parent = this->getParent()) {
        auto b = Bullet::create(spawn, angleDeg, speed);
        parent->addChild(b);
    }
    _cdBullet = _cdBulletMax;
}

void Player::trySlash() {
    if (_cdSlash > 0.f) return;

    float angleDeg = _lastFacingDeg;
    if (!_moveDir.isZero()) angleDeg = dirToAngleDeg(_moveDir);

    const float r = 26.f;
    const float swing = -35.f; // quét nhẹ
    const float dur = 0.14f;

    if (auto parent = this->getParent()) {
        auto s = Slash::create(this->getPosition(), r, angleDeg + swing, dur);
        parent->addChild(s);
    }
    _cdSlash = _cdSlashMax;
}

void Player::faceByDir(const Vec2& dir) {
    if (dir.isZero()) return;
    _lastFacingDeg = dirToAngleDeg(dir);
    _sprite->setRotation(-_lastFacingDeg); // quay visual (tuỳ art)
}

float Player::dirToAngleDeg(const Vec2& d) const {
    // cocos angle 0° là +X; atan2(y,x) trả rad; đổi sang độ
    return CC_RADIANS_TO_DEGREES(std::atan2(d.y, d.x));
}

File Player.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"

class Player final : public Entity {
public:
    // Tạo nhanh 1 player mặc định (sprite màu, thân tròn)
    static Player* createDefault(const cocos2d::Vec2& startPos);

    // Tốc độ đi/chạy (có thể set lại sau khi create)
    void setWalkSpeed(float v) { _speedWalk = v; }
    void setRunSpeed (float v) { _speedRun  = v; }

    // Giao diện trigger hành động (nếu muốn gọi từ ngoài)
    void pressFire();   // bắn đạn
    void pressSlash();  // chém

protected:
    bool initWithDefault(const cocos2d::Vec2& startPos);

    void onEnter() override;
    void onExit()  override;
    void update(float dt) override;

private:
    // Input
    void bindKeyboard();
    void unbindKeyboard();
    void onKeyPressed (cocos2d::EventKeyboard::KeyCode key);
    void onKeyReleased(cocos2d::EventKeyboard::KeyCode key);

    // Movement
    void refreshMoveDir();            // tính _moveDir từ phím
    void applyMove(float dt);         // set velocity cho PhysicsBody

    // Combat
    void tryFire();
    void trySlash();

    // Helpers
    float currentMoveSpeed() const { return _holdingRun ? _speedRun : _speedWalk; }
    void  faceByDir(const cocos2d::Vec2& dir);
    float dirToAngleDeg(const cocos2d::Vec2& d) const;

private:
    // Visual
    cocos2d::Sprite* _sprite = nullptr;

    // Movement state
    bool _holdW=false,_holdA=false,_holdS=false,_holdD=false;
    bool _holdUp=false,_holdLeft=false,_holdDown=false,_holdRight=false;
    bool _holdingRun=false;
    cocos2d::Vec2 _moveDir = cocos2d::Vec2::ZERO;
    float _speedWalk = 180.f;
    float _speedRun  = 300.f;
    float _lastFacingDeg = 0.f;

    // Combat cooldowns
    float _cdBullet     = 0.f; // còn lại
    float _cdSlash      = 0.f; // còn lại
    float _cdBulletMax  = 0.18f;
    float _cdSlashMax   = 0.28f;

    // Input listener
    cocos2d::EventListenerKeyboard* _kb = nullptr;
};


Folder Classes/game/bosses
File BossGolem.cpp
#include "game/bosses/BossGolem.h"
USING_NS_CC;

BossGolem* BossGolem::create(){ auto p=new(std::nothrow) BossGolem(); if(p&&p->init()){p->autorelease();return p;} CC_SAFE_DELETE(p); return nullptr; }
bool BossGolem::init(){
    if(!Enemy::init()) return false;
    setTextureRect(Rect(0,0,72,72));
    setColor(Color3B(90,70,50));
    _hp = 20; _speed = 60.f;
    return true;
}
void BossGolem::takeHit(int dmg){
    _hp -= dmg;
    runAction(Sequence::create(TintTo::create(0.05f,200,160,120), TintTo::create(0.05f,255,255,255), nullptr));
    if(_hp<=0) removeFromParent();
}

File BossGolem.h
#pragma once
#include "game/Enemy.h"

class BossGolem : public Enemy {
public:
    static BossGolem* create();
    bool init() override;
    void takeHit(int dmg) override;   // giờ override OK
};


Folder Classes/game/enemies
File Goomba.cpp
// Goomba.cpp
#include "game/enemies/Goomba.h"
USING_NS_CC;
Goomba* Goomba::create(){ auto p=new(std::nothrow) Goomba(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Goomba::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(200,120,60));
    return true;
}

File Goomba.h
// Goomba.h
#pragma once
#include "game/Enemy.h"
class Goomba : public Enemy {
public:
    static Goomba* create();
    bool init() override;
};

File Spiker.cpp
// Spiker.cpp
#include "game/enemies/Spiker.h"
USING_NS_CC;
Spiker* Spiker::create(){ auto p=new(std::nothrow) Spiker(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Spiker::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(180,200,255));
    return true;
}

File Spiker.h
// Spiker.h
#pragma once
#include "game/Enemy.h"
class Spiker : public Enemy {
public:
    static Spiker* create();
    bool init() override;
};


Folder Classes/game/objects
File Coin.cpp
// Coin.cpp
#include "game/objects/Coin.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Coin* Coin::create(){ auto p=new(std::nothrow) Coin(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Coin::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::COIN);
    auto dn = DrawNode::create();
    dn->drawSolidCircle(Vec2::ZERO, 10, 0, 24, Color4F(1,0.85f,0,1));
    addChild(dn);
    auto body = PhysicsBody::createCircle(10);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);               // sensor-only
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Coin.h
// Coin.h
#pragma once
#include "game/Entity.h"
class Coin : public Entity {
public:
    static Coin* create();
    bool init() override;
};

File Crate.cpp
// Crate.cpp
#include "game/objects/Crate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Crate* Crate::create(){ auto p=new(std::nothrow) Crate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Crate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::CRATE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-16,-16},{16,16}, Color4F(0.6f,0.4f,0.2f,1));
    addChild(dn);
    auto b = PhysicsBody::createBox(Size(32,32), PhysicsMaterial(0.3f,0,0.9f));
    b->setDynamic(true);
    b->setCategoryBitmask(phys::CAT_CRATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}

File Crate.h
// Crate.h
#pragma once
#include "game/Entity.h"
class Crate : public Entity {
public:
    static Crate* create();
    bool init() override;
};

File Gate.cpp
// Gate.cpp
#include "game/objects/Gate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Gate* Gate::create(){ auto p=new(std::nothrow) Gate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Gate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::GATE);
    _dn = DrawNode::create();
    _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
    addChild(_dn);
    auto b = PhysicsBody::createBox(Size(24,80));
    b->setDynamic(false);
    b->setCategoryBitmask(phys::CAT_GATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}
void Gate::open(bool on){
    _open = on;
    if(auto* b=getPhysicsBody()){
        b->setEnabled(!on);
    }
    _dn->clear();
    if(on) _dn->drawRect({-12,-40},{12,40}, Color4F(0.2f,1,0.2f,1));     // khung trống
    else   _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
}

File Gate.h
// Gate.h
#pragma once
#include "game/Entity.h"
class Gate : public Entity {
public:
    static Gate* create();
    bool init() override;
    void open(bool on);
    bool isOpen() const { return _open; }
private:
    bool _open=false;
    cocos2d::DrawNode* _dn=nullptr;
};

File PressurePlate.cpp
#include "game/objects/PressurePlate.h"
#include "physics/PhysicsDefs.h"
#include "cocos2d.h"

USING_NS_CC;

bool PressurePlate::init(){
    if(!Node::init()) return false;

    const float ww = 48.f, hh = 10.f;
    auto body = PhysicsBody::createBox(Size(ww, hh));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_SENSOR);
    body->setCollisionBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    body->setContactTestBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    setPhysicsBody(body);

    setTagEx(phys::Tag::PLATE);

    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-ww/2,-hh/2), Vec2(ww/2,hh/2), Color4F(0.9f,0.2f,0.2f,0.9f));
    addChild(dn);

    return true;
}

File PressurePlate.h
// PressurePlate.h
#pragma once
#include "game/Entity.h"
class PressurePlate : public Entity {
public:
    static PressurePlate* create();
    bool init() override;
    void setCallback(const std::function<void(bool)>& cb){ _cb = cb; }
private:
    std::function<void(bool)> _cb;
    int _pressCount = 0;
};

File Star.cpp
// Star.cpp
#include "game/objects/Star.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Star* Star::create(){ auto p=new(std::nothrow) Star(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Star::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::STAR);
    auto dn = DrawNode::create();
    Vec2 pts[5];
    for(int i=0;i<5;++i){ float a = CC_DEGREES_TO_RADIANS(72*i-90); pts[i]=Vec2(0,14).rotateByAngle(Vec2::ZERO,a); }
    dn->drawPoly(pts,5,true,Color4F(1,1,0.2f,1));
    addChild(dn);
    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Star.h
// Star.h
#pragma once
#include "game/Entity.h"
class Star : public Entity {
public:
    static Star* create();
    bool init() override;
};

File Upgrade.cpp
// Upgrade.cpp
#include "game/objects/Upgrade.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Upgrade* Upgrade::create(){ auto p=new(std::nothrow) Upgrade(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Upgrade::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::UPGRADE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-10,-10},{10,10}, Color4F(0.2f,1,1,1));
    addChild(dn);
    auto body = PhysicsBody::createBox(Size(20,20));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Upgrade.h
// Upgrade.h
#pragma once
#include "game/Entity.h"
class Upgrade : public Entity {
public:
    static Upgrade* create();
    bool init() override;
};


Folder Classes/game/weapon
File Bullet.cpp
#include "game/weapon/Bullet.h"
#include "cocos2d.h"
#include <cmath>

USING_NS_CC;

static inline Vec2 deg2dir(float deg) {
    float rad = CC_DEGREES_TO_RADIANS(deg);
    return Vec2(std::cos(rad), std::sin(rad));
}

Bullet* Bullet::create(const Vec2& pos, float angleDeg, float speed) {
    return Bullet::create(pos, deg2dir(angleDeg), speed);
}

Bullet* Bullet::create(const Vec2& pos, const Vec2& dir, float speed) {
    auto p = new (std::nothrow) Bullet();
    if (p && p->init()) {
        p->autorelease();
        p->setTagEx(phys::Tag::BULLET);
        Vec2 vel = dir.getNormalized() * speed;
        p->configure(pos, vel);
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

bool Bullet::init() {
    if (!Entity::init()) return false;

    // Viz rất nhẹ: dùng DrawNode hoặc 1 sprite nhỏ
    _viz = Sprite::create(); // rỗng; vẽ bằng DrawNode con cho nhẹ
    this->addChild(_viz);

    // trail nhẹ bằng action
    this->setCascadeOpacityEnabled(true);
    return true;
}

void Bullet::configure(const Vec2& pos, const Vec2& vel, float radius, float lifetimeSec) {
    this->setPosition(pos);
    buildBody(radius);

    // vẽ “đạn” nhỏ
    auto dn = DrawNode::create();
    _viz->removeAllChildren();
    _viz->addChild(dn);
    dn->drawSolidCircle(Vec2::ZERO, radius, 0, 16, Color4F(1, 1, 0.2f, 0.95f));
    dn->drawCircle(Vec2::ZERO, radius, 0, 16, false, Color4F(0.1f, 0.1f, 0, 1));

    // set velocity
    if (auto body = this->getPhysicsBody()) {
        body->setVelocity(vel);
    }

    // xoay sprite theo hướng bay (để sau dễ thay bằng texture)
    this->setRotation(CC_RADIANS_TO_DEGREES(atan2f(vel.y, vel.x)));

    armAndDie(lifetimeSec);
}

void Bullet::buildBody(float radius) {
    auto body = PhysicsBody::createCircle(radius, PhysicsMaterial(0, 0, 0));
    body->setDynamic(true);
    body->setGravityEnable(false);
    body->setRotationEnable(false);
    body->setLinearDamping(0.0f);
    body->setCategoryBitmask(phys::CAT_BULLET);
    body->setContactTestBitmask(phys::MASK_BULLET);
    body->setCollisionBitmask(phys::CAT_SOLID | phys::CAT_ENEMY | phys::CAT_CRATE | phys::CAT_GATE);
    body->setTag((int)phys::Tag::BULLET);
    this->setPhysicsBody(body);
    // nhỏ nên cho group cao để không va chạm “đạn vs đạn” nếu cần:
    // body->setGroup(-10);
}

void Bullet::armAndDie(float lifetimeSec) {
    this->stopAllActions();
    auto seq = Sequence::create(
        DelayTime::create(lifetimeSec),
        FadeOut::create(0.08f),
        CallFunc::create([this]() { this->removeFromParent(); }),
        nullptr
    );
    this->runAction(seq);
}

File Bullet.h
#pragma once
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Bullet : public Entity {
public:
    // Overload 1: tạo từ pos + góc (độ) + speed
    static Bullet* create(const cocos2d::Vec2& pos, float angleDeg, float speed = 420.f);

    // Overload 2: tạo từ pos + hướng đơn vị (dir) + speed
    static Bullet* create(const cocos2d::Vec2& pos, const cocos2d::Vec2& dir, float speed = 420.f);

    bool init() override;

    void configure(const cocos2d::Vec2& pos,
                   const cocos2d::Vec2& vel,
                   float radius = 6.f,
                   float lifetimeSec = 2.0f);

    void setDamage(int dmg) { _damage = dmg; }
    int  getDamage() const { return _damage; }

private:
    void buildBody(float radius);
    void armAndDie(float lifetimeSec);

private:
    cocos2d::Sprite* _viz = nullptr;
    int _damage = 1;
};

File Slash.cpp
#include "game/weapon/Slash.h"
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"

USING_NS_CC;

Slash* Slash::create(const Vec2& pos, float r, float deg, float lifetimeSec) {
    auto p = new (std::nothrow) Slash();
    if (p && p->init()) {
        p->autorelease();
        p->setTagEx(phys::Tag::SLASH);
        p->configure(pos, r, deg, lifetimeSec);
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

bool Slash::init() {
    if (!Entity::init()) return false;

    // FX đơn giản để thấy vùng quét — có thể thay bằng Sprite/Particles
    _viz = DrawNode::create();
    this->addChild(_viz, 1);

    // Cho nhẹ, đừng nhận sự kiện chạm/chuột
    this->setCascadeOpacityEnabled(true);
    this->setOpacity(180);
    return true;
}

void Slash::configure(const Vec2& pos, float r, float deg, float lifetimeSec) {
    _radius = r;
    this->setPosition(pos);
    this->setRotation(deg); // quay cho đúng hướng vung chém

    buildBody(r);
    armAndDie(lifetimeSec);

    // Vẽ vòng tròn mờ (debug). Có thể tắt nếu không cần.
    _viz->clear();
    _viz->drawSolidCircle(Vec2::ZERO, r, 0, 32, Color4F(1, 1, 1, 0.08f));
    _viz->drawCircle(Vec2::ZERO, r, 0, 32, false, Color4F(1, 1, 1, 0.25f));
}

void Slash::buildBody(float r) {
    // Sensor hình tròn
    auto body = PhysicsBody::createCircle(r, PhysicsMaterial(0, 0, 0));
    body->setDynamic(false);           // sensor đứng yên theo Node
    body->setGravityEnable(false);
    body->setRotationEnable(false);
    body->setCategoryBitmask(phys::CAT_SENSOR);
    body->setContactTestBitmask(phys::MASK_SENSOR);
    body->setCollisionBitmask(0);      // sensor: không va chạm cứng
    body->setTag((int)phys::Tag::SLASH);

    this->setPhysicsBody(body);
}

void Slash::armAndDie(float lifetimeSec) {
    // Scale nhẹ để có cảm giác vung nhanh
    this->setScale(0.85f);
    this->stopAllActions();
    auto seq = Sequence::create(
        Spawn::createWithTwoActions(
            ScaleTo::create(lifetimeSec * 0.8f, 1.15f),
            FadeTo::create(lifetimeSec * 0.8f, 140)
        ),
        FadeOut::create(lifetimeSec * 0.2f),
        CallFunc::create([this]() { this->removeFromParent(); }),
        nullptr
    );
    this->runAction(seq);
}

File Slash.h
#pragma once
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Slash : public Entity {
public:
    // Tạo một nhát chém (sensor) tại pos, bán kính r, góc quay deg, tồn tại lifetimeSec
    static Slash* create(const cocos2d::Vec2& pos, float r, float deg, float lifetimeSec = 0.12f);

    bool init() override;

    // Cho phép tái cấu hình nếu muốn reuse
    void configure(const cocos2d::Vec2& pos, float r, float deg, float lifetimeSec);

private:
    void buildBody(float r);
    void armAndDie(float lifetimeSec);

private:
    cocos2d::DrawNode* _viz = nullptr;     // vẽ vòng tròn mờ (debug/FX nhẹ)
    float _radius = 16.f;
};


Folder Classes/physics
File PhysicsDefs.h
// Classes/physics/PhysicsDefs.h
#pragma once
#include <cstdint>

namespace phys {

using Bit = uint32_t;

// ---------------- Category bits (va chạm) ----------------
enum : Bit {
    CAT_NONE   = 0,
    CAT_WORLD  = 1u << 0,  // tường / nền / địa hình
    CAT_PLAYER = 1u << 1,
    CAT_ENEMY  = 1u << 2,
    CAT_ITEM   = 1u << 3,  // coin, star, upgrade...
    CAT_SENSOR = 1u << 4,  // chân (foot), trigger
    CAT_WEAPON = 1u << 5,  // slash, bullet...
    CAT_ALL    = 0xFFFFFFFFu
};

// ---------------- Tag cấp entity (đính vào Entity) ----------------
enum class Tag : int {
    NONE   = 0,
    PLAYER = 1,
    ENEMY  = 2,
    BULLET = 3,
    ITEM   = 4,
    WORLD  = 5,
    SLASH  = 6
};

// ---------------- Tag cấp shape/fixture (ví dụ sensor chân) ----------------
struct ShapeTag {
    enum Value : int {
        DEFAULT = 0,
        FOOT    = 1,
        SLASH   = 2
    };
};

// ---------------- Helper bitmask ----------------
// Tập tất cả bits
inline constexpr Bit all() { return CAT_ALL; }

// Lấy all trừ một số category chỉ định
template <typename... Bits>
inline Bit all(Bits... except) {
    Bit m = CAT_ALL;
    // fold expression: m &= ~except;
    (void)std::initializer_list<int>{ (m &= ~static_cast<Bit>(except), 0)... };
    return m;
}

// Gộp nhiều bits (bitwise OR an toàn)
template <typename... Bits>
inline Bit any(Bits... bs) {
    Bit m = 0;
    (void)std::initializer_list<int>{ (m |= static_cast<Bit>(bs), 0)... };
    return m;
}

} // namespace phys


Folder Classes/scenes
File GameScene.cpp
#include "scenes/GameScene.h"
#include "game/Player.h"
#include "ui/HUDLayer.h"

#include "game/Enemy.h"
#include "game/enemies/Goomba.h"
#include "game/enemies/Spiker.h"
#include "game/bosses/BossGolem.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Crate.h"
#include "game/objects/Gate.h"

#include "physics/PhysicsDefs.h"
#include "audio/include/AudioEngine.h"
#include <algorithm>

USING_NS_CC;

// -------------------------------------------------
Scene* GameScene::createScene() {
    auto scene = Scene::createWithPhysics();
    auto layer = GameScene::create();
    scene->addChild(layer);
    return scene;
}

bool GameScene::init() {
    if (!Layer::init()) return false;

    _scene = this->getScene();
    _world = _scene->getPhysicsWorld();
    _world->setGravity(Vec2(0, -980)); // ~ -9.8 m/s^2 nếu quy ước 100px = 1m

    _vs     = Director::getInstance()->getVisibleSize();
    _origin = Director::getInstance()->getVisibleOrigin();

    // Nền màu
    auto bg = LayerColor::create(Color4B(25,25,32,255));
    addChild(bg, -100);

    // World nền (ground dài 5 màn hình)
    _setupWorld();

    // Zones + items + enemies
    _spawnZones();

    // UI camera + HUD
    buildUICamera();
    buildHUD();

    // Player
    auto pNode = Player::create();                 // kiểu trả về có thể là Entity*
    _player = dynamic_cast<Player*>(pNode);
    CCASSERT(_player, "Player::create() must return a Player* (or derived)");
    addChild(_player, 5);
    _player->enablePhysics(_origin + Vec2(_vs.width*0.15f, _vs.height*0.30f));


    // HUD init
    _lives = 3; _score = 0; _starsHave = 0; _starsNeed = 5;
    if (_hud) {
        _hud->setZone(1, 5);
        _hud->setLives(_lives);
        _hud->setScore(_score);
        _hud->setStars(_starsHave, _starsNeed);
    }

    // Input & Contact
    _bindInput();

    auto cl = EventListenerPhysicsContact::create();
    cl->onContactBegin    = CC_CALLBACK_1(GameScene::_onContactBegin, this);
    cl->onContactSeparate = CC_CALLBACK_1(GameScene::_onContactSeparate, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(cl, this);
    _contact = cl;

    scheduleUpdate();
    return true;
}

void GameScene::onEnter() {
    Layer::onEnter();
}
void GameScene::onExit() {
    Layer::onExit();
}

// ----------------- world & zones -----------------
void GameScene::_setupWorld() {
    float worldW = _vs.width * 5.f;

    auto ground = Node::create();
    auto gBody = PhysicsBody::createBox(Size(worldW, 28.f), PhysicsMaterial(0.2f,0.f,1.f));
    gBody->setDynamic(false);
    gBody->setCategoryBitmask(phys::CAT_WORLD);
    gBody->setCollisionBitmask(phys::all());
    gBody->setContactTestBitmask(phys::all());
    ground->setPhysicsBody(gBody);
    ground->setPosition(_origin + Vec2(_vs.width*2.5f, _vs.height*0.12f));

    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-worldW/2.f, -14.f), Vec2(worldW/2.f, 14.f), Color4F(0.12f,0.85f,0.25f,1));
    ground->addChild(dn);
    addChild(ground);
}

static Node* mkPlat(Node* root, Vec2 p, Size sz, Color4F c){
    auto n = Node::create();
    auto b = PhysicsBody::createBox(sz, PhysicsMaterial(0.15f,0.f,0.2f));
    b->setDynamic(false);
    b->setCategoryBitmask(phys::CAT_WORLD);
    b->setCollisionBitmask(phys::all());
    b->setContactTestBitmask(phys::all());
    n->setPhysicsBody(b); n->setPosition(p);
    auto d = DrawNode::create();
    d->drawSolidRect(Vec2(-sz.width*0.5f, -sz.height*0.5f),
                     Vec2(sz.width*0.5f, sz.height*0.5f), c);
    n->addChild(d);
    root->addChild(n);
    return n;
}

void GameScene::_spawnZones() {
    _camL = _origin.x;
    _camR = _camL + _vs.width;

    for (int i=0; i<5; ++i) {
        float x0 = _origin.x + i * _vs.width;

        // BG mỗi zone đổi màu nhẹ
        auto zoneBg = LayerColor::create(Color4B(30+10*i, 34+5*i, 45+2*i, 255));
        zoneBg->setContentSize(_vs);
        zoneBg->setPosition(_origin + Vec2(i*_vs.width, 0));
        addChild(zoneBg, -90);

        // Platforms
        mkPlat(this, {x0 + 280.f, _origin.y + 260.f}, {160.f,16.f}, Color4F(0.4f,0.4f,0.7f,1));
        mkPlat(this, {x0 + 520.f, _origin.y + 310.f}, {160.f,16.f}, Color4F(0.4f,0.4f,0.7f,1));
        mkPlat(this, {x0 + 700.f, _origin.y + 230.f}, {130.f,16.f}, Color4F(0.35f,0.6f,0.7f,1));

        // Items
        for (int k=0; k<3; ++k) {
            auto c = Coin::create();
            c->setPosition({x0+360.f + k*40.f, _origin.y+340.f});
            addChild(c, 2);
        }
        if (i<5) {
            auto s = Star::create();
            s->setPosition({x0+520.f, _origin.y+360.f});
            addChild(s, 2);
        }

        // Enemies
        Enemy* e = nullptr;
        if (i < 2) {
            e = Goomba::create(); addChild(e, 2);
            e->enablePhysics({x0+420.f, _origin.y+200.f}, {42.f,42.f});
            e->setPatrol({x0+380.f,_origin.y+200.f},{x0+520.f,_origin.y+200.f});
        } else if (i < 4) {
            e = Spiker::create(); addChild(e, 2);
            e->enablePhysics({x0+540.f, _origin.y+200.f}, {42.f,42.f});
            e->setPatrol({x0+520.f,_origin.y+200.f},{x0+640.f,_origin.y+200.f});
        } else {
            e = BossGolem::create(); addChild(e, 2);
            e->enablePhysics({x0+720.f, _origin.y+220.f}, {72.f,72.f});
            e->setPatrol({x0+680.f,_origin.y+220.f},{x0+820.f,_origin.y+220.f});
        }
        if (e) {
            e->setTarget(_player);
            _enemies.pushBack(e);
        }
    }
}

// ----------------- UI/HUD -----------------
void GameScene::buildUICamera() {
    _uiCam = Camera::createOrthographic(_vs.width, _vs.height, 1.0f, 1024.0f);
    _uiCam->setCameraFlag(CameraFlag::USER1);
    _uiCam->setPosition(_origin + Vec2(_vs.width*0.5f, _vs.height*0.5f));
    addChild(_uiCam, 999);
}
void GameScene::buildHUD() {
    _hud = HUDLayer::create();
    _hud->setCameraMask((unsigned short)CameraFlag::USER1);
    addChild(_hud, 100);
}

// ----------------- Input -----------------
void GameScene::_bindInput() {
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin) {
            if (c==EventKeyboard::KeyCode::KEY_R && _gameOver) _restartLevel();
            if ((c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) && _gameWin) _returnMenu();
            return;
        }
        if (!_player) return;
        switch (c) {
            case EventKeyboard::KeyCode::KEY_A:
            case EventKeyboard::KeyCode::KEY_LEFT_ARROW:  _player->setMoveDir({-1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_D:
            case EventKeyboard::KeyCode::KEY_RIGHT_ARROW: _player->setMoveDir({ 1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_W:
            case EventKeyboard::KeyCode::KEY_UP_ARROW:
            case EventKeyboard::KeyCode::KEY_SPACE: _player->jump(); break;
            case EventKeyboard::KeyCode::KEY_J: _doShoot(); break;
            case EventKeyboard::KeyCode::KEY_K: _doSlash(); break;
            default: break;
        }
    };
    l->onKeyReleased = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin || !_player) return;
        if (c==EventKeyboard::KeyCode::KEY_A || c==EventKeyboard::KeyCode::KEY_LEFT_ARROW ||
            c==EventKeyboard::KeyCode::KEY_D || c==EventKeyboard::KeyCode::KEY_RIGHT_ARROW)
            _player->setMoveDir({0.f,0.f});
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}

// ----------------- Combat helpers -----------------
void GameScene::_doShoot(){
    if(!_player) return;
    int dir = _player->facing(); // -1 hoặc 1
    cocos2d::Vec2 origin = _player->getPosition() + cocos2d::Vec2(dir*18.f, 12.f);

    // Dùng overload: Bullet::create(origin, velocity, lifeSec)
    auto b = Bullet::create(origin, cocos2d::Vec2(700.f * dir, 0.f), 1.5f);
    if (b) addChild(b, 6);
}

void GameScene::_doSlash(){
    if(!_player) return;
    int dir = _player->facing(); // -1 hoặc 1
    cocos2d::Vec2 origin = _player->getPosition() + cocos2d::Vec2(dir*28.f, 0.f);

    // Slash::create(origin, angleRad, sizeOrRange, durationSec)
    float angle = (dir > 0) ? 0.0f : 3.14159265f;
    auto s = Slash::create(origin, angle, 36.f, 0.12f);
    if (s) addChild(s, 6);
}


static bool hasCat(Node* n, uint32_t cat){
    return n && n->getPhysicsBody() &&
           (n->getPhysicsBody()->getCategoryBitmask() & cat);
}

// ----------------- Contact -----------------
bool GameScene::_onContactBegin(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();

    // FOOT ↔ WORLD
    if ((A->getTag()==phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        _player->incFoot(1);
        return true;
    }

    // Player ↔ Item
    Node* item = nullptr;
    if (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ITEM)) item=b;
    else if (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ITEM)) item=a;
    if (item) {
        if (dynamic_cast<Star*>(item))   { _setStars(_starsHave+1, _starsNeed); _addScore(50); }
        else if (dynamic_cast<Coin*>(item))    { _addScore(10); }
        else if (dynamic_cast<Upgrade*>(item)) { _addScore(25); }
        item->removeFromParent();
        _checkWin();
        return false;
    }

    // Bullet/Slash ↔ Enemy
    auto isSlash = [&](PhysicsShape* s){ return s->getTag()==phys::ShapeTag::SLASH; };
    Node* enemy=nullptr;
    if ( (hasCat(a,phys::CAT_BULLET)||isSlash(A)) && hasCat(b,phys::CAT_ENEMY)) enemy=b;
    else if ( (hasCat(b,phys::CAT_BULLET)||isSlash(B)) && hasCat(a,phys::CAT_ENEMY)) enemy=a;
    if (enemy) {
        if (auto e = dynamic_cast<Enemy*>(enemy)) e->takeHit(isSlash(A)||isSlash(B)?2:1);
        if (hasCat(a,phys::CAT_BULLET)) a->removeFromParent();
        if (hasCat(b,phys::CAT_BULLET)) b->removeFromParent();
        _addScore(20);
        return false;
    }

    // Enemy ↔ Player
    if ( (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ENEMY)) ||
         (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ENEMY)) ) {
        if (!_player->invincible()) {
            Node* eNode = hasCat(a,phys::CAT_ENEMY)? a : b;
            float dir = (_player->getPositionX() < eNode->getPositionX()) ? -1.f : 1.f;
            _player->hurt(1, Vec2(-dir*220.f, 260.f));
            _setLives(_lives-1);
            if (_lives<=0) { _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart"); }
        }
        return true;
    }

    return true;
}

void GameScene::_onContactSeparate(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();
    if ((A->getTag()==phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        _player->incFoot(-1);
    }
}

// ----------------- Update -----------------
void GameScene::update(float) {
    if (_gameOver || _gameWin) return;

    // Camera follow theo X
    float x = _player->getPositionX();
    float target = clampf(x, _camL + _vs.width*0.5f, _camR - _vs.width*0.5f);
    this->getScene()->getDefaultCamera()->setPositionX(target);

    // Sang zone kế
    if (_player->getPositionX() > _camR - 4.0f) {
        int next = std::min<int>(4, static_cast<int>((_camR - _origin.x) / _vs.width + 0.5f));
        _camL = _origin.x + next * _vs.width;
        _camR = _camL + _vs.width;
        if (_hud) _hud->setZone(next+1, 5);
    }

    // Rơi khỏi map
    if (_player->getPositionY() < _origin.y - 120.f) {
        _setLives(_lives-1);
        if (_lives<=0) {
            _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart");
        } else {
            _player->setPosition(_origin + Vec2(_vs.width*0.15f, _vs.height*0.40f));
        }
    }
}

// ----------------- HUD helpers -----------------
void GameScene::_setLives(int v){
    _lives = std::max(0, v);
    if (_hud) _hud->setLives(_lives);
}
void GameScene::_addScore(int v){
    _score += v;
    if (_hud) _hud->setScore(_score);
}
void GameScene::_setStars(int have, int need){
    _starsHave = have; _starsNeed = need;
    if (_hud) _hud->setStars(_starsHave, _starsNeed);
}
void GameScene::_checkWin(){
    if (_starsHave >= _starsNeed && !_gameWin){
        _gameWin = true;
        _showOverlay("YOU WIN!\nPress [Enter] to Menu");
    }
}

void GameScene::_restartLevel(){
    Director::getInstance()->replaceScene(GameScene::createScene());
}
void GameScene::_returnMenu(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, Scene::create()));
}
void GameScene::_showOverlay(const std::string& text){
    if(!_overlay){
        _overlay = Label::createWithSystemFont(text, "Arial", 46);
        _overlay->setAlignment(TextHAlignment::CENTER);
        _overlay->setAnchorPoint({0.5f,0.5f});
        _overlay->setColor(Color3B::WHITE);
        _overlay->enableShadow();
        addChild(_overlay, 99);
    }
    _overlay->setString(text);
    _overlay->setPosition(_origin + Vec2(_vs.width*0.5f, _vs.height*0.6f));
}

File GameScene.h
#pragma once
#include "cocos2d.h"
#include "game/Player.h"
#include "game/Enemy.h"
#include "physics/PhysicsDefs.h"

USING_NS_CC;

class HUDLayer;

class GameScene : public Layer {
public:
    // Tạo Scene có Physics + add GameScene layer
    static Scene* createScene();
    CREATE_FUNC(GameScene);

    bool init() override;
    void onEnter() override;
    void onExit() override;
    void update(float dt) override;

private:
    // ---- WORLD/PHYSICS ----
    Scene*        _scene = nullptr;
    PhysicsWorld* _world = nullptr;
    Size _vs;
    Vec2 _origin;

    // ---- PLAYER/ENEMY ----
    Player* _player = nullptr;
    Vector<Enemy*> _enemies;

    // ---- CAMERA/ZONES ----
    float _camL = 0.f, _camR = 0.f;

    // ---- UI/HUD ----
    Camera*   _uiCam   = nullptr;
    HUDLayer* _hud     = nullptr;
    Label*    _overlay = nullptr;

    int  _score     = 0;
    int  _lives     = 3;
    int  _starsHave = 0;
    int  _starsNeed = 5;
    bool _gameOver  = false;
    bool _gameWin   = false;

    // ---- INPUT/LISTENERS ----
    EventListenerKeyboard*       _kb      = nullptr;
    EventListenerPhysicsContact* _contact = nullptr;

private:
    // ===== BUILD / WORLD =====
    void _setupWorld();     // ground dài + vật lý nền
    void _spawnZones();     // platforms, items, enemies mỗi zone

    // ===== UI =====
    void buildUICamera();
    void buildHUD();

    // ===== INPUT =====
    void _bindInput();
    void _doShoot();
    void _doSlash();

    // ===== CONTACT =====
    bool _onContactBegin(PhysicsContact& c);
    void _onContactSeparate(PhysicsContact& c);

    // ===== HUD/STATE =====
    void _setLives(int v);
    void _addScore(int v);
    void _setStars(int have, int need);
    void _checkWin();
    void _showOverlay(const std::string& text);

    // ===== FLOW =====
    void _restartLevel();
    void _returnMenu();
};

File MenuScene.cpp
// MenuScene.cpp
#include "scenes/MenuScene.h"
#include "scenes/GameScene.h"
USING_NS_CC;

Scene* MenuScene::createScene(){ return MenuScene::create(); }
bool MenuScene::init(){
    if(!Scene::init()) return false;
    auto vs = Director::getInstance()->getVisibleSize();
    auto origin = Director::getInstance()->getVisibleOrigin();
    auto title = Label::createWithSystemFont("MyGame", "Arial", 48);
    title->setPosition(origin + Vec2(vs.width/2, vs.height*0.65f));
    auto hint  = Label::createWithSystemFont("[ENTER] New Game   |   [ESC] Quit","Arial",24);
    hint->setPosition(origin + Vec2(vs.width/2, vs.height*0.45f));
    addChild(title); addChild(hint);
    _bindInput();
    return true;
}
void MenuScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*){
        if(c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) _goGame();
        else if(c==EventKeyboard::KeyCode::KEY_ESCAPE) Director::getInstance()->end();
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
}
void MenuScene::_goGame(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, GameScene::createScene()));
}

File MenuScene.h
// MenuScene.h
#pragma once
#include "cocos2d.h"
class MenuScene : public cocos2d::Scene {
public:
    CREATE_FUNC(MenuScene);
    static cocos2d::Scene* createScene();
    bool init() override;
private:
    void _bindInput();
    void _goGame();
};


Folder Classes/ui
File HUDLayer.cpp
#include "ui/HUDLayer.h"
USING_NS_CC;

bool HUDLayer::init(){
    if(!Layer::init()) return false;
    auto vs = Director::getInstance()->getVisibleSize();
    auto origin = Director::getInstance()->getVisibleOrigin();

    _lblLives = Label::createWithSystemFont("Lives: 3","Arial",22);
    _lblScore = Label::createWithSystemFont("Score: 0","Arial",22);
    _lblStars = Label::createWithSystemFont("Stars: 0/5","Arial",22);
    _lblZone  = Label::createWithSystemFont("Zone: 1/5","Arial",22);

    _lblLives->setAnchorPoint({0,1});
    _lblLives->setPosition(origin + Vec2(10, vs.height-10));

    _lblScore->setAnchorPoint({1,1});
    _lblScore->setPosition(origin + Vec2(vs.width-10, vs.height-10));

    _lblStars->setAnchorPoint({1,1});
    _lblStars->setPosition(origin + Vec2(vs.width-10, vs.height-40));

    _lblZone->setAnchorPoint({0,1});
    _lblZone->setPosition(origin + Vec2(10, vs.height-40));

    addChild(_lblLives); addChild(_lblScore); addChild(_lblStars); addChild(_lblZone);
    return true;
}
void HUDLayer::setScore(int v){ _score=v; if(_lblScore) _lblScore->setString(StringUtils::format("Score: %d",v)); }
void HUDLayer::setLives(int v){ _lives=v; if(_lblLives) _lblLives->setString(StringUtils::format("Lives: %d",v)); }
void HUDLayer::setStars(int have, int need){
    _stars=have; _need=need;
    if(_lblStars) _lblStars->setString(StringUtils::format("Stars: %d/%d", _stars, _need));
}
void HUDLayer::setZone(int idx, int total){
    _zoneIdx=idx; _zoneTot=total;
    if(_lblZone) _lblZone->setString(StringUtils::format("Zone: %d/%d", _zoneIdx, _zoneTot));
}

File HUDLayer.h
#pragma once
#include "cocos2d.h"

class HUDLayer : public cocos2d::Layer {
public:
    CREATE_FUNC(HUDLayer);
    bool init() override;
    void setScore(int v);
    void setLives(int v);
    void setStars(int have, int need);
    void setZone(int idx, int total);

private:
    cocos2d::Label* _lblScore=nullptr;
    cocos2d::Label* _lblLives=nullptr;
    cocos2d::Label* _lblStars=nullptr;
    cocos2d::Label* _lblZone=nullptr;
    int _score=0, _lives=3, _stars=0, _need=5;
    int _zoneIdx=1, _zoneTot=5;
};


