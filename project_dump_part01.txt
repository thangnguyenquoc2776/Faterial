===== PROJECT TREE =====
./
├── CMakeLists.txt
└── Classes
    ├── main.cpp
    ├── core
    │   ├── AppDelegate.cpp
    │   ├── AppDelegate.h
    │   └── CrashGuard.h
    ├── game
    │   ├── Enemy.cpp
    │   ├── Enemy.h
    │   ├── Entity.cpp
    │   ├── Entity.h
    │   ├── Player.cpp
    │   ├── Player.h
    │   ├── bosses
    │   │   ├── BossGolem.cpp
    │   │   └── BossGolem.h
    │   ├── enemies
    │   │   ├── Goomba.cpp
    │   │   ├── Goomba.h
    │   │   ├── Spiker.cpp
    │   │   └── Spiker.h
    │   ├── loot
    │   │   ├── LootTable.cpp
    │   │   └── LootTable.h
    │   ├── map
    │   │   ├── LevelBuilder.cpp
    │   │   └── LevelBuilder.h
    │   ├── objects
    │   │   ├── Chest.cpp
    │   │   ├── Chest.h
    │   │   ├── Coin.cpp
    │   │   ├── Coin.h
    │   │   ├── Crate.cpp
    │   │   ├── Crate.h
    │   │   ├── Gate.cpp
    │   │   ├── Gate.h
    │   │   ├── PressurePlate.cpp
    │   │   ├── PressurePlate.h
    │   │   ├── Star.cpp
    │   │   ├── Star.h
    │   │   ├── Upgrade.cpp
    │   │   └── Upgrade.h
    │   ├── upgrades
    │   │   ├── UpgradeSystem.cpp
    │   │   └── UpgradeSystem.h
    │   └── weapon
    │       ├── Bullet.cpp
    │       ├── Bullet.h
    │       ├── Slash.cpp
    │       └── Slash.h
    ├── physics
    │   └── PhysicsDefs.h
    ├── scenes
    │   ├── GameScene.cpp
    │   ├── GameScene.h
    │   ├── MenuScene.cpp
    │   └── MenuScene.h
    └── ui
        ├── HUDLayer.cpp
        └── HUDLayer.h

===== FILE MANIFEST =====
- CMakeLists.txt — 7139 bytes — ok
- Classes/main.cpp — 178 bytes — ok
- Classes/core/AppDelegate.cpp — 1209 bytes — ok
- Classes/core/AppDelegate.h — 362 bytes — ok
- Classes/core/CrashGuard.h — 195 bytes — ok
- Classes/game/Enemy.cpp — 3469 bytes — ok
- Classes/game/Enemy.h — 1144 bytes — ok
- Classes/game/Entity.cpp — 187 bytes — ok
- Classes/game/Entity.h — 788 bytes — ok
- Classes/game/Player.cpp — 8545 bytes — ok
- Classes/game/Player.h — 2682 bytes — ok
- Classes/game/bosses/BossGolem.cpp — 1187 bytes — ok
- Classes/game/bosses/BossGolem.h — 363 bytes — ok
- Classes/game/enemies/Goomba.cpp — 327 bytes — ok
- Classes/game/enemies/Goomba.h — 153 bytes — ok
- Classes/game/enemies/Spiker.cpp — 328 bytes — ok
- Classes/game/enemies/Spiker.h — 153 bytes — ok
- Classes/game/loot/LootTable.cpp — 3330 bytes — ok
- Classes/game/loot/LootTable.h — 877 bytes — ok
- Classes/game/map/LevelBuilder.cpp — 5294 bytes — ok
- Classes/game/map/LevelBuilder.h — 468 bytes — ok
- Classes/game/objects/Chest.cpp — 1653 bytes — ok
- Classes/game/objects/Chest.h — 346 bytes — ok
- Classes/game/objects/Coin.cpp — 1583 bytes — ok
- Classes/game/objects/Coin.h — 279 bytes — ok
- Classes/game/objects/Crate.cpp — 792 bytes — ok
- Classes/game/objects/Crate.h — 152 bytes — ok
- Classes/game/objects/Gate.cpp — 1059 bytes — ok
- Classes/game/objects/Gate.h — 287 bytes — ok
- Classes/game/objects/PressurePlate.cpp — 725 bytes — ok
- Classes/game/objects/PressurePlate.h — 320 bytes — ok
- Classes/game/objects/Star.cpp — 826 bytes — ok
- Classes/game/objects/Star.h — 149 bytes — ok
- Classes/game/objects/Upgrade.cpp — 730 bytes — ok
- Classes/game/objects/Upgrade.h — 158 bytes — ok
- Classes/game/upgrades/UpgradeSystem.cpp — 1454 bytes — ok
- Classes/game/upgrades/UpgradeSystem.h — 1099 bytes — ok
- Classes/game/weapon/Bullet.cpp — 1809 bytes — ok
- Classes/game/weapon/Bullet.h — 473 bytes — ok
- Classes/game/weapon/Slash.cpp — 2497 bytes — ok
- Classes/game/weapon/Slash.h — 381 bytes — ok
- Classes/physics/PhysicsDefs.h — 3585 bytes — ok
- Classes/scenes/GameScene.cpp — 10082 bytes — ok
- Classes/scenes/GameScene.h — 1671 bytes — ok
- Classes/scenes/MenuScene.cpp — 1644 bytes — ok
- Classes/scenes/MenuScene.h — 375 bytes — ok
- Classes/ui/HUDLayer.cpp — 3219 bytes — ok
- Classes/ui/HUDLayer.h — 1048 bytes — ok



Folder .
File CMakeLists.txt
cmake_minimum_required(VERSION 3.20)

# ================== Project meta ==================
set(APP_NAME Faterial)
project(${APP_NAME} C CXX)

# ================== MSVC runtime & common defs ==================
if (MSVC)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL" CACHE STRING "" FORCE)
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS NOMINMAX)
    add_compile_options(/MP /utf-8)
endif()

# ================== Cocos2d-x engine ==================
if(NOT DEFINED BUILD_ENGINE_DONE)
    set(COCOS2DX_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cocos2d)
    set(CMAKE_MODULE_PATH ${COCOS2DX_ROOT_PATH}/cmake/Modules/)
    include(CocosBuildSet)
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos ${ENGINE_BINARY_PATH}/cocos/core)
endif()

# ================== Resources ==================
set(GAME_RES_FOLDER "${CMAKE_CURRENT_SOURCE_DIR}/Resources")
if(APPLE OR WINDOWS)
    cocos_mark_multi_resources(common_res_files RES_TO "Resources" FOLDERS ${GAME_RES_FOLDER})
endif()

# ================== Game headers & sources ==================
set(GAME_HEADER
    # core
    Classes/core/AppDelegate.h
    Classes/core/CrashGuard.h

    # physics
    Classes/physics/PhysicsDefs.h

    # ui
    Classes/ui/HUDLayer.h

    # scenes
    Classes/scenes/MenuScene.h
    Classes/scenes/GameScene.h

    # game base
    Classes/game/Entity.h
    Classes/game/Player.h
    Classes/game/Enemy.h

    # enemies / bosses
    Classes/game/enemies/Goomba.h
    Classes/game/enemies/Spiker.h
    Classes/game/bosses/BossGolem.h

    # objects
    Classes/game/objects/Coin.h
    Classes/game/objects/Star.h
    Classes/game/objects/Upgrade.h
    Classes/game/objects/Crate.h
    Classes/game/objects/Gate.h
    Classes/game/objects/PressurePlate.h
    Classes/game/objects/Chest.h

    # weapon
    Classes/game/weapon/Bullet.h
    Classes/game/weapon/Slash.h

    # loot & map
    Classes/game/loot/LootTable.h
    Classes/game/map/LevelBuilder.h
)

set(GAME_SRC
    # core
    Classes/core/AppDelegate.cpp

    # ui
    Classes/ui/HUDLayer.cpp

    # scenes
    Classes/scenes/MenuScene.cpp
    Classes/scenes/GameScene.cpp

    # game base
    Classes/game/Entity.cpp
    Classes/game/Player.cpp
    Classes/game/Enemy.cpp

    # enemies / bosses
    Classes/game/enemies/Goomba.cpp
    Classes/game/enemies/Spiker.cpp
    Classes/game/bosses/BossGolem.cpp

    # objects
    Classes/game/objects/Coin.cpp
    Classes/game/objects/Star.cpp
    Classes/game/objects/Upgrade.cpp
    Classes/game/objects/Crate.cpp
    Classes/game/objects/Gate.cpp
    Classes/game/objects/PressurePlate.cpp
    Classes/game/objects/Chest.cpp

    # weapon
    Classes/game/weapon/Bullet.cpp
    Classes/game/weapon/Slash.cpp

    # loot & map
    Classes/game/loot/LootTable.cpp
    Classes/game/map/LevelBuilder.cpp
)

# ================== Platform glue ==================
if(ANDROID)
    list(APPEND GAME_SRC proj.android/app/jni/hellocpp/main.cpp)

elseif(LINUX)
    list(APPEND GAME_SRC proj.linux/main.cpp)

elseif(WINDOWS)
    list(APPEND GAME_HEADER
        proj.win32/main.h
        proj.win32/resource.h
    )
    list(APPEND GAME_SRC
        proj.win32/main.cpp
        proj.win32/game.rc
        ${common_res_files}
    )

elseif(APPLE)
    if(IOS)
        list(APPEND GAME_HEADER
            proj.ios_mac/ios/AppController.h
            proj.ios_mac/ios/RootViewController.h
        )
        set(APP_UI_RES
            proj.ios_mac/ios/LaunchScreen.storyboard
            proj.ios_mac/ios/LaunchScreenBackground.png
            proj.ios_mac/ios/Images.xcassets
        )
        list(APPEND GAME_SRC
            proj.ios_mac/ios/main.m
            proj.ios_mac/ios/AppController.mm
            proj.ios_mac/ios/RootViewController.mm
            proj.ios_mac/ios/Prefix.pch
            ${APP_UI_RES}
        )
    elseif(MACOSX)
        set(APP_UI_RES
            proj.ios_mac/mac/Icon.icns
            proj.ios_mac/mac/Info.plist
        )
        list(APPEND GAME_SRC
            proj.ios_mac/mac/main.cpp
            proj.ios_mac/mac/Prefix.pch
            ${APP_UI_RES}
        )
    endif()
    list(APPEND GAME_SRC ${common_res_files})
endif()

# ================== Target ==================
set(all_code_files ${GAME_HEADER} ${GAME_SRC})

if(NOT ANDROID)
    add_executable(${APP_NAME} ${all_code_files})
else()
    add_library(${APP_NAME} SHARED ${all_code_files})
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos/platform/android ${ENGINE_BINARY_PATH}/cocos/platform)
    target_link_libraries(${APP_NAME} PRIVATE -Wl,--whole-archive cpp_android_spec -Wl,--no-whole-archive)
endif()

# ================== Include paths ==================
target_include_directories(${APP_NAME}
    PRIVATE Classes
    PRIVATE Classes/core
    PRIVATE Classes/physics
    PRIVATE Classes/ui
    PRIVATE Classes/scenes
    PRIVATE Classes/game
    PRIVATE Classes/game/enemies
    PRIVATE Classes/game/bosses
    PRIVATE Classes/game/objects
    PRIVATE Classes/game/weapon
    PRIVATE Classes/game/loot
    PRIVATE Classes/game/map
    PRIVATE ${COCOS2DX_ROOT_PATH}/cocos/audio/include/  # AudioEngine
)

# ================== Link engine + system libs ==================
target_link_libraries(${APP_NAME} PRIVATE cocos2d)
if (MSVC)
    target_link_options(${APP_NAME} PRIVATE /NODEFAULTLIB:LIBCMT /IGNORE:4098)
    target_link_libraries(${APP_NAME} PRIVATE winmm DbgHelp legacy_stdio_definitions)
endif()

# ================== App config & copy resources/DLL ==================
setup_cocos_app_config(${APP_NAME})

# Ép exe & dll vào build/bin (không tạo Debug/Release con)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
foreach(cfg Debug Release RelWithDebInfo MinSizeRel)
    set_target_properties(${APP_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        LIBRARY_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        ARCHIVE_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/lib
    )
endforeach()

# Windows: copy DLL engine (glew, glfw, openal, …) về cạnh .exe
if(WINDOWS)
    cocos_copy_target_dll(${APP_NAME})
endif()

# Copy Resources vào cạnh .exe (Windows/Linux/macOS)
if(LINUX OR WINDOWS)
    cocos_get_resource_path(APP_RES_DIR ${APP_NAME})
    cocos_copy_target_res(${APP_NAME} LINK_TO ${APP_RES_DIR} FOLDERS ${GAME_RES_FOLDER})
endif()

# (macOS/iOS) gán tài nguyên UI
if(APPLE)
    set_target_properties(${APP_NAME} PROPERTIES RESOURCE "${APP_UI_RES}")
    if(MACOSX)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/mac/Info.plist")
    elseif(IOS)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/ios/Info.plist")
        set_xcode_property(${APP_NAME} ASSETCATALOG_COMPILER_APPICON_NAME "AppIcon")
    endif()
endif()


Folder Classes
File main.cpp
#include "core/AppDelegate.h"
#include "cocos2d.h"

USING_NS_CC;

int main(int argc, char** argv) {
    AppDelegate app;
    return Application::getInstance()->run();
}


Folder Classes/core
File AppDelegate.cpp
// AppDelegate.cpp
#include "core/AppDelegate.h"
#include "base/CCDirector.h"
#include "platform/CCGLView.h"
#include "scenes/MenuScene.h"
USING_NS_CC;

AppDelegate::AppDelegate() {}
AppDelegate::~AppDelegate() {}

void AppDelegate::initGLContextAttrs(){
    GLContextAttrs a{8,8,8,8,24,8};
    GLView::setGLContextAttrs(a);
}

bool AppDelegate::applicationDidFinishLaunching(){
    auto* director = Director::getInstance();
    auto* glview = director->getOpenGLView();
    if(!glview){
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
        glview = GLViewImpl::createWithRect("Faterial", Rect(0,0,1920,1080));
#else
        glview = GLViewImpl::create("Faterial");
#endif
        director->setOpenGLView(glview);
    }
    director->setAnimationInterval(1.0f/60.0f);
#if COCOS2D_DEBUG
    director->setDisplayStats(true);
#endif
    glview->setDesignResolutionSize(1280, 720, ResolutionPolicy::NO_BORDER);
    director->runWithScene(MenuScene::createScene());
    return true;
}
void AppDelegate::applicationDidEnterBackground(){ Director::getInstance()->stopAnimation(); }
void AppDelegate::applicationWillEnterForeground(){ Director::getInstance()->startAnimation(); }

File AppDelegate.h
// AppDelegate.h
#pragma once
#include "cocos2d.h"
class AppDelegate : private cocos2d::Application {
public:
    AppDelegate();
    virtual ~AppDelegate();
    virtual void initGLContextAttrs();
    virtual bool applicationDidFinishLaunching();
    virtual void applicationDidEnterBackground();
    virtual void applicationWillEnterForeground();
};

File CrashGuard.h
#pragma once
#include <cstdio>
#define CG_LOGF(path, fmt, ...) \
  do { FILE* f=nullptr; fopen_s(&f, (path), "a"); if(f){std::fprintf(f, fmt "\n", ##__VA_ARGS__); std::fclose(f);} } while(0)


Folder Classes/game
File Enemy.cpp
#include "game/Enemy.h"
#include "game/Player.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"

using namespace cocos2d;

static inline void drawMiniHp(DrawNode* dn, int cur, int max) {
    if (!dn) return;
    dn->clear();
    const float W=30.f, H=4.f, pad=1.f;
    dn->drawSolidRect(Vec2(-W*0.5f, 10), Vec2(W*0.5f, 10+H), Color4F(0,0,0,0.55f));
    float ratio = (max>0)? (float)cur/(float)max : 0.f;
    float ww = (W-2*pad) * ratio;
    dn->drawSolidRect(Vec2(-W*0.5f+pad, 10+pad), Vec2(-W*0.5f+pad+ww, 10+H-pad),
                      Color4F(0.25f,0.95f,0.35f,1));
}

bool Enemy::init() {
    if (!Entity::init()) return false;

    setTagEx(static_cast<int>(phys::Tag::ENEMY));

    _sprite = Sprite::create();
    _sprite->setTextureRect(Rect(0,0,42,42));
    _sprite->setColor(Color3B(200,70,70));
    addChild(_sprite);

    _hpMini = DrawNode::create();
    addChild(_hpMini, 5);
    drawMiniHp(_hpMini, _hp, _maxHp);

    schedule([this](float){ updateEnemy(0); }, "enemy.tick");
    return true;
}

void Enemy::enablePhysics(const Vec2& pos, const Size& bodySize) {
    _body = buildOrUpdateBody(bodySize);
    applyEnemyMasks();
    setPosition(pos);
}

PhysicsBody* Enemy::buildOrUpdateBody(const Size& sz) {
    Size box = sz.width<1||sz.height<1 ? Size(42,42) : sz;

    PhysicsBody* body = _body;
    if (!body) {
        body = PhysicsBody::createBox(box, PhysicsMaterial(0.2f, 0.0f, 0.4f));
        body->setDynamic(true);
        body->setRotationEnable(false);
        addComponent(body);
    } else {
        auto shapes = body->getShapes();
        for (auto s : shapes) body->removeShape(s);
        body->addShape(PhysicsShapeBox::create(box, PhysicsMaterial(0.2f,0.0f,0.4f)));
    }
    body->setLinearDamping(0.1f);
    body->setMass(1.0f);
    return body;
}

void Enemy::applyEnemyMasks() {
    if (!_body) return;
    _body->setCategoryBitmask(static_cast<int>(phys::CAT_ENEMY));
    _body->setCollisionBitmask(static_cast<int>(
        phys::CAT_WORLD | phys::CAT_PLAYER | phys::CAT_CRATE | phys::CAT_GATE));
    _body->setContactTestBitmask(static_cast<int>(phys::CAT_ALL));
}

void Enemy::setPatrol(const Vec2& a, const Vec2& b) {
    _pA = a; _pB = b;
    if (_pA.x > _pB.x) std::swap(_pA, _pB);
    if (getPosition().fuzzyEquals(Vec2::ZERO, 0.1f))
        setPosition((_pA + _pB) * 0.5f);
}

void Enemy::updateEnemy(float) {
    if (!_body) return;
    if (_pA != _pB) {
        float x = getPositionX();
        if (_dir > 0 && x >= _pB.x) _dir = -1;
        else if (_dir < 0 && x <= _pA.x) _dir = +1;
        Vec2 v = _body->getVelocity();
        v.x = _dir * _moveSpeed;
        v.y = std::max(v.y, -900.0f);
        _body->setVelocity(v);
    }
}

void Enemy::takeHit(int dmg) {
    _hp -= std::max(1, dmg);
    drawMiniHp(_hpMini, _hp, _maxHp);
    if (_hp <= 0) {
        runAction(Sequence::create(FadeOut::create(0.08f),
                                   CallFunc::create([this]{ removeFromParent(); }),
                                   nullptr));
    } else if (_sprite) {
        _sprite->runAction(Sequence::create(TintTo::create(0.0f, 255,120,120),
                                            DelayTime::create(0.05f),
                                            TintTo::create(0.0f, 200,70,70),
                                            nullptr));
    }
}

File Enemy.h
#pragma once
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"
#include "game/Entity.h"

class Player;

class Enemy : public Entity {
public:
    CREATE_FUNC(Enemy);

    bool init() override;
    void enablePhysics(const cocos2d::Vec2& pos,
                       const cocos2d::Size& bodySize = cocos2d::Size(42, 42));

    void setPatrol(const cocos2d::Vec2& a, const cocos2d::Vec2& b);
    void setTarget(Player* p) { _target = p; }

    virtual void takeHit(int dmg);
    void updateEnemy(float dt);

    void setMoveSpeed(float v) { _moveSpeed = v; }
    void setMaxHp(int v)       { _maxHp = _hp = std::max(1, v); }

protected:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& sz);
    void applyEnemyMasks();

protected:
    cocos2d::Sprite*      _sprite  = nullptr;
    cocos2d::PhysicsBody* _body    = nullptr;
    cocos2d::DrawNode*    _hpMini  = nullptr;   // <--- thêm: thanh HP mini
    Player*               _target  = nullptr;

    cocos2d::Vec2 _pA, _pB;
    int           _dir = +1;
    float         _moveSpeed = 90.f;

    int _hp    = 2;
    int _maxHp = 2;
};

File Entity.cpp
#include "game/Entity.h"
// Hiện giờ mọi thứ đã làm trong header (inline) để đơn giản hoá.
// Nếu cần mở rộng logic chung cho mọi Entity, thêm ở đây.

File Entity.h
// Classes/game/Entity.h
#pragma once
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"

// Alias toàn cục để code cũ dùng Tag::XYZ vẫn hợp lệ
using Tag = phys::Tag;

class Entity : public cocos2d::Node {
public:
    CREATE_FUNC(Entity);

    // Node::init() mặc định
    bool init() override { return cocos2d::Node::init(); }

    // Tag gameplay mở rộng (không đụng tới Node::setTag(int) của cocos2d)
    void setTagEx(Tag t)           { _gtag = t; }
    void setTagExInt(int t)        { _gtag = static_cast<Tag>(t); }  // back-compat
    void setTagEx(int t)           { _gtag = static_cast<Tag>(t); }  // back-compat: setTagEx(1)
    Tag  getTagEx() const          { return _gtag; }

protected:
    Tag _gtag = Tag::NONE;
};

File Player.cpp
#include "game/Player.h"
#include "2d/CCDrawNode.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include <algorithm>
#include <cmath>
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
#include "GameScene.h" // nếu bạn cần dùng getParent() hoặc dynamic_cast

#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"

using namespace cocos2d;

static inline float approach(float cur, float target, float delta) {
    if (cur < target) return std::min(target, cur + delta);
    if (cur > target) return std::max(target, cur - delta);
    return cur;
}

bool Player::init() {
    if (!Entity::init()) return false;
    CCLOG("Player::init");

    // _gfx = DrawNode::create();
    // addChild(_gfx, 1);
    // refreshVisual();

    _sprite = Sprite::create("sprites/player/idle/idle_1.png"); // frame đầu tiên
    _sprite->setAnchorPoint(Vec2(0.5f, 0.5f)); // chân ở dưới
    _sprite->setPositionY(_colSize.height * 0.5f); // dời lên nửa collider
    _sprite->setScale(1.4f); // tùy chỉnh kích cỡ hiển thị
    addChild(_sprite, 1);


    scheduleUpdate();
    return true;
}

void Player::refreshVisual() {
    // if (!_gfx) return;
    // _gfx->clear();
    // const float w = _colSize.width;
    // const float h = _colSize.height;
    // _gfx->drawSolidRect(Vec2(-w*0.5f, 0.f), Vec2(w*0.5f, h),
    //                     Color4F(0.90f, 0.90f, 0.98f, 1.f));
}

void Player::enablePhysics(const Vec2& feetPos, const Size& bodySize) {
    if (bodySize.width > 0 && bodySize.height > 0) _colSize = bodySize;
    setPosition(feetPos);

    _body = buildOrUpdateBody(_colSize);
    applyPlayerMasks();

    _body->setEnabled(true);
    _body->setGravityEnable(true);
    _body->setDynamic(true);
    _body->setVelocity(Vec2::ZERO);
}

PhysicsBody* Player::buildOrUpdateBody(const Size& bodySize) {
    Size sz = bodySize;
    sz.width  = std::max(18.f, sz.width  * 0.90f);
    //! config lai height 1.5 cho bang sprite
    sz.height = std::max(30.f, sz.height * 1.5f);

    if (!_body) {
        _body = PhysicsBody::create();
        _body->setDynamic(true);
        _body->setRotationEnable(false);
        addComponent(_body);
    } else {
        auto shapes = _body->getShapes();
        for (auto s : shapes) _body->removeShape(s);
    }

    auto mainBox = PhysicsShapeBox::create(
        sz, PhysicsMaterial(0.1f, 0.0f, 0.5f),
        Vec2(0, +sz.height * 0.5f)
    );
    _body->addShape(mainBox);

    const float footH = std::max(4.0f, sz.height * 0.08f);
    const Size  footSize(sz.width * 0.60f, footH);
    const Vec2  footOffset(0, -footH * 0.5f);
    auto foot = PhysicsShapeBox::create(footSize, PhysicsMaterial(0,0,0), footOffset);
    foot->setSensor(true);
    foot->setTag((int)phys::ShapeTag::FOOT);
    _body->addShape(foot);

    _body->setMass(1.0f);
    _body->setLinearDamping(0.1f);
    return _body;
}

void Player::applyPlayerMasks() {
    if (!_body) return;

    const phys::Mask collide =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_SOLID |
        phys::CAT_GATE  | phys::CAT_CRATE;
    const phys::Mask contact =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_ITEM   |
        phys::CAT_BULLET| phys::CAT_SENSOR;

    phys::setMasks(_body, phys::CAT_PLAYER, collide, contact);
}

void Player::setMoveDir(const Vec2& dir) {
    _moveDir = dir;
    if (_moveDir.x < 0) _facing = -1;
    else if (_moveDir.x > 0) _facing = +1;
}

void Player::jump() {
    if (!_body) return;
    if (_footContacts <= 0) return;
    const float m = _body->getMass();
    _body->applyImpulse(Vec2(0, _jumpImpulse * m));
}

void Player::incFoot(int delta) {
    _footContacts += delta;
    if (_footContacts < 0) _footContacts = 0;
}

void Player::heal(int v) {
    _hp = std::min(_maxHp, _hp + std::max(0, v));
}
void Player::restoreFullHP() { _hp = _maxHp; }

void Player::hurt(int dmg) {
    if (invincible() || !_body) return;
    _hp = std::max(0, _hp - std::max(1, dmg));
    _invincibleT = 0.8f;

    const float dir = (_facing > 0 ? -1.f : +1.f);
    _body->applyImpulse(Vec2(200.f * dir, 260.f));
}

// Bắn / chém giữ nguyên
void Player::doShoot(){
    if (_shooting) return; // tránh spam
    _shooting = true;

    int dir = facing();


    runAction(Sequence::create(
        DelayTime::create(0.35f), // delay 0.35 giây
        CallFunc::create([this, dir]() {
            Vec2 origin = getPosition() + Vec2(dir * 18.f, halfH() * 0.25f);
            auto b = Bullet::create(origin, Vec2(700.f * dir, 0.f), 1.5f);
            if (getParent() && b)
                getParent()->addChild(b, 6);
        }),
        DelayTime::create(0.36f), // cooldown trước khi có thể bắn lại
        CallFunc::create([this]() { _shooting = false; }),
        nullptr
    ));

}

void Player::doSlash(){
     if (_attacking ) return; // tránh spam
    _attacking = true;

    int dir = facing();
    
    // Delay 0.25s trước khi spawn hitbox (trúng sau khi vung)
    runAction(Sequence::create(
        DelayTime::create(0.25f),
        CallFunc::create([this, dir]() {
            Vec2 origin = getPosition() + Vec2(dir * 28.f, halfH() * 0.1f);
            float angle = (dir > 0) ? 0.0f : M_PI;
            auto s = Slash::create(origin, angle, 60.f, 0.12f);
            if (getParent()) getParent()->addChild(s, 6);
        }),
        // Cho nghỉ 0.36s rồi mới cho phép tấn công tiếp
        DelayTime::create(0.36f),
        CallFunc::create([this]() {
            _attacking = false;
        }),
        nullptr
    ));
}


Vector<SpriteFrame*> Player::buildFrames(const std::string& animName, int frameCount) {

    Vector<SpriteFrame*> frames;
    for (int i = 1; i < frameCount+1; ++i) {
        std::string path = StringUtils::format("sprites/player/%s/%s_%d.png", animName.c_str(), animName.c_str(), i);
        auto tex = Director::getInstance()->getTextureCache()->addImage(path);
        if (!tex) break; // không tìm thấy file => dừng
        Rect rect(0, 0, tex->getPixelsWide(), tex->getPixelsHigh());
        frames.pushBack(SpriteFrame::create(path, rect));
    }
    return frames;

}

void Player::playAnim(const std::string& animName, float delay, int frameCount) {
    CCLOG("Play anim: %s", animName.c_str());
    if (_currentAnim == animName) return;

    auto frames = buildFrames(animName, frameCount);
    if (frames.empty()) {
        CCLOG("Không tìm thấy frame cho anim: %s", animName.c_str());
        return;
    }
    _currentAnim = animName;
    auto animation = Animation::createWithSpriteFrames(frames, delay);
    auto act = RepeatForever::create(Animate::create(animation));

    if (_sprite) {
        _sprite->stopAllActions();
        _sprite->runAction(act);
    }
}

void Player::update(float dt) {
    if (!_body) return;

    if (_invincibleT > 0.f) {
        _invincibleT -= dt;
        const bool blink = ((int)std::floor(_invincibleT * 20.f)) % 2 == 0;
        if (_sprite) _sprite->setOpacity(blink ? 140 : 255);
    } else if (_sprite) {
        _sprite->setOpacity(255);
    }

    const bool grounded = (_footContacts > 0);
    const float targetVx = _moveDir.x * _moveSpeed;

    Vec2 v = _body->getVelocity();
    const float accel = grounded ? _accelGround : _accelAir;

    if (grounded && std::abs(_moveDir.x) < 1e-3f)
        v.x = approach(v.x, 0.f, accel * dt);
    else
        v.x = approach(v.x, targetVx, accel * dt);

    v.y = std::max(v.y, -_maxFall);
    _body->setVelocity(v);

    // !--- animation select ---

    if (isDead()) nextAnim = "die";
    else if (_attacking) nextAnim = "attack";
    else if (_shooting) nextAnim = "shoot";
    else if (!grounded) nextAnim = "jump";
    else if (std::abs(_moveDir.x) > 1e-3f) nextAnim = "run";
    
    else nextAnim = "idle";

    if (_currentAnim != nextAnim)
    {
        if (nextAnim == "die") playAnim("die", 0.12f, 6);
        else if (nextAnim == "jump") playAnim("jump", 0.23f, 4);
        else if (nextAnim == "run") playAnim("run", 0.06f, 8);
        else if (nextAnim == "attack") playAnim("attack", 0.06f, 6);
        else if (nextAnim == "shoot") playAnim("shoot", 0.08f, 6);
        else playAnim("idle", 0.12f, 8);
    }

    if (_sprite) _sprite->setScaleX(_facing);
}

File Player.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"


class Player : public Entity {
public:
    CREATE_FUNC(Player);

    bool init() override;

    // Bật vật lý. feetPos = vị trí đặt BÀN CHÂN. Nếu bodySize rỗng -> dùng mặc định.
    void enablePhysics(const cocos2d::Vec2& feetPos,
                       const cocos2d::Size& bodySize = cocos2d::Size::ZERO);

    // Điều khiển
    void setMoveDir(const cocos2d::Vec2& dir);
    void jump();
    void doShoot();
    void doSlash();

    
    // Gameplay state
    void incFoot(int delta);      // tăng/giảm số contact của sensor FOOT
    void hurt(int dmg);
    bool invincible() const { return _invincibleT > 0.f; }
    bool _attacking = false;
    bool _shooting  = false;


    // HP
    int  hp()    const { return _hp; }
    int  maxHp() const { return _maxHp; }
    void heal(int v);
    void restoreFullHP();
    bool isDead() const { return _hp <= 0; }

    // Trợ giúp cho GameScene/Weapon
    int   facing()   const { return _facing; }            // -1 (trái) / +1 (phải)
    float halfH()    const { return _colSize.height * 0.5f; }
    cocos2d::Size colliderSize() const { return _colSize; }

    std::string nextAnim;



protected:
    void update(float dt) override;

private:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& bodySize);
    void applyPlayerMasks();
    void refreshVisual();

private:
    // cocos2d::DrawNode*    _gfx   = nullptr;
    //!ANIMATION
    cocos2d::Sprite* _sprite = nullptr;
    std::string _currentAnim;
    
    //!PLAY ANIMATION
    void playAnim(const std::string& name, float delay, int frames);
    // !helper to build frames either from SpriteFrameCache (.plist) or from individual png files
    cocos2d::Vector<cocos2d::SpriteFrame*> buildFrames(const std::string& animName, int frameCount);

    cocos2d::PhysicsBody* _body  = nullptr;

    cocos2d::Size _colSize{28.f, 44.f};
    cocos2d::Vec2 _moveDir{0,0};
    int    _facing        = +1;
    int    _footContacts  = 0;

    // Chuyển động
    float _moveSpeed   = 180.f;   // px/s
    float _accelGround = 1200.f;  // px/s^2
    float _accelAir    = 650.f;   // px/s^2
    float _jumpImpulse = 420.f;   // lực nhảy (nhân khối lượng)
    float _maxFall     = 1200.f;  // clamp vận tốc rơi

    // HP
    int   _hp    = 100;
    int   _maxHp = 100;

    // Bất tử ngắn sau khi bị thương
    float _invincibleT = 0.f;
};


Folder Classes/game/bosses
File BossGolem.cpp
// Classes/game/bosses/BossGolem.cpp
#include "game/bosses/BossGolem.h"
#include "2d/CCSprite.h"
#include "2d/CCActionInterval.h"

USING_NS_CC;

BossGolem* BossGolem::create() {
    auto p = new (std::nothrow) BossGolem();
    if (p && p->init()) { p->autorelease(); return p; }
    CC_SAFE_DELETE(p);
    return nullptr;
}

bool BossGolem::init() {
    if (!Enemy::init()) return false;

    // Đảm bảo có sprite hiển thị từ Enemy (Enemy giữ _sprite)
    if (!_sprite) {
        _sprite = Sprite::create();
        _sprite->setAnchorPoint(Vec2(0.5f, 0.5f));
        _sprite->setContentSize(Size(72.f, 72.f));
        addChild(_sprite);
    }

    _sprite->setTextureRect(Rect(0, 0, 72, 72));
    _sprite->setColor(Color3B(90, 70, 50));

    _hp    = 20;
    _speed = 60.f; // tuỳ bạn có dùng hay không

    return true;
}

void BossGolem::takeHit(int dmg) {
    _hp -= dmg;

    if (_sprite) {
        _sprite->runAction(Sequence::create(
            TintTo::create(0.05f, 200, 160, 120),
            TintTo::create(0.05f, 255, 255, 255),
            nullptr
        ));
    }

    if (_hp <= 0) removeFromParent();
}

File BossGolem.h
// Classes/game/bosses/BossGolem.h
#pragma once
#include "game/Enemy.h"

class BossGolem : public Enemy {
public:
    static BossGolem* create();
    bool init() override;
    void takeHit(int dmg) override;

private:
    int   _hp    = 0;
    float _speed = 0.0f;  // nếu Enemy đã có cơ chế move riêng, bạn có thể bỏ biến này
};


Folder Classes/game/enemies
File Goomba.cpp
// Goomba.cpp
#include "game/enemies/Goomba.h"
USING_NS_CC;
Goomba* Goomba::create(){ auto p=new(std::nothrow) Goomba(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Goomba::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(200,120,60));
    return true;
}

File Goomba.h
// Goomba.h
#pragma once
#include "game/Enemy.h"
class Goomba : public Enemy {
public:
    static Goomba* create();
    bool init() override;
};

File Spiker.cpp
// Spiker.cpp
#include "game/enemies/Spiker.h"
USING_NS_CC;
Spiker* Spiker::create(){ auto p=new(std::nothrow) Spiker(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Spiker::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(180,200,255));
    return true;
}

File Spiker.h
// Spiker.h
#pragma once
#include "game/Enemy.h"
class Spiker : public Enemy {
public:
    static Spiker* create();
    bool init() override;
};


Folder Classes/game/loot
File LootTable.cpp
#include "game/loot/LootTable.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "physics/CCPhysicsBody.h"

using namespace cocos2d;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

const std::vector<DropSpec>& LootTable::defaultEnemyTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    60.f, 1, 3 },
        { DropKind::UPGRADE, 25.f, 1, 1 },
        { DropKind::STAR,     5.f, 1, 1 },
        { DropKind::NONE,    10.f, 0, 0 }
    };
    return T;
}
const std::vector<DropSpec>& LootTable::defaultChestTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    40.f, 3, 6 },
        { DropKind::UPGRADE, 45.f, 1, 2 },
        { DropKind::STAR,    10.f, 1, 1 },
        { DropKind::NONE,     5.f, 0, 0 }
    };
    return T;
}

DropKind LootTable::rollOne(const std::vector<DropSpec>& table, int& outCount){
    float sumW = 0.f;
    for (auto& e : table) sumW += e.weight;
    float r = frand(0.f, sumW), acc = 0.f;
    for (auto& e : table){
        acc += e.weight;
        if (r <= acc){
            outCount = (e.maxCount>=e.minCount)? irand(e.minCount, e.maxCount) : e.minCount;
            return e.kind;
        }
    }
    outCount = 0; return DropKind::NONE;
}

static void asSensorItem(Node* n){
    if (!n) return;
    auto* b = n->getPhysicsBody();
    if (!b){
        // tạo body tròn tĩnh nhỏ nếu item chưa có body
        const float r = std::max(n->getContentSize().width, n->getContentSize().height) * 0.4f;
        b = PhysicsBody::createCircle(r, PhysicsMaterial(0,0,0));
        b->setDynamic(false);
        n->setPhysicsBody(b);
    }
    b->setGravityEnable(false);
    // mask ITEM sensor
    const uint32_t CAT_ITEM = 1u<<3, ALL=0xFFFFFFFFu;
    b->setCategoryBitmask(CAT_ITEM);
    b->setCollisionBitmask(0);       // không phản lực
    b->setContactTestBitmask(ALL);   // để GameScene bắt contact
    for (auto s : b->getShapes()) s->setSensor(true);
}

void LootTable::spawn(Node* root, const Vec2& p, DropKind k, int count){
    if (!root || k==DropKind::NONE || count<=0) return;
    const float spread = 28.f;

    for (int i=0;i<count;++i){
        Node* item=nullptr;
        switch (k){
            case DropKind::COIN:    item = Coin::create();    break;
            case DropKind::UPGRADE: item = Upgrade::create(); break;
            case DropKind::STAR:    item = Star::create();    break;
            default: break;
        }
        if (!item) continue;
        item->setPosition(p);
        root->addChild(item, 6);

        // sensor & hiệu ứng "bật" nhẹ
        asSensorItem(item);
        Vec2 dir = Vec2(frand(-1.f,1.f), 1.f).getNormalized();
        float dist = frand(spread*0.4f, spread);
        item->runAction(Sequence::create(
            MoveBy::create(0.25f, dir * dist),
            nullptr
        ));
    }
}

void LootTable::rollAndSpawn(Node* root, const Vec2& p, const std::vector<DropSpec>& table){
    int cnt=0; DropKind k = rollOne(table, cnt);
    spawn(root, p, k, cnt);
}

File LootTable.h
#pragma once
#include <vector>
#include "cocos2d.h"

enum class DropKind { NONE, COIN, UPGRADE, STAR };

struct DropSpec {
    DropKind kind;
    float    weight;    // trọng số bốc thăm
    int      minCount;
    int      maxCount;
};

class LootTable {
public:
    static const std::vector<DropSpec>& defaultEnemyTable();
    static const std::vector<DropSpec>& defaultChestTable();

    // Roll & spawn tại vị trí p (CENTER của đối tượng chết/vỡ)
    static void rollAndSpawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                             const std::vector<DropSpec>& table = defaultEnemyTable());

private:
    static DropKind rollOne(const std::vector<DropSpec>& table, int& outCount);
    static void     spawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                          DropKind k, int count);
};


Folder Classes/game/map
File LevelBuilder.cpp
#include "game/map/LevelBuilder.h"
#include "physics/PhysicsDefs.h"

#include "2d/CCDrawNode.h"
#include "2d/CCLayer.h"

#include "game/Enemy.h"
#include "game/enemies/Goomba.h"
#include "game/enemies/Spiker.h"
#include "game/bosses/BossGolem.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"

using namespace cocos2d;

namespace {

// NỀN/PLATFORM “top-anchored”: node đặt tại (cx, topY - h/2)
static Node* addPlatformTop(Node* root, float cx, float topY, float w, float h, const Color4F& c) {
    auto n = Node::create();
    n->setPosition(Vec2(cx, topY - h * 0.5f));

    auto* body = PhysicsBody::createBox(Size(w, h), PhysicsMaterial(0.15f, 0.0f, 0.3f));
    body->setDynamic(false);

    // KHÔNG dùng MASK_ALL (vì header của bạn không có) → set qua helper trong PhysicsDefs.h
    // Cho WORLD va chạm với mọi “thứ rắn” và nhận contact với player/sensor.
    phys::setMasks(body,
        phys::CAT_WORLD,
        (phys::CAT_PLAYER | phys::CAT_ENEMY | phys::CAT_SOLID | phys::CAT_GATE | phys::CAT_CRATE),
        (phys::CAT_PLAYER | phys::CAT_ENEMY | phys::CAT_SENSOR)
    );

    n->setPhysicsBody(body);

    auto d = DrawNode::create();
    d->drawSolidRect(Vec2(-w*0.5f, -h*0.5f), Vec2(w*0.5f, h*0.5f), c);
    n->addChild(d);

    root->addChild(n);
    return n;
}

static void addZoneBG(Node* root, const Size& vs, const Vec2& origin, int i) {
    auto bg = LayerColor::create(Color4B(25+10*i, 25+10*i, 30+6*i, 255));
    bg->setContentSize(vs);
    bg->setPosition(origin + Vec2(i * vs.width, 0));
    root->addChild(bg, -90);
}

} // anon

namespace levels {

BuildResult buildLevel1(Node* root, const Size& vs, const Vec2& origin) {
    BuildResult out{};

    const int   SEGMENTS    = 5;
    const float SEG_W       = vs.width;
    const float GROUND_H    = 36.f;
    const float GROUND_TOP  = origin.y + vs.height * 0.12f;

    out.segments     = SEGMENTS;
    out.segmentWidth = SEG_W;
    out.groundTop    = GROUND_TOP;

    // Ground chạy suốt map (top-anchored)
    const float worldW = SEG_W * SEGMENTS;
    addPlatformTop(root, origin.x + worldW*0.5f, GROUND_TOP,
                   worldW, GROUND_H, Color4F(0.10f,0.82f,0.22f,1.f));

    for (int i=0; i<SEGMENTS; ++i) {
        const float x0 = origin.x + i * SEG_W;
        addZoneBG(root, vs, origin, i);

        switch (i) {
        case 0: {
            addPlatformTop(root, x0 + SEG_W*0.42f, GROUND_TOP + 110.f, 220.f, 16.f, Color4F(0.48f,0.48f,0.78f,1));
            for (int k=0;k<3;++k){
                auto c = Coin::create();
                c->setPosition({x0+SEG_W*0.42f-30.f+30.f*k, GROUND_TOP+135.f});
                root->addChild(c, 2);
            }
            break;
        }
        case 1: {
            addPlatformTop(root, x0 + SEG_W*0.30f, GROUND_TOP + 150.f, 180.f, 16.f, Color4F(0.48f,0.48f,0.78f,1));
            addPlatformTop(root, x0 + SEG_W*0.60f, GROUND_TOP + 200.f, 160.f, 16.f, Color4F(0.40f,0.65f,0.80f,1));
            auto g = Goomba::create(); root->addChild(g,2);
            g->enablePhysics({x0+SEG_W*0.50f, GROUND_TOP+10.f}, {42,42});
            g->setPatrol({x0+SEG_W*0.45f, GROUND_TOP+10.f},{x0+SEG_W*0.70f, GROUND_TOP+10.f});
            out.enemies.pushBack(g);
            break;
        }
        case 2: {
            addPlatformTop(root, x0 + SEG_W*0.25f, GROUND_TOP + 140.f, 140.f, 16.f, Color4F(0.40f,0.40f,0.70f,1));
            addPlatformTop(root, x0 + SEG_W*0.50f, GROUND_TOP + 180.f, 200.f, 16.f, Color4F(0.48f,0.48f,0.78f,1));
            addPlatformTop(root, x0 + SEG_W*0.75f, GROUND_TOP + 220.f, 140.f, 16.f, Color4F(0.35f,0.60f,0.75f,1));
            auto s = Spiker::create(); root->addChild(s,2);
            s->enablePhysics({x0+SEG_W*0.58f, GROUND_TOP+10.f}, {42,42});
            s->setPatrol({x0+SEG_W*0.52f, GROUND_TOP+10.f},{x0+SEG_W*0.70f, GROUND_TOP+10.f});
            out.enemies.pushBack(s);
            for (int k=0;k<3;++k){
                auto c = Coin::create();
                c->setPosition({x0+SEG_W*0.50f-30.f+30.f*k, GROUND_TOP+205.f});
                root->addChild(c, 2);
            }
            break;
        }
        case 3: {
            addPlatformTop(root, x0 + SEG_W*0.35f, GROUND_TOP + 160.f, 180.f, 16.f, Color4F(0.48f,0.48f,0.78f,1));
            addPlatformTop(root, x0 + SEG_W*0.65f, GROUND_TOP + 120.f, 200.f, 16.f, Color4F(0.40f,0.65f,0.80f,1));
            break;
        }
        case 4: {
            addPlatformTop(root, x0 + SEG_W*0.50f, GROUND_TOP + 160.f, 220.f, 16.f, Color4F(0.48f,0.48f,0.78f,1));
            auto boss = BossGolem::create(); root->addChild(boss,2);
            boss->enablePhysics({x0+SEG_W*0.70f, GROUND_TOP+10.f}, {72,72});
            boss->setPatrol({x0+SEG_W*0.62f, GROUND_TOP+10.f},{x0+SEG_W*0.88f, GROUND_TOP+10.f});
            out.enemies.pushBack(boss);

            auto star = Star::create();
            star->setPosition({x0+SEG_W*0.52f, GROUND_TOP+190.f});
            root->addChild(star,2);
            break;
        }
        }
    }

    out.playerSpawn = Vec2(origin.x + SEG_W*0.15f, GROUND_TOP + 1.f); // feet = top + 1
    return out;
}


} // namespace levels

File LevelBuilder.h
#pragma once
#include "cocos2d.h"

class Enemy; // fwd

namespace levels {

struct BuildResult {
    float groundTop = 0.f;
    int   segments = 0;
    float segmentWidth = 0.f;
    cocos2d::Vec2 playerSpawn;
    cocos2d::Vector<Enemy*> enemies;   // <<< TRẢ VỀ Enemy*
};

BuildResult buildLevel1(cocos2d::Node* root,
                        const cocos2d::Size& vs,
                        const cocos2d::Vec2& origin);

} // namespace levels


Folder Classes/game/objects
File Chest.cpp
#include "game/objects/Chest.h"
#include "2d/CCDrawNode.h"
#include "physics/CCPhysicsBody.h"
#include "game/loot/LootTable.h"

USING_NS_CC;

bool Chest::init(){
    if (!Enemy::init()) return false;

    // vẽ placeholder chiếc rương (vẽ như top-anchored)
    auto d = DrawNode::create();
    const Size S(36, 28);
    d->drawSolidRect(Vec2(-S.width*0.5f, -S.height), Vec2(S.width*0.5f, 0),
                     Color4F(0.65f,0.45f,0.20f,1.f));
    addChild(d);
    setContentSize(S);
    return true;
}

void Chest::enablePhysicsTop(const Vec2& topCenter, const Size& sz){
    setPosition(topCenter);  // Node = đường TOP

    auto body = PhysicsBody::createBox(sz, PhysicsMaterial(0.2f, 0.f, 0.6f),
                                       Vec2(0, -sz.height*0.5f)); // offset xuống dưới
    body->setDynamic(false);
    body->setRotationEnable(false);

    // Cho rương vào CAT_ENEMY để tái dùng logic Bullet/Slash ↔ Enemy
    const uint32_t CAT_ENEMY = 1u<<2, ALL=0xFFFFFFFFu;
    body->setCategoryBitmask(CAT_ENEMY);
    body->setCollisionBitmask(ALL);
    body->setContactTestBitmask(ALL);
    setPhysicsBody(body);
}

void Chest::takeHit(int dmg){
    hp -= std::max(1, dmg);
    // nháy nhẹ báo trúng
    runAction(Sequence::create(TintTo::create(0, 255,200,200),
                               TintTo::create(0.08f, 255,255,255),
                               nullptr));
    if (hp <= 0) spawnLootAndVanish();
}

void Chest::spawnLootAndVanish(){
    LootTable::rollAndSpawn(getParent(), getPosition(), LootTable::defaultChestTable());
    removeFromParent();
}

File Chest.h
#pragma once
#include "game/Enemy.h"

class Chest : public Enemy {
public:
    CREATE_FUNC(Chest);

    bool init() override;
    void enablePhysicsTop(const cocos2d::Vec2& topCenter, const cocos2d::Size& sz);

    void takeHit(int dmg) override;   // bị chém/bắn
    int  hp = 3;

private:
    void spawnLootAndVanish();
};

File Coin.cpp
// Coin.cpp
#include "game/objects/Coin.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Coin* Coin::create(){ auto p=new(std::nothrow) Coin(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Coin::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::COIN);

    _sprite = Sprite::create("sprites/objects/coin/coin_1.png"); // frame đầu tiên
    _sprite->setScale(1.5f); // tùy chỉnh kích cỡ hiển thị
    addChild(_sprite, 1);

    Vector<SpriteFrame*> frames;
    auto firstSize = _sprite->getContentSize();
    for (int i = 1; i <= 4; i++) { // giả sử bạn có coin_1.png -> coin_5.png
        std::string framePath = StringUtils::format("sprites/objects/coin/coin_%d.png", i);
        auto frame = SpriteFrame::create(framePath, Rect(0, 0, firstSize.width, firstSize.height));
        frame->setOriginalSize(firstSize);
        frames.pushBack(frame);
    }

    auto animation = Animation::createWithSpriteFrames(frames, 0.2f); // 0.4s mỗi frame
    auto animate = Animate::create(animation);
    _sprite->runAction(RepeatForever::create(animate));

    // auto dn = DrawNode::create();
    // dn->drawSolidCircle(Vec2::ZERO, 10, 0, 24, Color4F(1,0.85f,0,1));
    // addChild(dn);
    auto body = PhysicsBody::createCircle(10);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);               // sensor-only
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Coin.h
// Coin.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
class Coin : public Entity {
public:
    static Coin* create();
    bool init() override;
    cocos2d::Sprite* _sprite = nullptr;
};

File Crate.cpp
// Crate.cpp
#include "game/objects/Crate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Crate* Crate::create(){ auto p=new(std::nothrow) Crate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Crate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::CRATE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-16,-16},{16,16}, Color4F(0.6f,0.4f,0.2f,1));
    addChild(dn);
    auto b = PhysicsBody::createBox(Size(32,32), PhysicsMaterial(0.3f,0,0.9f));
    b->setDynamic(true);
    b->setCategoryBitmask(phys::CAT_CRATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}

File Crate.h
// Crate.h
#pragma once
#include "game/Entity.h"
class Crate : public Entity {
public:
    static Crate* create();
    bool init() override;
};

File Gate.cpp
// Gate.cpp
#include "game/objects/Gate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Gate* Gate::create(){ auto p=new(std::nothrow) Gate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Gate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::GATE);
    _dn = DrawNode::create();
    _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
    addChild(_dn);
    auto b = PhysicsBody::createBox(Size(24,80));
    b->setDynamic(false);
    b->setCategoryBitmask(phys::CAT_GATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}
void Gate::open(bool on){
    _open = on;
    if(auto* b=getPhysicsBody()){
        b->setEnabled(!on);
    }
    _dn->clear();
    if(on) _dn->drawRect({-12,-40},{12,40}, Color4F(0.2f,1,0.2f,1));     // khung trống
    else   _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
}

File Gate.h
// Gate.h
#pragma once
#include "game/Entity.h"
class Gate : public Entity {
public:
    static Gate* create();
    bool init() override;
    void open(bool on);
    bool isOpen() const { return _open; }
private:
    bool _open=false;
    cocos2d::DrawNode* _dn=nullptr;
};

File PressurePlate.cpp
#include "game/objects/PressurePlate.h"
#include "physics/PhysicsDefs.h"
#include "cocos2d.h"

USING_NS_CC;

bool PressurePlate::init(){
    if(!Node::init()) return false;

    const float ww = 48.f, hh = 10.f;
    auto body = PhysicsBody::createBox(Size(ww, hh));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_SENSOR);
    body->setCollisionBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    body->setContactTestBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    setPhysicsBody(body);

    setTagEx(phys::Tag::PLATE);

    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-ww/2,-hh/2), Vec2(ww/2,hh/2), Color4F(0.9f,0.2f,0.2f,0.9f));
    addChild(dn);

    return true;
}

File PressurePlate.h
// PressurePlate.h
#pragma once
#include "game/Entity.h"
class PressurePlate : public Entity {
public:
    static PressurePlate* create();
    bool init() override;
    void setCallback(const std::function<void(bool)>& cb){ _cb = cb; }
private:
    std::function<void(bool)> _cb;
    int _pressCount = 0;
};

File Star.cpp
// Star.cpp
#include "game/objects/Star.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Star* Star::create(){ auto p=new(std::nothrow) Star(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Star::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::STAR);
    auto dn = DrawNode::create();
    Vec2 pts[5];
    for(int i=0;i<5;++i){ float a = CC_DEGREES_TO_RADIANS(72*i-90); pts[i]=Vec2(0,14).rotateByAngle(Vec2::ZERO,a); }
    dn->drawPoly(pts,5,true,Color4F(1,1,0.2f,1));
    addChild(dn);
    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Star.h
// Star.h
#pragma once
#include "game/Entity.h"
class Star : public Entity {
public:
    static Star* create();
    bool init() override;
};

File Upgrade.cpp
// Upgrade.cpp
#include "game/objects/Upgrade.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Upgrade* Upgrade::create(){ auto p=new(std::nothrow) Upgrade(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Upgrade::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::UPGRADE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-10,-10},{10,10}, Color4F(0.2f,1,1,1));
    addChild(dn);
    auto body = PhysicsBody::createBox(Size(20,20));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Upgrade.h
// Upgrade.h
#pragma once
#include "game/Entity.h"
class Upgrade : public Entity {
public:
    static Upgrade* create();
    bool init() override;
};


Folder Classes/game/upgrades
File UpgradeSystem.cpp
#include "game/upgrades/UpgradeSystem.h"
using namespace cocos2d;
using namespace upgrades;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

UpgradeSystem::Effect UpgradeSystem::roll(int segIndex, const RollSpec& spec) {
    // Chọn type
    Type T;
    switch (irand(0,4)) {
        case 0: T = Type::MOVE_SPEED;  break;
        case 1: T = Type::JUMP_POWER;  break;
        case 2: T = Type::DAMAGE_MULT; break;
        case 3: T = Type::BULLET_COUNT;break;
        default:T = Type::SLASH_RANGE; break;
    }

    // Biên độ “mềm tay”
    float mag = 0.f;
    switch (T) {
        case Type::MOVE_SPEED:   mag = frand(18.f, 40.f);   break;
        case Type::JUMP_POWER:   mag = frand(24.f, 60.f);   break;
        case Type::DAMAGE_MULT:  mag = frand(1.15f, 1.45f); break;
        case Type::BULLET_COUNT: mag = (float)irand(1,2);   break;
        case Type::SLASH_RANGE:  mag = frand(1.15f, 1.40f); break;
    }

    // 50% TIMED, còn lại theo defaultScope
    Scope sc  = spec.defaultScope;
    float dur = 0.f;
    if (spec.allowTimed && RandomHelper::random_int(0,1)==1) {
        sc  = Scope::TIMED;
        dur = spec.timedDuration + segIndex * 3.f; // mini sau lâu hơn chút
    }

    return Effect{ T, mag, sc, dur };
}

File UpgradeSystem.h
#pragma once
#include "cocos2d.h"

namespace upgrades {

// Thời hạn hiệu lực
enum class Scope : int { TIMED, SEGMENT, PERSIST };

// Loại nâng cấp
enum class Type  : int {
    MOVE_SPEED,     // +px/s
    JUMP_POWER,     // +impulse
    DAMAGE_MULT,    // × sát thương (đạn + chém)
    BULLET_COUNT,   // +số đạn mỗi phát
    SLASH_RANGE     // × tầm chém
};

// Hiệu ứng cụ thể
struct Effect {
    Type  type;
    float magnitude;    // + hoặc × (tuỳ loại)
    Scope scope;
    float durationSec;  // dùng khi TIMED; SEGMENT/PERSIST = 0
};

// Tham số roll gacha
struct RollSpec {
    Scope defaultScope  = Scope::SEGMENT; // mặc định hết mini thì hết
    float timedDuration = 20.f;           // base thời gian khi TIMED
    bool  allowTimed    = true;           // 50% ra TIMED nếu true
};

class UpgradeSystem {
public:
    // Trả về 1 hiệu ứng ngẫu nhiên theo mini (segIndex) và rule
    static Effect roll(int segIndex, const RollSpec& spec = {});
};

} // namespace upgrades


Folder Classes/game/weapon
File Bullet.cpp
#include "game/weapon/Bullet.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"

using namespace cocos2d;

Bullet* Bullet::create(const Vec2& origin, const Vec2& velocity, float lifeSec) {
    auto p = new (std::nothrow) Bullet();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay
        p->setTagEx(phys::Tag::BULLET);

        // Vị trí ban đầu
        p->setPosition(origin);

        // Vẽ dấu chấm nhỏ cho dễ nhìn
        auto dot = DrawNode::create();
        dot->drawSolidCircle(Vec2::ZERO, 4.5f, 0, 12, Color4F(1.f, 0.95f, 0.2f, 1.f));
        p->addChild(dot);

        // Thân vật lý
        auto body = PhysicsBody::createCircle(4.5f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Masks theo PhysicsDefs.h (C++14-safe)
        body->setCategoryBitmask(static_cast<int>(phys::CAT_BULLET));
        body->setCollisionBitmask(static_cast<int>(phys::MASK_BULLET));
        body->setContactTestBitmask(static_cast<int>(phys::MASK_BULLET));

        // Gắn tag lên shape để contact listener nhận diện nhanh
        if (!body->getShapes().empty())
            body->getShapes().front()->setTag(static_cast<int>(phys::Tag::BULLET));

        p->addComponent(body);

        // Bay theo vận tốc đầu vào
        body->setVelocity(velocity);

        // Tự hủy sau lifeSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Bullet.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Bullet : public Entity {
public:
    CREATE_FUNC(Bullet);

    // Tạo bullet tại origin, bay với velocity, tự hủy sau lifeSec
    static Bullet* create(const cocos2d::Vec2& origin,
                          const cocos2d::Vec2& velocity,
                          float lifeSec);

protected:
    bool init() override { return Entity::init(); }
};

File Slash.cpp
#include "game/weapon/Slash.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include <algorithm>
#include <cmath>

using namespace cocos2d;

Slash* Slash::create(const Vec2& origin, float angleRad, float sizeOrRange, float durationSec) {
    auto p = new (std::nothrow) Slash();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay mở rộng
        p->setTagEx(phys::Tag::SLASH);
        p->setPosition(origin);

        // Vẽ nhát chém đơn giản để debug (dạng tam giác)
        // auto dn = DrawNode::create();
        float r  = std::max(8.0f, sizeOrRange);

        Vec2 a( std::cos(angleRad), std::sin(angleRad) );
        Vec2 p0 = Vec2::ZERO;
        Vec2 p1 = a * r;
        Vec2 p2 = a.rotateByAngle(Vec2::ZERO, 0.35f) * (r * 0.75f);

        Vec2 tri[3] = { p0, p1, p2 };
        // dn->drawSolidPoly(tri, 3, Color4F(1.f, 1.f, 0.4f, 0.35f));
        // p->addChild(dn);

        // Body sensor hình hộp mỏng, đặt lệch về hướng tấn công
        auto body = PhysicsBody::create();
        body->setDynamic(false);          // sensor tạm thời
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Hộp mỏng theo hướng chém (tạo shape với OFFSET ngay từ factory)
        const float boxW = r * 0.9f;
        const float boxH = std::max(10.0f, r * 0.35f);
        Vec2 offset = a * (r * 0.45f);

        auto shape = PhysicsShapeBox::create(Size(boxW, boxH), PhysicsMaterial(0,0,0), offset);
        shape->setSensor(true);
        shape->setTag(static_cast<int>(phys::ShapeTag::SLASH));
        body->addShape(shape); // cocos2d-x 3.x: addShape chỉ nhận 1 tham số

        // Masks: sensor chỉ cần contact, không collide cứng
        body->setCategoryBitmask(static_cast<int>(phys::CAT_SENSOR));
        body->setCollisionBitmask(0);
        body->setContactTestBitmask(static_cast<int>(phys::MASK_SENSOR));

        p->addComponent(body);

        // Xoay để visual khớp hướng
        p->setRotation(-CC_RADIANS_TO_DEGREES(angleRad));

        // Tự hủy sau durationSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, durationSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Slash.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

#pragma once
#include "game/Entity.h"

class Slash : public Entity {
public:
    static Slash* create(const cocos2d::Vec2& origin, float angleRad,
                         float sizeOrRange, float durationSec = 0.15f);
    bool init() override { return Entity::init(); }
};


Folder Classes/physics
File PhysicsDefs.h
// Classes/physics/PhysicsDefs.h
#pragma once
#include <cstdint>
#include <initializer_list>
#include "cocos2d.h"

namespace phys {

// ==============================
// Bit/Mask cơ bản
// ==============================
using Mask = std::uint32_t;

enum : Mask {
    CAT_NONE   = 0u,
    CAT_WORLD  = 1u << 0,  // ground/map/platform
    CAT_PLAYER = 1u << 1,
    CAT_ENEMY  = 1u << 2,
    CAT_ITEM   = 1u << 3,  // coin/star/upgrade…
    CAT_BULLET = 1u << 4,  // projectile
    CAT_SENSOR = 1u << 5,  // generic sensors
    CAT_CRATE  = 1u << 6,
    CAT_GATE   = 1u << 7,
    CAT_SOLID  = 1u << 8,  // tường/vật thể rắn khác
    CAT_ALL    = 0xFFFFFFFFu
};

// ==============================
// Tag gameplay cho Entity
// ==============================
enum class Tag : int {
    NONE    = 0,
    COIN    = 1,
    STAR    = 2,
    UPGRADE = 3,
    GATE    = 4,
    CRATE   = 5,
    BULLET  = 6,
    SLASH   = 7,
    PLATE   = 8,
    PLAYER  = 9,
    ENEMY   = 10
};

// ==============================
// Tag cho PhysicsShape (sensor/fixture)
// ==============================
enum class ShapeTag : int {
    NONE  = 0,
    FOOT  = 1,  // chân player để bắt tiếp đất
    SLASH = 2   // hitbox chém
};

// Alias số nguyên để code cũ từng dùng phys::FOOT/SLASH vẫn chạy (C++14-safe).
constexpr int FOOT  = static_cast<int>(ShapeTag::FOOT);
constexpr int SLASH = static_cast<int>(ShapeTag::SLASH);

// ==============================
// Masks giữ lại cho back-compat
// ==============================
constexpr Mask MASK_BULLET = (CAT_WORLD | CAT_ENEMY | CAT_GATE | CAT_CRATE);
constexpr Mask MASK_SENSOR = CAT_ALL;

// ==============================
// Helpers cho mask
// ==============================
inline Mask all() { return CAT_ALL; }  // all() = mọi bit

// all({ A, B, C }) — C++14, không dùng fold-expression
inline Mask all(std::initializer_list<Mask> xs) {
    Mask m = 0u;
    for (Mask v : xs) m |= v;
    return m;
}

inline bool any(Mask m, Mask flags) { return (m & flags) != 0u; }

// ==============================
// Helpers thao tác với PhysicsBody / Node
// ==============================
inline bool hasCat(const cocos2d::PhysicsBody* body, Mask cat) {
    return body && ((static_cast<Mask>(body->getCategoryBitmask()) & cat) != 0u);
}
inline bool hasCat(const cocos2d::Node* node, Mask cat) {
    return node && hasCat(node->getPhysicsBody(), cat);
}

inline void setMasks(cocos2d::PhysicsBody* body, Mask category, Mask collide, Mask contact) {
    if (!body) return;
    body->setCategoryBitmask(static_cast<int>(category));
    body->setCollisionBitmask(static_cast<int>(collide));
    body->setContactTestBitmask(static_cast<int>(contact));
}
inline void setMasks(cocos2d::Node* node, Mask category, Mask collide, Mask contact) {
    if (!node) return;
    setMasks(node->getPhysicsBody(), category, collide, contact);
}

// đặt TÂM thân ở ngay phía trên mép trên topY, có skin nhỏ để không "lún"
inline float yOnTop(float topY, float bodyH, float skin = 0.5f) {
    return topY + bodyH * 0.5f + skin;
}


} // namespace phys

// ------------------------------------------------------------
// Legacy forwarders: cho những chỗ gọi all(...) không có tiền tố phys::
// ------------------------------------------------------------
inline phys::Mask all() { return phys::all(); }
inline phys::Mask all(std::initializer_list<phys::Mask> xs) { return phys::all(xs); }


Folder Classes/scenes
File GameScene.cpp
#include "scenes/GameScene.h"
#include "ui/HUDLayer.h"
#include "game/map/LevelBuilder.h"

#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"

#include "physics/PhysicsDefs.h"
#include <algorithm>

USING_NS_CC;

// helper: check category
static bool hasCat(cocos2d::Node* n, phys::Mask catMask){
    return n && n->getPhysicsBody() &&
           ((phys::Mask)n->getPhysicsBody()->getCategoryBitmask() & catMask) != 0u;
}

Scene* GameScene::createScene() {
    auto scene = Scene::createWithPhysics();
    auto layer = GameScene::create();
    layer->setPhysicsWorld(scene->getPhysicsWorld());
    scene->addChild(layer);
    return scene;
}

bool GameScene::init() {
    if (!Layer::init()) return false;

    _vs     = Director::getInstance()->getVisibleSize();
    _origin = Director::getInstance()->getVisibleOrigin();

    buildUICamera();
    buildHUD();

    // Map 5 đoạn
    auto L = levels::buildLevel1(this, _vs, _origin);
    _groundTop    = L.groundTop;
    _segmentCount = L.segments;
    _segmentWidth = L.segmentWidth;

    _segment = 0;
    _camL = _origin.x + _segment * _segmentWidth;
    _camR = _camL + _segmentWidth;

    // Player
    _player = Player::create();
    addChild(_player, 5);
    _player->enablePhysics({ L.playerSpawn.x, _groundTop + 220.f });

    for (auto* e : L.enemies) _enemies.pushBack(e);

    // HUD
    _lives = 3; _score = 0; _starsHave = 0; _starsNeed = _segmentCount;
    if (_hud) {
        _hud->setZone(1, _segmentCount);
        _hud->setLives(_lives);
        _hud->setScore(_score);
        _hud->setStars(_starsHave, _starsNeed);
        _hud->setHP(_player->hp(), _player->maxHp());   // <---
    }

    _bindInput();
    auto cl = EventListenerPhysicsContact::create();
    cl->onContactBegin    = CC_CALLBACK_1(GameScene::_onContactBegin, this);
    cl->onContactSeparate = CC_CALLBACK_1(GameScene::_onContactSeparate, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(cl, this);
    _contact = cl;

    scheduleUpdate();
    return true;
}

void GameScene::onEnter() {
    Layer::onEnter();
    if (!_world && getScene()) _world = getScene()->getPhysicsWorld();
    CCASSERT(_world, "GameScene must be under a Scene with physics");
    _world->setGravity(Vec2(0, -980));
}

void GameScene::onExit() { Layer::onExit(); }

// UI
void GameScene::buildUICamera() {
    _uiCam = Camera::createOrthographic(_vs.width, _vs.height, 1.0f, 1024.0f);
    _uiCam->setCameraFlag(CameraFlag::USER1);
    _uiCam->setPosition(_origin + Vec2(_vs.width*0.5f, _vs.height*0.5f));
    addChild(_uiCam, 999);
}
void GameScene::buildHUD() {
    _hud = HUDLayer::create();
    _hud->setCameraMask((unsigned short)CameraFlag::USER1);
    addChild(_hud, 100);
}

// Input
void GameScene::_bindInput() {
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin) {
            if (c==EventKeyboard::KeyCode::KEY_R && _gameOver) _restartLevel();
            if ((c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) && _gameWin) _returnMenu();
            return;
        }
        if (!_player) return;
        switch (c) {
            case EventKeyboard::KeyCode::KEY_A:
            case EventKeyboard::KeyCode::KEY_LEFT_ARROW:  _player->setMoveDir({-1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_D:
            case EventKeyboard::KeyCode::KEY_RIGHT_ARROW: _player->setMoveDir({ 1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_W:
            case EventKeyboard::KeyCode::KEY_UP_ARROW:
            case EventKeyboard::KeyCode::KEY_SPACE: _player->jump(); break;
            case EventKeyboard::KeyCode::KEY_J: _player->doShoot(); break;
            case EventKeyboard::KeyCode::KEY_K: _player->doSlash(); break;
            default: break;
        }
    };
    l->onKeyReleased = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin || !_player) return;
        if (c==EventKeyboard::KeyCode::KEY_A || c==EventKeyboard::KeyCode::KEY_LEFT_ARROW ||
            c==EventKeyboard::KeyCode::KEY_D || c==EventKeyboard::KeyCode::KEY_RIGHT_ARROW)
            _player->setMoveDir({0.f,0.f});
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}



// Contact
bool GameScene::_onContactBegin(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();

    // FOOT ↔ WORLD
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(1);
        return true;
    }

    // Player ↔ Item
    Node* item = nullptr;
    if (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ITEM)) item=b;
    else if (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ITEM)) item=a;
    if (item) {
        if (dynamic_cast<Star*>(item))      { _setStars(_starsHave+1, _starsNeed); _addScore(50); }
        else if (dynamic_cast<Coin*>(item)) { _addScore(10); }
        else if (dynamic_cast<Upgrade*>(item)) { _addScore(25); } // chừa chỗ cắm UpgradeSystem sau
        item->removeFromParent();
        _checkWin();
        return false;
    }

    // Bullet/Slash ↔ Enemy
    auto isSlash = [&](PhysicsShape* s)->bool { return s && s->getTag()==(int)phys::ShapeTag::SLASH; };
    Node* enemy=nullptr;
    if ( (hasCat(a,phys::CAT_BULLET)||isSlash(A)) && hasCat(b,phys::CAT_ENEMY)) enemy=b;
    else if ( (hasCat(b,phys::CAT_BULLET)||isSlash(B)) && hasCat(a,phys::CAT_ENEMY)) enemy=a;
    if (enemy) {
        if (auto e = dynamic_cast<Enemy*>(enemy)) e->takeHit(isSlash(A)||isSlash(B)?2:1);
        if (hasCat(a,phys::CAT_BULLET)) a->removeFromParent();
        if (hasCat(b,phys::CAT_BULLET)) b->removeFromParent();
        _addScore(20);
        return false;
    }

    // Enemy ↔ Player → TRỪ HP, chỉ trừ mạng khi HP hết
    if ( (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ENEMY)) ||
         (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ENEMY)) ) {
        if (_player && !_player->invincible()) {
            _player->hurt(10);                                // trừ HP
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());

            if (_player->isDead()) {
                _setLives(_lives-1);
                if (_lives<=0) {
                    _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart");
                } else {
                    _player->restoreFullHP();
                    if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
                    if (auto body = _player->getPhysicsBody()) body->setVelocity(Vec2::ZERO);
                    _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f,
                                                        _groundTop + 40.f));
                }
            }
        }
        return true;
    }

    return true;
}

void GameScene::_onContactSeparate(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(-1);
    }
}

void GameScene::update(float) {
    if (_gameOver || _gameWin || !_player) return;

    float x = _player->getPositionX();
    float target = cocos2d::clampf(x, _camL + _vs.width*0.5f, _camR - _vs.width*0.5f);
    this->getScene()->getDefaultCamera()->setPositionX(target);

    if (_player->getPositionX() > _camR - 4.0f && _segment < _segmentCount-1) {
        _segment++;
        _camL = _origin.x + _segment * _segmentWidth;
        _camR = _camL + _segmentWidth;
        if (_hud) _hud->setZone(_segment+1, _segmentCount);
    }

    // Rơi khỏi map → trừ mạng + hồi full HP
    if (_player->getPositionY() < _groundTop - 200.f) {
        _setLives(_lives-1);
        if (_lives<=0) {
            _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart");
        } else {
            _player->restoreFullHP();
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
            _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f,
                                                _groundTop + 40.f));
        }
    }
}

// HUD helpers
void GameScene::_setLives(int v){ _lives = std::max(0, v); if (_hud) _hud->setLives(_lives); }
void GameScene::_addScore(int v){ _score += v; if (_hud) _hud->setScore(_score); }
void GameScene::_setStars(int have, int need){ _starsHave = have; _starsNeed = need; if (_hud) _hud->setStars(_starsHave, _starsNeed); }
void GameScene::_checkWin(){
    if (_starsHave >= _starsNeed && !_gameWin){
        _gameWin = true;
        _showOverlay("YOU WIN!\nPress [Enter] to Menu");
    }
}
void GameScene::_restartLevel(){ Director::getInstance()->replaceScene(GameScene::createScene()); }
void GameScene::_returnMenu(){ Director::getInstance()->replaceScene(TransitionFade::create(0.25f, Scene::create())); }
void GameScene::_showOverlay(const std::string& text){
    if(!_overlay){
        _overlay = Label::createWithSystemFont(text, "Arial", 46);
        _overlay->setAlignment(TextHAlignment::CENTER);
        _overlay->setAnchorPoint({0.5f,0.5f});
        _overlay->setColor(Color3B::WHITE);
        _overlay->enableShadow();
        addChild(_overlay, 99);
    }
    _overlay->setString(text);
    _overlay->setPosition(_origin + Vec2(_camL + _segmentWidth*0.5f, _vs.height*0.6f));
}

File GameScene.h
#pragma once
#include "cocos2d.h"
#include "game/Player.h"
#include "game/Enemy.h"
#include "game/map/LevelBuilder.h"

class HUDLayer;

class GameScene : public cocos2d::Layer {
public:
    static cocos2d::Scene* createScene();
    CREATE_FUNC(GameScene);

    bool init() override;
    void onEnter() override;
    void onExit() override;
    void update(float dt) override;

    void setPhysicsWorld(cocos2d::PhysicsWorld* w) { _world = w; }

private:
    cocos2d::PhysicsWorld* _world = nullptr;
    cocos2d::Size _vs{};
    cocos2d::Vec2 _origin{};

    cocos2d::Camera* _uiCam = nullptr;
    HUDLayer*        _hud   = nullptr;
    cocos2d::Label*  _overlay = nullptr;

    Player* _player = nullptr;
    cocos2d::Vector<Enemy*> _enemies;

    float _groundTop = 0.f;
    int   _segment = 0, _segmentCount = 1;
    float _segmentWidth = 0.f;
    float _camL = 0.f, _camR = 0.f;

    int  _score=0, _lives=3, _starsHave=0, _starsNeed=5;
    bool _gameOver=false, _gameWin=false;

    cocos2d::EventListenerKeyboard*       _kb      = nullptr;
    cocos2d::EventListenerPhysicsContact* _contact = nullptr;

    // UI
    void buildUICamera();
    void buildHUD();
    void _showOverlay(const std::string& text);

    // input
    void _bindInput();
    void _doShoot();
    void _doSlash();

    // contact
    bool _onContactBegin(cocos2d::PhysicsContact& c);
    void _onContactSeparate(cocos2d::PhysicsContact& c);

    // HUD/state
    void _setLives(int v);
    void _addScore(int v);
    void _setStars(int have, int need);
    void _checkWin();
    void _restartLevel();
    void _returnMenu();
};

File MenuScene.cpp
#include "scenes/MenuScene.h"
#include "scenes/GameScene.h"
USING_NS_CC;

Scene* MenuScene::createScene(){ return MenuScene::create(); }

bool MenuScene::init(){
    if(!Scene::init()) return false;

    auto vs = Director::getInstance()->getVisibleSize();
    auto origin = Director::getInstance()->getVisibleOrigin();

    auto title = Label::createWithSystemFont("MyGame", "Arial", 48);
    title->setPosition(origin + Vec2(vs.width/2, vs.height*0.65f));
    auto hint  = Label::createWithSystemFont("[ENTER] New Game   |   [ESC] Quit","Arial",24);
    hint->setPosition(origin + Vec2(vs.width/2, vs.height*0.45f));
    addChild(title); addChild(hint);

    // Dự phòng: nếu có Menu* close từ template bị add nhầm
    for (auto ch : getChildren())
        if (auto m = dynamic_cast<Menu*>(ch)) m->setEnabled(false);

    _bindInput();
    return true;
}

void MenuScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*){
        if (c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) _goGame();
        else if (c==EventKeyboard::KeyCode::KEY_ESCAPE) Director::getInstance()->end();
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;  // lưu lại để gỡ
}

void MenuScene::onExit(){
    if (_kb) {
        _eventDispatcher->removeEventListener(_kb);
        _kb = nullptr;
    }
    Scene::onExit();
}

void MenuScene::_goGame(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, GameScene::createScene()));
}

File MenuScene.h
#pragma once
#include "cocos2d.h"

class MenuScene : public cocos2d::Scene {
public:
    CREATE_FUNC(MenuScene);
    static cocos2d::Scene* createScene();
    bool init() override;
    void onExit() override;                // <-- thêm

private:
    void _bindInput();
    void _goGame();

    cocos2d::EventListenerKeyboard* _kb = nullptr;  // <-- thêm
};


Folder Classes/ui
File HUDLayer.cpp
#include "ui/HUDLayer.h"
#include "2d/CCDrawNode.h"

using namespace cocos2d;

bool HUDLayer::init() {
    if (!Layer::init()) return false;

    // Label cơ bản
    _lLives = Label::createWithSystemFont("Lives: ❤❤❤", "Arial", 22);
    _lScore = Label::createWithSystemFont("Score: 0", "Arial", 22);
    _lStars = Label::createWithSystemFont("★ 0/5", "Arial", 22);
    _lZone  = Label::createWithSystemFont("Zone 1/5", "Arial", 22);
    for (auto* L : {_lLives, _lScore, _lStars, _lZone}) {
        L->setColor(Color3B::WHITE);
        L->enableShadow(Color4B(0,0,0,128), Size(1,-1), 1);
        addChild(L);
    }

    // HP bar + text
    _hpBar   = DrawNode::create();
    _lHpText = Label::createWithSystemFont("HP 100/100", "Arial", 20);
    _lHpText->setColor(Color3B::WHITE);
    _lHpText->enableShadow(Color4B(0,0,0,128), Size(1,-1), 1);
    addChild(_hpBar);
    addChild(_lHpText);

    _layout();
    _drawHpBar(100,100);
    return true;
}

void HUDLayer::onEnter() {
    Layer::onEnter();
    _layout();
}

void HUDLayer::_layout() {
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();

    // Trái trên: HP bar + Lives + Score
    const Vec2 hpOrigin = org + Vec2(16, vs.height - 16);
    _hpBar->setPosition(hpOrigin);
    _lHpText->setAnchorPoint({0,1});
    _lHpText->setPosition(hpOrigin + Vec2(0, -24));

    _lLives->setAnchorPoint({0,1});
    _lLives->setPosition(org + Vec2(16, vs.height - 64));

    _lScore->setAnchorPoint({0,1});
    _lScore->setPosition(org + Vec2(16, vs.height - 92));

    // Phải trên: Stars, Zone
    _lStars->setAnchorPoint({1,1});
    _lStars->setPosition(org + Vec2(vs.width - 16, vs.height - 12));

    _lZone->setAnchorPoint({1,1});
    _lZone->setPosition(org + Vec2(vs.width - 16, vs.height - 40));
}

// ---------- API ----------
void HUDLayer::setLives(int v) {
    v = std::max(0, v);
    std::string hearts;
    for (int i = 0; i < v; ++i) hearts += u8"❤";
    if (hearts.empty()) hearts = "0";
    _lLives->setString("Lives: " + hearts);
}
void HUDLayer::setScore(int v) { _lScore->setString("Score: " + std::to_string(v)); }
void HUDLayer::setStars(int have, int need) { _lStars->setString("★ " + std::to_string(have) + "/" + std::to_string(need)); }
void HUDLayer::setZone(int cur, int total) { _lZone->setString("Zone " + std::to_string(cur) + "/" + std::to_string(total)); }

void HUDLayer::setHP(int cur, int max) {
    cur = std::max(0, std::min(cur, max));
    _lHpText->setString("HP " + std::to_string(cur) + "/" + std::to_string(max));
    _drawHpBar(cur, max);
}

void HUDLayer::_drawHpBar(int cur, int max) {
    _hpBar->clear();
    const float W = 200.f, H = 18.f, pad = 2.f;
    _hpBar->drawSolidRect(Vec2(0, -H), Vec2(W, 0), Color4F(0,0,0,0.45f)); // khung
    _hpBar->drawSolidRect(Vec2(pad, -H+pad), Vec2(W-pad, -pad), Color4F(0.2f,0.2f,0.25f,0.9f)); // nền
    float ratio = (max>0)? (float)cur/(float)max : 0.f;
    float ww = (W-2*pad) * ratio;
    _hpBar->drawSolidRect(Vec2(pad, -H+pad), Vec2(pad+ww, -pad), Color4F(0.2f,0.9f,0.3f,1.f));  // máu
}

File HUDLayer.h
#pragma once
#include "cocos2d.h"

class HUDLayer : public cocos2d::Layer {
public:
    CREATE_FUNC(HUDLayer);

    bool init() override;
    void onEnter() override;

    // ===== API GameScene gọi =====
    void setLives(int v);                    // v trái tim (❤❤❤)
    void setScore(int v);                    // điểm
    void setStars(int have, int need);       // sao đã nhặt / cần
    void setZone(int cur, int total);        // đoạn hiện tại / tổng
    void setHP(int cur, int max);            // <--- thêm: thanh HP + số

private:
    cocos2d::Label*   _lLives = nullptr;
    cocos2d::Label*   _lScore = nullptr;
    cocos2d::Label*   _lStars = nullptr;
    cocos2d::Label*   _lZone  = nullptr;

    // HP bar vẽ bằng DrawNode để sau này dễ thay asset
    cocos2d::DrawNode* _hpBar   = nullptr;
    cocos2d::Label*    _lHpText = nullptr;

    void _layout();                          // đặt vị trí label theo màn hình
    void _drawHpBar(int cur, int max);
};


