===== PROJECT TREE =====
./
â”œâ”€â”€ CMakeLists.txt
â””â”€â”€ Classes
    â”œâ”€â”€ main.cpp
    â”œâ”€â”€ audio
    â”‚   â”œâ”€â”€ Sound.cpp
    â”‚   â””â”€â”€ Sound.h
    â”œâ”€â”€ core
    â”‚   â”œâ”€â”€ AppDelegate.cpp
    â”‚   â”œâ”€â”€ AppDelegate.h
    â”‚   â”œâ”€â”€ CrashGuard.h
    â”‚   â””â”€â”€ Settings.h
    â”œâ”€â”€ game
    â”‚   â”œâ”€â”€ Enemy.cpp
    â”‚   â”œâ”€â”€ Enemy.h
    â”‚   â”œâ”€â”€ Entity.cpp
    â”‚   â”œâ”€â”€ Entity.h
    â”‚   â”œâ”€â”€ Player.cpp
    â”‚   â”œâ”€â”€ Player.h
    â”‚   â”œâ”€â”€ bosses
    â”‚   â”‚   â”œâ”€â”€ BossGolem.cpp
    â”‚   â”‚   â””â”€â”€ BossGolem.h
    â”‚   â”œâ”€â”€ enemies
    â”‚   â”‚   â”œâ”€â”€ Goomba.cpp
    â”‚   â”‚   â”œâ”€â”€ Goomba.h
    â”‚   â”‚   â”œâ”€â”€ Spiker.cpp
    â”‚   â”‚   â””â”€â”€ Spiker.h
    â”‚   â”œâ”€â”€ loot
    â”‚   â”‚   â”œâ”€â”€ LootTable.cpp
    â”‚   â”‚   â””â”€â”€ LootTable.h
    â”‚   â”œâ”€â”€ map
    â”‚   â”‚   â”œâ”€â”€ LevelBuilder.cpp
    â”‚   â”‚   â””â”€â”€ LevelBuilder.h
    â”‚   â”œâ”€â”€ objects
    â”‚   â”‚   â”œâ”€â”€ Chest.cpp
    â”‚   â”‚   â”œâ”€â”€ Chest.h
    â”‚   â”‚   â”œâ”€â”€ Coin.cpp
    â”‚   â”‚   â”œâ”€â”€ Coin.h
    â”‚   â”‚   â”œâ”€â”€ Crate.cpp
    â”‚   â”‚   â”œâ”€â”€ Crate.h
    â”‚   â”‚   â”œâ”€â”€ Gate.cpp
    â”‚   â”‚   â”œâ”€â”€ Gate.h
    â”‚   â”‚   â”œâ”€â”€ PressurePlate.cpp
    â”‚   â”‚   â”œâ”€â”€ PressurePlate.h
    â”‚   â”‚   â”œâ”€â”€ Star.cpp
    â”‚   â”‚   â”œâ”€â”€ Star.h
    â”‚   â”‚   â”œâ”€â”€ Upgrade.cpp
    â”‚   â”‚   â””â”€â”€ Upgrade.h
    â”‚   â”œâ”€â”€ upgrades
    â”‚   â”‚   â”œâ”€â”€ UpgradeSystem.cpp
    â”‚   â”‚   â””â”€â”€ UpgradeSystem.h
    â”‚   â””â”€â”€ weapon
    â”‚       â”œâ”€â”€ Bullet.cpp
    â”‚       â”œâ”€â”€ Bullet.h
    â”‚       â”œâ”€â”€ Slash.cpp
    â”‚       â””â”€â”€ Slash.h
    â”œâ”€â”€ physics
    â”‚   â””â”€â”€ PhysicsDefs.h
    â”œâ”€â”€ scenes
    â”‚   â”œâ”€â”€ CreditsScene.cpp
    â”‚   â”œâ”€â”€ CreditsScene.h
    â”‚   â”œâ”€â”€ EndScene.cpp
    â”‚   â”œâ”€â”€ EndScene.h
    â”‚   â”œâ”€â”€ GameScene.cpp
    â”‚   â”œâ”€â”€ GameScene.h
    â”‚   â”œâ”€â”€ MenuScene.cpp
    â”‚   â”œâ”€â”€ MenuScene.h
    â”‚   â”œâ”€â”€ SettingsScene.cpp
    â”‚   â””â”€â”€ SettingsScene.h
    â””â”€â”€ ui
        â”œâ”€â”€ HUDLayer.cpp
        â”œâ”€â”€ HUDLayer.h
        â”œâ”€â”€ PauseLayer.cpp
        â””â”€â”€ PauseLayer.h

===== FILE MANIFEST =====
- CMakeLists.txt â€” 8656 bytes â€” ok
- Classes/main.cpp â€” 178 bytes â€” ok
- Classes/audio/Sound.cpp â€” 2991 bytes â€” ok
- Classes/audio/Sound.h â€” 485 bytes â€” ok
- Classes/core/AppDelegate.cpp â€” 1717 bytes â€” ok
- Classes/core/AppDelegate.h â€” 362 bytes â€” ok
- Classes/core/CrashGuard.h â€” 195 bytes â€” ok
- Classes/core/Settings.h â€” 641 bytes â€” ok
- Classes/game/Enemy.cpp â€” 6908 bytes â€” ok
- Classes/game/Enemy.h â€” 2154 bytes â€” ok
- Classes/game/Entity.cpp â€” 187 bytes â€” ok
- Classes/game/Entity.h â€” 788 bytes â€” ok
- Classes/game/Player.cpp â€” 11939 bytes â€” ok
- Classes/game/Player.h â€” 2927 bytes â€” ok
- Classes/game/bosses/BossGolem.cpp â€” 11319 bytes â€” ok
- Classes/game/bosses/BossGolem.h â€” 658 bytes â€” ok
- Classes/game/enemies/Goomba.cpp â€” 2316 bytes â€” ok
- Classes/game/enemies/Goomba.h â€” 197 bytes â€” ok
- Classes/game/enemies/Spiker.cpp â€” 2463 bytes â€” ok
- Classes/game/enemies/Spiker.h â€” 195 bytes â€” ok
- Classes/game/loot/LootTable.cpp â€” 3517 bytes â€” ok
- Classes/game/loot/LootTable.h â€” 1041 bytes â€” ok
- Classes/game/map/LevelBuilder.cpp â€” 14710 bytes â€” ok
- Classes/game/map/LevelBuilder.h â€” 476 bytes â€” ok
- Classes/game/objects/Chest.cpp â€” 1869 bytes â€” ok
- Classes/game/objects/Chest.h â€” 376 bytes â€” ok
- Classes/game/objects/Coin.cpp â€” 1454 bytes â€” ok
- Classes/game/objects/Coin.h â€” 279 bytes â€” ok
- Classes/game/objects/Crate.cpp â€” 792 bytes â€” ok
- Classes/game/objects/Crate.h â€” 152 bytes â€” ok
- Classes/game/objects/Gate.cpp â€” 1059 bytes â€” ok
- Classes/game/objects/Gate.h â€” 287 bytes â€” ok
- Classes/game/objects/PressurePlate.cpp â€” 725 bytes â€” ok
- Classes/game/objects/PressurePlate.h â€” 320 bytes â€” ok
- Classes/game/objects/Star.cpp â€” 1518 bytes â€” ok
- Classes/game/objects/Star.h â€” 190 bytes â€” ok
- Classes/game/objects/Upgrade.cpp â€” 3405 bytes â€” ok
- Classes/game/objects/Upgrade.h â€” 1042 bytes â€” ok
- Classes/game/upgrades/UpgradeSystem.cpp â€” 1454 bytes â€” ok
- Classes/game/upgrades/UpgradeSystem.h â€” 1099 bytes â€” ok
- Classes/game/weapon/Bullet.cpp â€” 2103 bytes â€” ok
- Classes/game/weapon/Bullet.h â€” 473 bytes â€” ok
- Classes/game/weapon/Slash.cpp â€” 2586 bytes â€” ok
- Classes/game/weapon/Slash.h â€” 381 bytes â€” ok
- Classes/physics/PhysicsDefs.h â€” 3795 bytes â€” ok
- Classes/scenes/CreditsScene.cpp â€” 2629 bytes â€” ok
- Classes/scenes/CreditsScene.h â€” 342 bytes â€” ok
- Classes/scenes/EndScene.cpp â€” 2534 bytes â€” ok
- Classes/scenes/EndScene.h â€” 267 bytes â€” ok
- Classes/scenes/GameScene.cpp â€” 19600 bytes â€” ok
- Classes/scenes/GameScene.h â€” 1982 bytes â€” ok
- Classes/scenes/MenuScene.cpp â€” 6263 bytes â€” ok
- Classes/scenes/MenuScene.h â€” 590 bytes â€” ok
- Classes/scenes/SettingsScene.cpp â€” 5339 bytes â€” ok
- Classes/scenes/SettingsScene.h â€” 570 bytes â€” ok
- Classes/ui/HUDLayer.cpp â€” 5546 bytes â€” ok
- Classes/ui/HUDLayer.h â€” 1408 bytes â€” ok
- Classes/ui/PauseLayer.cpp â€” 3803 bytes â€” ok
- Classes/ui/PauseLayer.h â€” 300 bytes â€” ok



Folder .
File CMakeLists.txt
cmake_minimum_required(VERSION 3.20)

# ================== Project meta ==================
set(APP_NAME Faterial)
project(${APP_NAME} C CXX)

# Chuáº©n C/C++
set(CMAKE_C_STANDARD 99)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ================== MSVC runtime & common defs ==================
if (MSVC)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL" CACHE STRING "" FORCE)
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS NOMINMAX)
    add_compile_options(/MP /utf-8)
endif()

# ================== Cocos2d-x engine ==================
if(NOT DEFINED BUILD_ENGINE_DONE)
    set(COCOS2DX_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cocos2d)
    set(CMAKE_MODULE_PATH ${COCOS2DX_ROOT_PATH}/cmake/Modules/)
    include(CocosBuildSet)
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos ${ENGINE_BINARY_PATH}/cocos/core)
endif()

# ================== Resources ==================
set(GAME_RES_FOLDER "${CMAKE_CURRENT_SOURCE_DIR}/Resources")
if(APPLE OR WINDOWS)
    cocos_mark_multi_resources(common_res_files RES_TO "Resources" FOLDERS ${GAME_RES_FOLDER})
endif()

# ===== Helper: chá»‰ append file náº¿u tá»“n táº¡i (cho optional scenes) =====
function(append_if_exists outvar)
    foreach(f IN LISTS ARGN)
        if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/${f}")
            list(APPEND ${outvar} ${f})
        endif()
    endforeach()
    set(${outvar} "${${outvar}}" PARENT_SCOPE)
endfunction()

# ================== Game headers & sources ==================
set(GAME_HEADER
    # core
    Classes/core/AppDelegate.h
    Classes/core/CrashGuard.h

    # physics
    Classes/physics/PhysicsDefs.h

    # ui
    Classes/ui/HUDLayer.h
    Classes/ui/PauseLayer.h            # << thÃªm

    # scenes
    Classes/scenes/MenuScene.h
    Classes/scenes/GameScene.h
    # optional scenes (tá»± Ä‘á»™ng náº¿u cÃ³)
)
append_if_exists(GAME_HEADER
    Classes/scenes/SettingsScene.h
    Classes/scenes/CreditsScene.h
    Classes/scenes/EndScene.h
)

set(GAME_SRC
    # core
    Classes/core/AppDelegate.cpp

    # ui
    Classes/ui/HUDLayer.cpp
    Classes/ui/PauseLayer.cpp          # << thÃªm (QUAN TRá»ŒNG)

    # scenes
    Classes/scenes/MenuScene.cpp
    Classes/scenes/GameScene.cpp
    # optional scenes (tá»± Ä‘á»™ng náº¿u cÃ³)
)
append_if_exists(GAME_SRC
    Classes/scenes/SettingsScene.cpp
    Classes/scenes/CreditsScene.cpp
    Classes/scenes/EndScene.cpp
)

# game base
list(APPEND GAME_HEADER
    Classes/game/Entity.h
    Classes/game/Player.h
    Classes/game/Enemy.h
    Classes/audio/Sound.h
)
list(APPEND GAME_SRC
    Classes/game/Entity.cpp
    Classes/game/Player.cpp
    Classes/game/Enemy.cpp
    Classes/audio/Sound.cpp
)

# enemies / bosses
list(APPEND GAME_HEADER
    Classes/game/enemies/Goomba.h
    Classes/game/enemies/Spiker.h
    Classes/game/bosses/BossGolem.h
)
list(APPEND GAME_SRC
    Classes/game/enemies/Goomba.cpp
    Classes/game/enemies/Spiker.cpp
    Classes/game/bosses/BossGolem.cpp
)

# objects
list(APPEND GAME_HEADER
    Classes/game/objects/Coin.h
    Classes/game/objects/Star.h
    Classes/game/objects/Upgrade.h
    Classes/game/objects/Crate.h
    Classes/game/objects/Gate.h
    Classes/game/objects/PressurePlate.h
    Classes/game/objects/Chest.h
)
list(APPEND GAME_SRC
    Classes/game/objects/Coin.cpp
    Classes/game/objects/Star.cpp
    Classes/game/objects/Upgrade.cpp
    Classes/game/objects/Crate.cpp
    Classes/game/objects/Gate.cpp
    Classes/game/objects/PressurePlate.cpp
    Classes/game/objects/Chest.cpp
)

# weapon
list(APPEND GAME_HEADER
    Classes/game/weapon/Bullet.h
    Classes/game/weapon/Slash.h
)
list(APPEND GAME_SRC
    Classes/game/weapon/Bullet.cpp
    Classes/game/weapon/Slash.cpp
)

# loot & map
list(APPEND GAME_HEADER
    Classes/game/loot/LootTable.h
    Classes/game/map/LevelBuilder.h
)
list(APPEND GAME_SRC
    Classes/game/loot/LootTable.cpp
    Classes/game/map/LevelBuilder.cpp
)

# ================== Platform glue ==================
if(ANDROID)
    list(APPEND GAME_SRC proj.android/app/jni/hellocpp/main.cpp)

elseif(LINUX)
    list(APPEND GAME_SRC proj.linux/main.cpp)

elseif(WINDOWS)
    list(APPEND GAME_HEADER
        proj.win32/main.h
        proj.win32/resource.h
    )
    list(APPEND GAME_SRC
        proj.win32/main.cpp
        proj.win32/game.rc
        ${common_res_files}
    )

elseif(APPLE)
    if(IOS)
        list(APPEND GAME_HEADER
            proj.ios_mac/ios/AppController.h
            proj.ios_mac/ios/RootViewController.h
        )
        set(APP_UI_RES
            proj.ios_mac/ios/LaunchScreen.storyboard
            proj.ios_mac/ios/LaunchScreenBackground.png
            proj.ios_mac/ios/Images.xcassets
        )
        list(APPEND GAME_SRC
            proj.ios_mac/ios/main.m
            proj.ios_mac/ios/AppController.mm
            proj.ios_mac/ios/RootViewController.mm
            proj.ios_mac/ios/Prefix.pch
            ${APP_UI_RES}
        )
    elseif(MACOSX)
        set(APP_UI_RES
            proj.ios_mac/mac/Icon.icns
            proj.ios_mac/mac/Info.plist
        )
        list(APPEND GAME_SRC
            proj.ios_mac/mac/main.cpp
            proj.ios_mac/mac/Prefix.pch
            ${APP_UI_RES}
        )
    endif()
    list(APPEND GAME_SRC ${common_res_files})
endif()

# ================== Target ==================
set(all_code_files ${GAME_HEADER} ${GAME_SRC})

if(NOT ANDROID)
    add_executable(${APP_NAME} ${all_code_files})
else()
    add_library(${APP_NAME} SHARED ${all_code_files})
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos/platform/android ${ENGINE_BINARY_PATH}/cocos/platform)
    target_link_libraries(${APP_NAME} PRIVATE -Wl,--whole-archive cpp_android_spec -Wl,--no-whole-archive)
endif()

# ================== Include paths ==================
target_include_directories(${APP_NAME}
    PRIVATE Classes
    PRIVATE Classes/core
    PRIVATE Classes/physics
    PRIVATE Classes/ui
    PRIVATE Classes/scenes
    PRIVATE Classes/game
    PRIVATE Classes/game/enemies
    PRIVATE Classes/game/bosses
    PRIVATE Classes/game/objects
    PRIVATE Classes/game/weapon
    PRIVATE Classes/game/loot
    PRIVATE Classes/game/map
    PRIVATE ${COCOS2DX_ROOT_PATH}/cocos/audio/include/  # AudioEngine
)

# ================== Link engine + system libs ==================
target_link_libraries(${APP_NAME} PRIVATE cocos2d)
if (MSVC)
    target_link_options(${APP_NAME} PRIVATE /NODEFAULTLIB:LIBCMT /IGNORE:4098)
    target_link_libraries(${APP_NAME} PRIVATE winmm DbgHelp legacy_stdio_definitions)
endif()

# ================== App config & copy resources/DLL ==================
setup_cocos_app_config(${APP_NAME})

# PhÃ¡t hiá»‡n optional scenes Ä‘á»ƒ báº­t macro cho MenuScene
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/Classes/scenes/SettingsScene.h")
    target_compile_definitions(${APP_NAME} PRIVATE USE_SETTINGS_SCENE=1)
endif()
if(EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/Classes/scenes/CreditsScene.h")
    target_compile_definitions(${APP_NAME} PRIVATE USE_CREDITS_SCENE=1)
endif()

# Ã‰p exe & dll vÃ o build/bin (khÃ´ng táº¡o Debug/Release con)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
foreach(cfg Debug Release RelWithDebInfo MinSizeRel)
    set_target_properties(${APP_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        LIBRARY_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        ARCHIVE_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/lib
    )
endforeach()

# Windows: copy DLL engine (glew, glfw, openal, â€¦) vá» cáº¡nh .exe
if(WINDOWS)
    cocos_copy_target_dll(${APP_NAME})
endif()

# Copy Resources vÃ o cáº¡nh .exe (Windows/Linux/macOS)
if(LINUX OR WINDOWS)
    cocos_get_resource_path(APP_RES_DIR ${APP_NAME})
    cocos_copy_target_res(${APP_NAME} LINK_TO ${APP_RES_DIR} FOLDERS ${GAME_RES_FOLDER})
endif()

# (macOS/iOS) gÃ¡n tÃ i nguyÃªn UI
if(APPLE)
    set_target_properties(${APP_NAME} PROPERTIES RESOURCE "${APP_UI_RES}")
    if(MACOSX)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/mac/Info.plist")
    elseif(IOS)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/ios/Info.plist")
        set_xcode_property(${APP_NAME} ASSETCATALOG_COMPILER_APPICON_NAME "AppIcon")
    endif()
endif()


Folder Classes
File main.cpp
#include "core/AppDelegate.h"
#include "cocos2d.h"

USING_NS_CC;

int main(int argc, char** argv) {
    AppDelegate app;
    return Application::getInstance()->run();
}


Folder Classes/audio
File Sound.cpp
#include "audio/Sound.h"
#include "audio/include/AudioEngine.h"
#include "base/CCUserDefault.h"
#include "platform/CCFileUtils.h"
#include "base/ccMacros.h"
#include "cocos2d.h"
#include <string>

using namespace cocos2d;
using AE = cocos2d::AudioEngine;

namespace {
    int   s_bgmId  = -1;
    float s_music  = 0.8f;
    float s_sfx    = 0.8f;
    std::string s_bgmFile;

    // Cho phÃ©p chá»‰ Ä‘áº·t "gá»‘c tÃªn" (khÃ´ng Ä‘uÃ´i) trong Resources/audio/
    static const char* kBgmMain = "audio/bgm_main";
    static const char* kSlash   = "audio/sfx_slash";
    static const char* kShoot   = "audio/sfx_shoot";
    static const char* kPickup  = "audio/sfx_pickup";

    static std::string pickExisting(const std::string& stem) {
        static const char* exts[3] = { ".wav", ".mp3", ".ogg" };
        FileUtils* fu = FileUtils::getInstance();
        for (int i = 0; i < 3; ++i) {
            std::string p = stem + exts[i];
            if (fu->isFileExist(p)) return p;
        }
        CCLOG("SND missing: none of (%s.wav|.mp3|.ogg) exists", stem.c_str());
        return std::string();
    }

    static int play2dSafe(const std::string& file, bool loop, float vol) {
        if (file.empty()) return -1;
        int id = AE::play2d(file, loop, vol);
        if (id == -1) CCLOG("SND play2d failed: %s", file.c_str());
        return id;
    }
}

void snd::init() {
    UserDefault* ud = UserDefault::getInstance();
    s_music = clampf(ud->getFloatForKey("cfg.music", 0.8f), 0.f, 1.f);
    s_sfx   = clampf(ud->getFloatForKey("cfg.sfx",   0.8f), 0.f, 1.f);

    std::string p;
    p = pickExisting(kSlash);   if (!p.empty()) AE::preload(p);
    p = pickExisting(kShoot);   if (!p.empty()) AE::preload(p);
    p = pickExisting(kPickup);  if (!p.empty()) AE::preload(p);
}

void snd::setVolumes(float music, float sfx) {
    s_music = clampf(music, 0.f, 1.f);
    s_sfx   = clampf(sfx,   0.f, 1.f);
    if (s_bgmId != -1) AE::setVolume(s_bgmId, s_music);
}

float snd::musicVol() { return s_music; }
float snd::sfxVol()   { return s_sfx;   }

void snd::playBgm(const std::string& fileOrStem, bool loop) {
    std::string file = fileOrStem;

    FileUtils* fu = FileUtils::getInstance();
    if (!fu->isFileExist(file)) {
        if (file.find('.') == std::string::npos) {
            file = pickExisting(file);
        } else {
            std::string stem = file.substr(0, file.find_last_of('.'));
            file = pickExisting(stem);
        }
    }

    if (s_bgmId != -1) { AE::stop(s_bgmId); s_bgmId = -1; }
    s_bgmFile = file;
    s_bgmId   = play2dSafe(file, loop, s_music);
}

void snd::stopBgm() {
    if (s_bgmId != -1) { AE::stop(s_bgmId); s_bgmId = -1; }
}

void snd::sfxSlash() { play2dSafe(pickExisting(kSlash),  false, s_sfx); }
void snd::sfxShoot() { play2dSafe(pickExisting(kShoot),  false, s_sfx); }
void snd::sfxCoin()  { play2dSafe(pickExisting(kPickup), false, s_sfx); }

File Sound.h
#pragma once
#include <string>

namespace snd {
    // Gá»i 1 láº§n á»Ÿ App khá»Ÿi Ä‘á»™ng
    void init();

    // Ãp dá»¥ng volume (0..1), tá»± láº¥y tá»« UserDefault náº¿u báº¡n muá»‘n
    void setVolumes(float music, float sfx);
    float musicVol();
    float sfxVol();

    // Nháº¡c ná»n
    void playBgm(const std::string& file, bool loop = true);
    void stopBgm();

    // Hiá»‡u á»©ng
    void sfxSlash();
    void sfxShoot();
    void sfxCoin();
}


Folder Classes/core
File AppDelegate.cpp
// AppDelegate.cpp
#include "core/AppDelegate.h"
#include "base/CCDirector.h"
#include "platform/CCGLView.h"
#include "scenes/MenuScene.h"

// Ã‚m thanh
#include "audio/include/AudioEngine.h"
#include "audio/Sound.h"

USING_NS_CC;
using AE = cocos2d::AudioEngine;

AppDelegate::AppDelegate() {}
AppDelegate::~AppDelegate() {
    // Giáº£i phÃ³ng AudioEngine an toÃ n khi thoÃ¡t app
    AE::end();
}

void AppDelegate::initGLContextAttrs() {
    GLContextAttrs a{8,8,8,8,24,8};
    GLView::setGLContextAttrs(a);
}

bool AppDelegate::applicationDidFinishLaunching() {
    auto* director = Director::getInstance();
    auto* glview   = director->getOpenGLView();
    if (!glview) {
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
        glview = GLViewImpl::createWithRect("Faterial", Rect(0,0,1920,1080));
#else
        glview = GLViewImpl::create("Faterial");
#endif
        director->setOpenGLView(glview);
    }

    director->setAnimationInterval(1.0f/60.0f);
#if COCOS2D_DEBUG
    director->setDisplayStats(true);
#endif

    // Thiáº¿t láº­p thiáº¿t káº¿ mÃ n hÃ¬nh
    glview->setDesignResolutionSize(1280, 720, ResolutionPolicy::NO_BORDER);

    // Khá»Ÿi táº¡o Ã¢m thanh (Ä‘á»c volume Ä‘Ã£ lÆ°u, preload sfx)
    snd::init();

    // Cháº¡y vÃ o Menu
    director->runWithScene(MenuScene::createScene());
    return true;
}

void AppDelegate::applicationDidEnterBackground() {
    // Táº¡m dá»«ng render + Ã¢m thanh
    Director::getInstance()->stopAnimation();
    AE::pauseAll();
}

void AppDelegate::applicationWillEnterForeground() {
    // Tiáº¿p tá»¥c render + Ã¢m thanh
    Director::getInstance()->startAnimation();
    AE::resumeAll();
}

File AppDelegate.h
// AppDelegate.h
#pragma once
#include "cocos2d.h"
class AppDelegate : private cocos2d::Application {
public:
    AppDelegate();
    virtual ~AppDelegate();
    virtual void initGLContextAttrs();
    virtual bool applicationDidFinishLaunching();
    virtual void applicationDidEnterBackground();
    virtual void applicationWillEnterForeground();
};

File CrashGuard.h
#pragma once
#include <cstdio>
#define CG_LOGF(path, fmt, ...) \
  do { FILE* f=nullptr; fopen_s(&f, (path), "a"); if(f){std::fprintf(f, fmt "\n", ##__VA_ARGS__); std::fclose(f);} } while(0)

File Settings.h
#pragma once
#include "base/CCUserDefault.h"

struct Settings {
    float musicVolume = 0.8f; // 0..1
    float sfxVolume   = 1.0f; // 0..1

    static Settings load() {
        Settings s;
        auto* ud = cocos2d::UserDefault::getInstance();
        s.musicVolume = ud->getFloatForKey("musicVolume", 0.8f);
        s.sfxVolume   = ud->getFloatForKey("sfxVolume",   1.0f);
        return s;
    }
    void save() const {
        auto* ud = cocos2d::UserDefault::getInstance();
        ud->setFloatForKey("musicVolume", musicVolume);
        ud->setFloatForKey("sfxVolume",   sfxVolume);
        ud->flush();
    }
};


Folder Classes/game
File Enemy.cpp
#include "game/Enemy.h"
#include "game/Player.h"

#include "game/objects/Coin.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Chest.h"
#include "game/loot/LootTable.h"

#include "physics/PhysicsDefs.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"

#include "2d/CCDrawNode.h"
#include "2d/CCDrawNode.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"



using namespace cocos2d;

static inline void drawMiniHp(DrawNode* dn, int cur, int max) {
    if (!dn) return;
    dn->clear();
    const float W=30.f, H=4.f, pad=1.f;
    dn->drawSolidRect(Vec2(-W*0.5f, 10), Vec2(W*0.5f, 10+H), Color4F(0,0,0,0.55f));
    float ratio = (max>0)? (float)cur/(float)max : 0.f;
    float ww = (W-2*pad) * ratio;
    dn->drawSolidRect(Vec2(-W*0.5f+pad, 10+pad), Vec2(-W*0.5f+pad+ww, 10+H-pad),
                      Color4F(0.25f,0.95f,0.35f,1));
}

static inline float sgn(float x) { return (x > 0.f) ? 1.f : (x < 0.f ? -1.f : 0.f); }

bool Enemy::init() {
    if (!Entity::init()) return false;
    setTagEx((int)phys::Tag::ENEMY);

    // _sprite = Sprite::create();
    // _sprite->setTextureRect(Rect(0,0,42,42));
    // _sprite->setColor(Color3B(200,70,70));
    // addChild(_sprite);

    _hpbar = DrawNode::create();
    addChild(_hpbar, 2);

    schedule([this](float dt) { updateEnemy(dt); }, "enemy.tick");
    return true;
}


Vector<SpriteFrame*> Enemy::buildFrames(const std::string& animName, int frameCount, const std::string& className) {

    Vector<SpriteFrame*> frames;
    for (int i = 1; i < frameCount+1; ++i) {
        std::string path = StringUtils::format("sprites/%s/%s/%s_%d.png", className.c_str(), animName.c_str(), animName.c_str(), i);
        auto tex = Director::getInstance()->getTextureCache()->addImage(path);
        if (!tex) break; // khÃ´ng tÃ¬m tháº¥y file => dá»«ng
        Rect rect(0, 0, tex->getPixelsWide(), tex->getPixelsHigh());
        frames.pushBack(SpriteFrame::create(path, rect));
    }
    return frames;

}

void Enemy::playAnim(const std::string& animName, float delay, int frameCount, const std::string& className) {
    CCLOG("Play anim: %s", animName.c_str());
    if (_currentAnim == animName) return;

    auto frames = buildFrames(animName, frameCount, className);
    if (frames.empty()) {
        CCLOG("KhÃ´ng tÃ¬m tháº¥y frame cho anim: %s", animName.c_str());
        return;
    }
    _currentAnim = animName;
    auto animation = Animation::createWithSpriteFrames(frames, delay);
    auto act = RepeatForever::create(Animate::create(animation));

    if (_sprite) {
        _sprite->stopAllActions();
        _sprite->runAction(act);
    }
}

void Enemy::enablePhysics(const Vec2& pos, const Size& bodySize) {
    _body = buildOrUpdateBody(bodySize);
    applyEnemyMasks();
    setPosition(pos);
    _updateHpBar();
}

PhysicsBody* Enemy::buildOrUpdateBody(const Size& szIn) {
    Size box = (szIn.width < 1 || szIn.height < 1) ? Size(42, 42) : szIn;
    PhysicsBody* body = _body;

    if (!body) {
        body = PhysicsBody::createBox(box, PhysicsMaterial(0.2f, 0.0f, 0.4f));
        body->setDynamic(true);
        body->setRotationEnable(false);
        addComponent(body);
    } else {
        auto shapes = body->getShapes();
        for (auto s : shapes) body->removeShape(s);
        body->addShape(PhysicsShapeBox::create(box, PhysicsMaterial(0.2f, 0.0f, 0.4f)));
    }

    body->setLinearDamping(0.1f);
    body->setMass(1.0f);
    return body;
}

void Enemy::applyEnemyMasks() {
    if (!_body) return;
    _body->setCategoryBitmask((int)phys::CAT_ENEMY);
    _body->setCollisionBitmask((int)(phys::CAT_WORLD | phys::CAT_PLAYER | phys::CAT_CRATE | phys::CAT_GATE));
    _body->setContactTestBitmask((int)phys::CAT_ALL);
}

void Enemy::setPatrol(const Vec2& a, const Vec2& b) {
    _pA = a; _pB = b;
    if (_pA.x > _pB.x) std::swap(_pA, _pB);
    if (getPosition().fuzzyEquals(Vec2::ZERO, 0.1f))
        setPosition((_pA + _pB) * 0.5f);
}


void Enemy::updateEnemy(float) {
    // if (!_body) return;

    // Vec2 v = _body->getVelocity();

    // // Äuá»•i khi báº­t aggro + trong táº§m (giá»›i háº¡n lá»‡ch Y Ä‘á»ƒ khÃ´ng â€œhÃºt xuyÃªn táº§ngâ€)
    // bool chasing = false;
    // if (_aggroEnabled && _target) {
    //     float dx = _target->getPositionX() - getPositionX();
    //     float dy = _target->getPositionY() - getPositionY();
    //     if (std::abs(dx) <= _aggroRange && std::abs(dy) <= 160.f) {
    //         _dir = (dx >= 0 ? +1 : -1);
    //         v.x = _dir * _chaseSpeed;
    //         chasing = true;
    //     }
    // }

    // // KhÃ´ng Ä‘uá»•i -> tuáº§n tra giá»¯a 2 má»‘c
    // if (!chasing && _pA != _pB) {
    //     float x = getPositionX();
    //     if (_dir > 0 && x >= _pB.x) _dir = -1;
    //     else if (_dir < 0 && x <= _pA.x) _dir = +1;
    //     v.x = _dir * _moveSpeed;
    // }

    // v.y = std::max(v.y, -900.0f);
    // _body->setVelocity(v);
}

void Enemy::_updateHpBar() {
    _hpbar->clear();
    const float w = 46.f, h = 4.f;
    const float t = std::max(0.f, std::min(1.f, _hp / (float)_maxHp));
    Vec2 base(-w * 0.5f, 28.f);
    _hpbar->drawSolidRect(base, base + Vec2(w, h), Color4F(0, 0, 0, 0.6f));
    _hpbar->drawSolidRect(base + Vec2(1, 1), base + Vec2(1 + (w - 2) * t, h - 1),
                          Color4F(0.9f, 0.2f, 0.2f, 0.95f));
}

// RÆ¡i Ä‘á»“: Ä‘áº©y vá» LootTable (Ä‘Ã£ loáº¡i STAR)
void Enemy::_dropLoot() {
    if (auto parent = getParent())
        LootTable::dropAt(parent, getPosition());
}

void Enemy::takeHit(int dmg) {
    if (_dead) return;

    _hp -= std::max(1, dmg);
    _updateHpBar();

    if (_hp <= 0) {
        _dead = true;

        // Ngáº¯t tÆ°Æ¡ng tÃ¡c váº­t lÃ½ rá»“i rÆ¡i Ä‘á»“ Ä‘Ãºng 1 láº§n
        scheduleOnce([this](float) {
            if (_body) {
                _body->setVelocity(Vec2::ZERO);
                _body->setDynamic(false);
                _body->setCategoryBitmask(0);
                _body->setCollisionBitmask(0);
                _body->setContactTestBitmask(0);
            }

            _dropLoot(); // <- duy nháº¥t chá»— nÃ y, KHÃ”NG Star

            runAction(Sequence::create(
                FadeOut::create(0.08f),
                CallFunc::create([this] { removeFromParent(); }),
                nullptr
            ));
        }, 0.0f, "enemy_die_defer");
        return;
    }

    if (_sprite) {
        _sprite->runAction(Sequence::create(
            TintTo::create(0.0f, 255, 120, 120),
            DelayTime::create(0.05f),
            TintTo::create(0.0f, 200, 70, 70),
            nullptr
        ));
    }
}

File Enemy.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"
#include "game/Entity.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"

class Player;

class Enemy : public Entity {
public:
    CREATE_FUNC(Enemy);
    bool init() override;
    void enablePhysics(const cocos2d::Vec2& pos, const cocos2d::Size& bodySize = cocos2d::Size(42, 42));

    void setPatrol(const cocos2d::Vec2& a, const cocos2d::Vec2& b);

    // Target + Aggro
    void setTarget(Player* p)             { _target = p; }
    void setAggroEnabled(bool on)         { _aggroEnabled = on; }
    void setAggroRange(float r)           { _aggroRange = std::max(0.f, r); }
    void setChaseSpeed(float v)           { _chaseSpeed = std::max(10.f, v); }

    virtual void takeHit(int dmg);
    virtual void updateEnemy(float dt);   // cÃ³ chase theo aggro

    void setMoveSpeed(float v) { _moveSpeed = v; }
    void setMaxHp(int v) { _maxHp = _hp = std::max(1, v); _updateHpBar(); }

protected:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& sz);
    void applyEnemyMasks();

    void _updateHpBar();
    void _dropLoot();

protected:
    cocos2d::Sprite*      _sprite  = nullptr;
    cocos2d::PhysicsBody* _body    = nullptr;
    cocos2d::DrawNode*    _hpbar   = nullptr;
    Player*               _target  = nullptr;

    std::string _currentAnim;
    
    //!PLAY ANIMATION
    void playAnim(const std::string& name, float delay, int frames, const std::string& className);
    // !helper to build frames either from SpriteFrameCache (.plist) or from individual png files
    virtual cocos2d::Vector<cocos2d::SpriteFrame*> buildFrames(const std::string& animName, int frameCount, const std::string& className);
    cocos2d::Vec2 _pA, _pB;
    int   _dir = +1;
    float _moveSpeed = 90.f;      // tuáº§n tra
    float _chaseSpeed = 140.f;    // Ä‘uá»•i
    float _aggroRange = 220.f;    // táº§m phÃ¡t hiá»‡n (theo X, kÃ¨m giá»›i háº¡n Y)
    bool  _aggroEnabled = true;

    // Stat
    int _hp = 2, _maxHp = 2;
    bool _dead = false;
};

File Entity.cpp
#include "game/Entity.h"
// Hiá»‡n giá» má»i thá»© Ä‘Ã£ lÃ m trong header (inline) Ä‘á»ƒ Ä‘Æ¡n giáº£n hoÃ¡.
// Náº¿u cáº§n má»Ÿ rá»™ng logic chung cho má»i Entity, thÃªm á»Ÿ Ä‘Ã¢y.

File Entity.h
// Classes/game/Entity.h
#pragma once
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"

// Alias toÃ n cá»¥c Ä‘á»ƒ code cÅ© dÃ¹ng Tag::XYZ váº«n há»£p lá»‡
using Tag = phys::Tag;

class Entity : public cocos2d::Node {
public:
    CREATE_FUNC(Entity);

    // Node::init() máº·c Ä‘á»‹nh
    bool init() override { return cocos2d::Node::init(); }

    // Tag gameplay má»Ÿ rá»™ng (khÃ´ng Ä‘á»¥ng tá»›i Node::setTag(int) cá»§a cocos2d)
    void setTagEx(Tag t)           { _gtag = t; }
    void setTagExInt(int t)        { _gtag = static_cast<Tag>(t); }  // back-compat
    void setTagEx(int t)           { _gtag = static_cast<Tag>(t); }  // back-compat: setTagEx(1)
    Tag  getTagEx() const          { return _gtag; }

protected:
    Tag _gtag = Tag::NONE;
};

File Player.cpp
// Classes/game/Player.cpp  â€” phiÃªn báº£n cÃ³ SFX báº¯n/chÃ©m + jump/land/hurt (fallback Ä‘uÃ´i)
#include "game/Player.h"

#include "2d/CCDrawNode.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"

#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"

#include "GameScene.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"

// Ã‚m thanh
#include "audio/Sound.h"                        // dÃ¹ng snd::sfxShoot(), snd::sfxSlash()
#include "audio/include/AudioEngine.h"          // fallback SFX cho jump/land/hurt
#include "platform/CCFileUtils.h"

#include <algorithm>
#include <cmath>
#include <string>

using namespace cocos2d;

// ==============================
// SFX helpers (fallback by stem)
// ==============================
namespace {
    using AE = cocos2d::AudioEngine;

    // Cho phÃ©p chá»‰ truyá»n "gá»‘c tÃªn" (stem), tá»± tÃ¬m .wav/.mp3/.ogg náº¿u tá»“n táº¡i
    inline std::string _pickAudio(const char* stem) {
        static const char* exts[] = { ".wav", ".mp3", ".ogg" };
        auto* fu = FileUtils::getInstance();
        for (auto* ext : exts) {
            std::string p = std::string(stem) + ext;
            if (fu->isFileExist(p)) return p;
        }
        CCLOG("SND missing: %s.(wav|mp3|ogg) not found", stem);
        return {};
    }

    inline void _sfxOptional(const char* stem, float vol = 0.9f) {
        if (!stem) return;
        std::string f = _pickAudio(stem);
        if (!f.empty()) AE::play2d(f, false, vol);
    }

    // TÃªn gá»‘c (stem) cho cÃ¡c SFX thÃªm má»›i:
    constexpr const char* SFX_JUMP = "audio/sfx_jump";
    constexpr const char* SFX_LAND = "audio/sfx_land";
    constexpr const char* SFX_HURT = "audio/sfx_hurt";
}

// ==============================

static inline float approach(float cur, float target, float delta) {
    if (cur < target) return std::min(target, cur + delta);
    if (cur > target) return std::max(target, cur - delta);
    return cur;
}

bool Player::init() {
    if (!Entity::init()) return false;
    CCLOG("Player::init");
    this->setName("player");


    _sprite = Sprite::create("sprites/player/idle/idle_1.png");
    _sprite->setAnchorPoint(Vec2(0.5f, 0.5f));
    _sprite->setPositionY(_colSize.height * 0.5f);
    _sprite->setScale(1.4f);
    addChild(_sprite, 1);

    scheduleUpdate();
    return true;
}

void Player::refreshVisual() {
    // (tÃ¹y chá»n) debug collider
}

void Player::enablePhysics(const Vec2& feetPos, const Size& bodySize) {
    if (bodySize.width > 0 && bodySize.height > 0) _colSize = bodySize;
    setPosition(feetPos);

    _body = buildOrUpdateBody(_colSize);
    applyPlayerMasks();

    _body->setEnabled(true);          // Ä‘Ãºng chÃ­nh táº£ cocos2d-x
    _body->setGravityEnable(true);
    _body->setDynamic(true);
    _body->setVelocity(Vec2::ZERO);
}

PhysicsBody* Player::buildOrUpdateBody(const Size& bodySize) {
    Size sz = bodySize;
    sz.width  = std::max(18.f, sz.width  * 0.90f);
    sz.height = std::max(30.f, sz.height * 1.5f);

    if (!_body) {
        _body = PhysicsBody::create();
        _body->setDynamic(true);
        _body->setRotationEnable(false);
        addComponent(_body);
    } else {
        auto shapes = _body->getShapes();
        for (auto s : shapes) _body->removeShape(s);
    }

    // main box (trá»ng tÃ¢m náº±m giá»¯a thÃ¢n)
    auto mainBox = PhysicsShapeBox::create(
        sz, PhysicsMaterial(0.1f, 0.0f, 0.5f),
        Vec2(0, +sz.height * 0.5f)
    );
    _body->addShape(mainBox);

    // chÃ¢n (sensor) â€” Ä‘á»ƒ Ä‘áº¿m tiáº¿p Ä‘áº¥t
    const float footH = std::max(4.0f, sz.height * 0.08f);
    const Size  footSize(sz.width * 0.60f, footH);
    const Vec2  footOffset(0, -footH * 0.5f);
    auto foot = PhysicsShapeBox::create(footSize, PhysicsMaterial(0,0,0), footOffset);
    foot->setSensor(true);
    foot->setTag((int)phys::ShapeTag::FOOT);
    _body->addShape(foot);

    _body->setMass(1.0f);
    _body->setLinearDamping(0.1f);
    return _body;
}

void Player::applyPlayerMasks() {
    if (!_body) return;

    // va cháº¡m cá»©ng
    const phys::Mask collide =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_SOLID |
        phys::CAT_GATE  | phys::CAT_CRATE;

    // contact (thÃªm ENEMY_PROJ Ä‘á»ƒ Äƒn Ä‘áº¡n Ä‘á»‹ch)
    const phys::Mask contact =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_ENEMY_PROJ |
        phys::CAT_ITEM  | phys::CAT_BULLET | phys::CAT_SENSOR;

    phys::setMasks(_body, phys::CAT_PLAYER, collide, contact);
}

void Player::setMoveDir(const Vec2& dir) {
    _moveDir = dir;
    if (_moveDir.x < 0) _facing = -1;
    else if (_moveDir.x > 0) _facing = +1;
}

void Player::jump() {
    if (!_body) return;
    const float m = _body->getMass();
    const float impulse = _jumpImpulse * m;

    if (_footContacts > 0) {
        _body->applyImpulse(Vec2(0, impulse));
        _sfxOptional(SFX_JUMP);       // ğŸ”Š nháº£y tá»« Ä‘áº¥t
        return;
    }
    if (_airJumpsMax > 0 && _airJumpsUsed < _airJumpsMax) {
        _airJumpsUsed++;
        _body->setVelocity(Vec2(_body->getVelocity().x, 0));
        _body->applyImpulse(Vec2(0, impulse * 0.92f));
        _sfxOptional(SFX_JUMP);       // ğŸ”Š nháº£y trÃªn khÃ´ng
    }
}

void Player::incFoot(int delta) {
    const int prev = _footContacts;
    _footContacts = std::max(0, _footContacts + delta);
    if (prev==0 && _footContacts>0) {
        _airJumpsUsed = 0;            // cháº¡m Ä‘áº¥t -> reset
        _sfxOptional(SFX_LAND);       // ğŸ”Š cháº¡m Ä‘áº¥t
    }
}

void Player::heal(int v) { _hp = std::min(_maxHp, _hp + std::max(0, v)); }
void Player::restoreFullHP() { _hp = _maxHp; }

void Player::hurt(int dmg) {
    if (invincible() || !_body) return;
    _hp = std::max(0, _hp - std::max(1, dmg));
    _invincibleT = 0.8f;
    _sfxOptional(SFX_HURT);           // ğŸ”Š bá»‹ thÆ°Æ¡ng

    const float dir = (_facing > 0 ? -1.f : +1.f);
    _body->applyImpulse(Vec2(200.f * dir, 260.f));
}

void Player::doShoot(){
    if (_shooting) return;
    _shooting = true;

    int dir = facing();
    runAction(Sequence::create(
        DelayTime::create(0.35f),
        CallFunc::create([this, dir]() {
            int count = 1 + std::max(0, _extraBullets);
            float spread = 0.08f;
            for (int i=0;i<count;i++){
                float offY = (i - (count-1)*0.5f) * 8.0f;
                Vec2 origin = getPosition() + Vec2(dir * 18.f, halfH() * 0.25f + offY);
                Vec2 vel(700.f * dir, (i - (count-1)*0.5f) * 120.f * spread);
                auto b = Bullet::create(origin, vel, 1.5f);
                if (getParent() && b) getParent()->addChild(b, 6);
            }
            snd::sfxShoot();          // ğŸ”Š báº¯n
        }),
        DelayTime::create(0.36f),
        CallFunc::create([this]() { _shooting = false; }),
        nullptr
    ));
}

void Player::doSlash(){
    if (_attacking) return;
    _attacking = true;
    const int dir = facing();

    runAction(Sequence::create(
        DelayTime::create(0.20f),
        CallFunc::create([this, dir]() {
            Vec2 origin = getPosition() + Vec2(dir*28.f, halfH()*0.1f);
            float angle = (dir > 0) ? 0.0f : 3.14159265f;
            auto s = Slash::create(origin, angle, _slashRange, 0.12f);
            if (auto p=getParent()) p->addChild(s, 6);
            snd::sfxSlash();          // ğŸ”Š chÃ©m
        }),
        DelayTime::create(0.30f),
        CallFunc::create([this]{ _attacking = false; }),
        nullptr));
}

void Player::applyUpgrade(int type, float duration){
    float factor = 1.f;
    switch(type){
        case 0: factor = 1.25f; _moveSpeed   *= factor; break; // SPEED
        case 1: factor = 1.15f; _jumpImpulse *= factor; break; // JUMP
        case 2: _atkBonus += 1; break;                           // DAMAGE (+1)
        case 3: _extraBullets += 1; break;                       // BULLET
        case 4: /* RANGE tÄƒng táº§m, xá»­ lÃ½ trong Slash.create báº±ng _slashRange */ break;
        case 5: _airJumpsMax = std::max(_airJumpsMax, 1); break; // DOUBLEJUMP
        default: break;
    }
    _buffs.push_back({type, std::max(0.1f, duration), factor, -1});
}

cocos2d::Vector<cocos2d::SpriteFrame*> Player::buildFrames(const std::string& animName, int frameCount) {
    Vector<SpriteFrame*> frames;
    for (int i = 1; i <= frameCount; ++i) {
        std::string path = StringUtils::format("sprites/player/%s/%s_%d.png", animName.c_str(), animName.c_str(), i);
        auto tex = Director::getInstance()->getTextureCache()->addImage(path);
        if (!tex) break;
        Rect rect(0, 0, tex->getPixelsWide(), tex->getPixelsHigh());
        frames.pushBack(SpriteFrame::create(path, rect));
    }
    return frames;
}

void Player::playAnim(const std::string& animName, float delay, int frameCount) {
    if (_currentAnim == animName) return;
    auto frames = buildFrames(animName, frameCount);
    if (frames.empty()) return;

    _currentAnim = animName;
    auto animation = Animation::createWithSpriteFrames(frames, delay);
    auto act = RepeatForever::create(Animate::create(animation));
    if (_sprite) { _sprite->stopAllActions(); _sprite->runAction(act); }
}

void Player::update(float dt) {
    if (!_body) return;

    // invuln blink
    if (_invincibleT > 0.f) {
        _invincibleT -= dt;
        const bool blink = ((int)std::floor(_invincibleT * 20.f)) % 2 == 0;
        if (_sprite) _sprite->setOpacity(blink ? 140 : 255);
    } else if (_sprite) {
        _sprite->setOpacity(255);
    }

    const bool grounded = (_footContacts > 0);
    const float targetVx = _moveDir.x * _moveSpeed;

    Vec2 v = _body->getVelocity();
    const float accel = grounded ? _accelGround : _accelAir;

    if (grounded && std::abs(_moveDir.x) < 1e-3f) v.x = approach(v.x, 0.f, accel * dt);
    else v.x = approach(v.x, targetVx, accel * dt);

    v.y = std::max(v.y, -_maxFall);
    _body->setVelocity(v);

    // chá»n anim
    if (isDead()) nextAnim = "die";
    else if (_attacking) nextAnim = "attack";
    else if (_shooting)  nextAnim = "shoot";
    else if (!grounded)  nextAnim = "jump";
    else if (std::abs(_moveDir.x) > 1e-3f) nextAnim = "run";
    else nextAnim = "idle";

    if (_currentAnim != nextAnim){
        if (nextAnim == "die")         playAnim("die",    0.12f, 6);
        else if (nextAnim == "jump")   playAnim("jump",   0.23f, 4);
        else if (nextAnim == "run")    playAnim("run",    0.06f, 8);
        else if (nextAnim == "attack") playAnim("attack", 0.06f, 6);
        else if (nextAnim == "shoot")  playAnim("shoot",  0.08f, 6);
        else                           playAnim("idle",   0.12f, 8);
    }

    // láº­t sprite váº«n giá»¯ scale gá»‘c
    if (_sprite) {
        float sx = std::fabs(_sprite->getScaleX());
        if (sx < 0.01f) sx = 1.4f; // náº¿u trÆ°á»›c Ä‘Ã³ bá»‹ set vá» 0/1, láº¥y láº¡i máº·c Ä‘á»‹nh
        _sprite->setScaleX(_facing * sx);
    }

    // Ä‘áº¿m buff & revert
    for (int i=(int)_buffs.size()-1; i>=0; --i){
        _buffs[i].remain -= dt;
        if (_buffs[i].remain <= 0.f){
            int type = _buffs[i].type; float factor = _buffs[i].factor;
            switch(type){
                case 0: _moveSpeed   /= factor; break;
                case 1: _jumpImpulse /= factor; break;
                case 2: _atkBonus    = std::max(0, _atkBonus-1); break;
                case 3: _extraBullets= std::max(0, _extraBullets-1); break;
                case 5: _airJumpsMax = 0; _airJumpsUsed = 0; break;
                default: break;
            }
            _buffs.erase(_buffs.begin()+i);
        }
    }
}

File Player.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"
#include <vector>
#include <string>

class Player : public Entity {
public:
    CREATE_FUNC(Player);
    bool init() override;

    // Váº­t lÃ½
    void enablePhysics(const cocos2d::Vec2& feetPos,
                       const cocos2d::Size& bodySize = cocos2d::Size::ZERO);

    // Äiá»u khiá»ƒn
    void setMoveDir(const cocos2d::Vec2& dir);
    void jump();
    void doShoot();
    void doSlash();

    // Tráº¡ng thÃ¡i gameplay
    void incFoot(int delta);
    void hurt(int dmg);
    bool invincible() const { return _invincibleT > 0.f; }

    // HP
    int  hp() const { return _hp; }
    int  maxHp() const { return _maxHp; }
    void heal(int v);
    void restoreFullHP();
    bool isDead() const { return _hp <= 0; }

    // Trá»£ giÃºp
    int   facing() const { return _facing; } // -1 / +1
    float halfH() const { return _colSize.height * 0.5f; }
    cocos2d::Size colliderSize() const { return _colSize; }

    // Buff/Upgrade
    void applyUpgrade(int type, float durationSec); // map tá»« Upgrade::Type
    int  atkBonus() const { return _atkBonus; }

    // Debug/anim state
    std::string nextAnim;

    // (giá»¯ public cho tÆ°Æ¡ng thÃ­ch code cÅ©)
    bool _attacking = false;
    bool _shooting  = false;

protected:
    void update(float dt) override;

private:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& bodySize);
    void applyPlayerMasks();
    void refreshVisual();

    // Animation helpers (Ä‘á»ƒ Player.cpp gá»i)
    void playAnim(const std::string& name, float delay, int frames);
    cocos2d::Vector<cocos2d::SpriteFrame*> buildFrames(const std::string& animName, int frameCount);

private:
    // Visual
    cocos2d::Sprite* _sprite = nullptr;
    std::string _currentAnim;

    // Body/collider
    cocos2d::PhysicsBody* _body = nullptr;
    cocos2d::Size _colSize{28.f, 44.f};
    cocos2d::Vec2 _moveDir{0,0};
    int _facing = +1;
    int _footContacts = 0;

    // Di chuyá»ƒn
    float _moveSpeed   = 180.f;
    float _accelGround = 1200.f;
    float _accelAir    = 650.f;
    float _jumpImpulse = 550.f;
    // float _jumpImpulse = 600.f;
    float _maxFall     = 1200.f;

    // HP/invuln
    int _hp = 100;
    int _maxHp = 100;
    float _invincibleT = 0.f;

    // Buff core (chá»‰ khai 1 láº§n, khÃ´ng trÃ¹ng!)
    int   _extraBullets = 0;   // báº¯n thÃªm N viÃªn
    float _slashRange   = 60.f;
    float _dmgScale     = 1.0f; // náº¿u muá»‘n dÃ¹ng dáº¡ng nhÃ¢n
    int   _atkBonus     = 0;    // Ä‘ang dÃ¹ng cá»™ng tháº³ng

    // Double jump
    int _airJumpsMax  = 0;
    int _airJumpsUsed = 0;

    // Buff runtime (Ä‘áº¿m ngÆ°á»£c & revert)
    struct ActiveBuff { int type; float remain; float factor; int hudId; };
    std::vector<ActiveBuff> _buffs;
};


Folder Classes/game/bosses
File BossGolem.cpp
#include "game/bosses/BossGolem.h"
#include "game/Player.h"                  // dÃ¹ng Player* cho target
#include "game/objects/Star.h"            // rÆ¡i Star khi cháº¿t

#include "physics/PhysicsDefs.h"
#include "2d/CCDrawNode.h"
#include "physics/CCPhysicsBody.h"
#include "2d/CCActionInstant.h"
#include "base/CCDirector.h"
#include "physics/CCPhysicsBody.h"
#include "game/Player.h"
#include "physics/CCPhysicsShape.h"
#include "base/ccRandom.h"

#include <vector>
#include <algorithm>
#include <cmath>

using namespace cocos2d;

BossGolem* BossGolem::create() {
    auto p = new (std::nothrow) BossGolem();
    if (p && p->init()) { p->autorelease(); return p; }
    CC_SAFE_DELETE(p); return nullptr;
}

bool BossGolem::init() {
    if (!Enemy::init()) return false;

    setMaxHp(36);
    setMoveSpeed(70.f);
    _cd = 1.0f;

    if (_sprite) {
        _sprite->removeFromParent();
        _sprite = nullptr; // Reset con trá»
    }

        _sprite = Sprite::create("sprites/boss/idle/idle_1.png");
        _sprite->setAnchorPoint(Vec2(0.5f, 0.5f)); // chÃ¢n á»Ÿ dÆ°á»›i
        _sprite->setPosition(Vec2(0.f, 150.f));
        _sprite->setScale(2.5f);
        addChild(_sprite, 1);

    auto size = _sprite->getContentSize() * _sprite->getScale();
    _body = PhysicsBody::createBox(size);
    setPhysicsBody(_body);

    // scheduleUpdate();
    // schedule([this](float){ updateEnemy(0); }, "enemy.tick");
    schedule([this](float dt){ this->_tickBoss(dt); }, "boss.ai");


    return true;
}



void BossGolem::takeHit(int dmg){
    if (_dead || _dying) return;

    const int hit = std::max(1, dmg);
    const int finalHp = _hp - hit;

    // hiá»‡u á»©ng trÃºng Ä‘Ã²n
    if (_sprite) {
        _sprite->runAction(Sequence::create(
            TintTo::create(0.0f, 255,150,150),
            DelayTime::create(0.06f),
            TintTo::create(0.0f, 120,170,255),
            nullptr
        ));
    }

    // chÆ°a cháº¿t -> dÃ¹ng logic Enemy thÆ°á»ng (giáº£m mÃ¡u + cáº­p nháº­t thanh HP)
    if (finalHp > 0) { Enemy::takeHit(dmg); return; }

    // ====== cháº¿t: KHÃ”NG gá»i Enemy::takeHit Ä‘á»ƒ nÃ© LootTable (coin/upgrade) ======
    _hp = 0;
    _dead  = true;
    _dying = true;

    // táº¯t AI vÃ  "Ä‘Ã³ng bÄƒng" body (khÃ´ng thÃ¡o shape ngay trong step hiá»‡n táº¡i)
    unschedule("boss.ai");
    if (_body) {
        _body->setVelocity(Vec2::ZERO);
        _body->setContactTestBitmask(0);
        _body->setCollisionBitmask((int)phys::CAT_WORLD); // váº«n Ä‘á»©ng yÃªn náº¿u cÃ²n tháº¥y
        _body->setEnabled(false);                         // tÃ¡ch khá»i physics world
    }

    // HoÃ£n 1 nhá»‹p ngáº¯n Ä‘á»ƒ thoÃ¡t contact, rá»“i spawn Star + xÃ³a boss
    this->runAction(Sequence::create(
        FadeOut::create(0.05f),
        DelayTime::create(0.02f),                 // QUAN TRá»ŒNG: hoÃ£n 1 frame
        CallFunc::create([this](){
            if (auto parent = getParent()) {
                auto star = Star::create();
                if (star) {
                    star->setPosition(getPosition() + Vec2(0, 24.f));
                    parent->addChild(star, 7);
                }
            }
            removeFromParent();
        }),
        nullptr
    ));
}

// =====================
// Helpers ná»™i bá»™
// =====================
namespace {
    // projectile mask cho Äáº N Äá»ŠCH (Ä‘Ã£ Ä‘á»‹nh nghÄ©a CAT_ENEMY_PROJ trong PhysicsDefs)
    inline void setEnemyProjMasks(cocos2d::PhysicsBody* b) {
        b->setCategoryBitmask((int)phys::CAT_ENEMY_PROJ);
        b->setCollisionBitmask((int)(phys::CAT_WORLD | phys::CAT_PLAYER));
        b->setContactTestBitmask((int)(phys::CAT_PLAYER | phys::CAT_BULLET | phys::CAT_SENSOR));
    }

    // AOE vÃ²ng trÃ²n sensor, tá»± huá»· nhanh
    Node* makeAoeRing(const Vec2& center, float radius, float lifeSec = 0.25f) {
        auto n = Node::create(); n->setPosition(center);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawCircle(Vec2::ZERO, radius, 0, 28, false, 1.8f, 1.8f, Color4F(1.f,0.8f,0.4f,0.7f));
        dn->drawSolidCircle(Vec2::ZERO, radius*0.85f, 0, 24, Color4F(1,0.8f,0.4f,0.10f));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(radius, PhysicsMaterial(0,0,0));
        body->setDynamic(false);
        for (auto s : body->getShapes()) s->setSensor(true);
        setEnemyProjMasks(body);
        n->addComponent(body);

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }

    // Äáº¡n thÆ°á»ng: bay tháº³ng
    Node* makeBullet(const Vec2& origin, const Vec2& velocity, float lifeSec = 1.8f) {
        auto n = Node::create(); n->setPosition(origin);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawSolidCircle(Vec2::ZERO, 6.f, 0, 18, Color4F(0.95f,0.4f,0.2f,1));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(6.f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);
        setEnemyProjMasks(body);
        n->addComponent(body);
        body->setVelocity(velocity);
        body->setLinearDamping(0.02f);

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }

    // Äáº¡n homing: báº» lÃ¡i dáº§n
    Node* makeHoming(const Vec2& origin, Node* target,
                     float speed = 240.f, float turnRate = 6.0f, float lifeSec = 2.2f) {
        auto n = Node::create(); n->setPosition(origin);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawSolidCircle(Vec2::ZERO, 5.f, 0, 18, Color4F(0.9f,0.9f,1.f,1));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(5.f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);
        setEnemyProjMasks(body);
        n->addComponent(body);

        n->schedule([n, target, speed, turnRate](float dt){
            auto b = n->getPhysicsBody(); 
            if (!b || !target) return;
            if (!target->getParent()) return;
            Vec2 from = n->getPosition(), to = target->getPosition();
            Vec2 dir  = (to - from).getNormalized();
            Vec2 desired = dir * speed;
            Vec2 v = b->getVelocity();
            float alpha = cocos2d::clampf(turnRate * dt, 0.f, 1.f);
            v = v * (1.f - alpha) + desired * alpha;
            if (v.lengthSquared() < speed*speed*0.25f) v = desired;
            b->setVelocity(v);
        }, "enemy.homing");

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }
} // namespace (helpers)

// =====================
// AI patterns
// =====================
void BossGolem::_tickBoss(float dt){
    if (_dead || !_body) return;

    // KHÃ“A HOÃ€N TOÃ€N khi chÆ°a aggro (báº­t á»Ÿ mini cuá»‘i trong GameScene)
    if (!_aggroEnabled) {
        Vec2 v = _body->getVelocity();
        v.x = 0.f;
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        return;
    }

    Player* p = (_target ? dynamic_cast<Player*>(_target) : nullptr);
    if (!p) return;

    Vec2 bp = getPosition();
    Vec2 pp = p->getPosition();
    float dist = bp.distance(pp);
    float dx   = pp.x - bp.x;

    const float AGGRO = 520.f;
    if (dist > AGGRO) {
        // di chuyá»ƒn nháº¹ khi chÆ°a vÃ o táº§m
        Vec2 v = _body->getVelocity();
        v.x = (dx > 0 ? +1 : -1) * std::min(_moveSpeed * 0.6f, 80.f);
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        playAnim("walk", 0.18f, 12, "boss");

        _cd -= dt * 0.5f;
        return;
    }

    _cd -= dt;
    if (_cd > 0.f) {
        Vec2 v = _body->getVelocity();
        v.x *= 0.9f;
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        playAnim("walk", 0.18f, 12, "boss");
        if (_sprite) _sprite->setFlippedX(_dir > 0);


        return;
    }

    // Æ¯u tiÃªn Radial; mÃ¡u tháº¥p thÃ¬ hung hÄƒng hÆ¡n
    int r = (_hp <= _maxHp/2) ? RandomHelper::random_int(0, 3)
                              : RandomHelper::random_int(0, 2);
    if (r <= 1) _radialBurst(pp);
    else        _blinkStrike(pp);

    _cd = 1.5f + RandomHelper::random_real(0.2f, 0.9f);
}

void BossGolem::_blinkStrike(const Vec2& playerPos){
    auto parent = getParent(); if (!parent) return;
    Vec2 bp = getPosition();
    int dir = (playerPos.x >= bp.x) ? +1 : -1;

    if (_sprite) _sprite->runAction(TintTo::create(0.0f, 200,240,255));
    runAction(Sequence::create(
        CallFunc::create([=](){ // Báº®T Äáº¦U hoáº¡t áº£nh ATTACK
            playAnim("attack", 0.18f, 15, "boss");
            if (_sprite) _sprite->setFlippedX(dir < 0); // Äá»•i hÆ°á»›ng á»Ÿ Ä‘Ã¢y (hoáº·c trÆ°á»›c Ä‘Ã³)
        }),
        DelayTime::create(0.12f), // telegraph ngáº¯n
        CallFunc::create([=](){
            // ... (pháº§n code dá»‹ch chuyá»ƒn, AOE) ...
            setPosition(bp + Vec2(dir * 180.f, 0));
            auto aoe = makeAoeRing(getPosition(), 90.f, 0.24f);
            if (aoe) parent->addChild(aoe, 7);
            if (_sprite) _sprite->runAction(TintTo::create(0.0f, 120,170,255));
            // KhÃ´ng cáº§n setFlippedX á»Ÿ Ä‘Ã¢y ná»¯a náº¿u Ä‘Ã£ set á»Ÿ trÃªn
        }),
        DelayTime::create(0.18f * 15), // Chá» hoáº¡t áº£nh Attack káº¿t thÃºc (vÃ­ dá»¥ 15 frame * 0.18s)
        CallFunc::create([=](){
            // Chuyá»ƒn vá» idle/walk náº¿u cáº§n
            // playAnim("walk", 0.18f, 12, "boss");
        }),
        nullptr
    ));
}

void BossGolem::_radialBurst(const Vec2& /*playerPos*/){
    auto parent = getParent(); if (!parent) return;

    const int N = RandomHelper::random_int(12, 16);
    const int K = RandomHelper::random_int(2, 4); // sá»‘ viÃªn homing
    const float S = 260.f;

    std::vector<int> homingIdx; homingIdx.reserve(K);
    for (int i=0; i<K; ++i) homingIdx.push_back(RandomHelper::random_int(0, N-1));

    float ang0 = RandomHelper::random_real(0.f, 3.1415926f);
    for (int i=0; i<N; ++i){
        float a = ang0 + i * (2*3.1415926f / N);
        Vec2 dir(std::cos(a), std::sin(a));
        bool isHoming = (std::find(homingIdx.begin(), homingIdx.end(), i) != homingIdx.end());

        Node* b = isHoming ? makeHoming(getPosition(), _target, 240.f, 6.0f, 2.2f)
                           : makeBullet(getPosition(), dir * S, 1.8f);
        if (b) parent->addChild(b, 6);
    }

    if (_sprite) _sprite->runAction(Sequence::create(
        TintTo::create(0.0f, 255,230,140),
        DelayTime::create(0.18f),
        TintTo::create(0.0f, 120,170,255),
        nullptr
    ));
}

File BossGolem.h
#pragma once
#include "game/Enemy.h"
class Player;

class BossGolem : public Enemy {
public:
    static BossGolem* create();
    bool init() override;

    // Ghi Ä‘Ã¨ Ä‘á»ƒ xá»­ lÃ½ cháº¿t an toÃ n + rÆ¡i Star (khÃ´ng dÃ¹ng LootTable)
    void takeHit(int dmg) override;

private:
    void _tickBoss(float dt);
    void _blinkStrike(const cocos2d::Vec2& playerPos); // dá»‹ch chuyá»ƒn + AOE
    void _radialBurst(const cocos2d::Vec2& playerPos); // vÃ²ng Ä‘áº¡n + vÃ i viÃªn homing

    float _cd = 1.0f;   // cooldown ná»™i bá»™ luÃ¢n phiÃªn pattern
    bool  _dying = false; // trÃ¡nh gá»i cháº¿t nhiá»u láº§n trong cÃ¹ng 1 frame
};


Folder Classes/game/enemies
File Goomba.cpp
// Goomba.cpp
#include "game/enemies/Goomba.h"
#include "game/Player.h"

USING_NS_CC;
Goomba* Goomba::create(){ auto p=new(std::nothrow) Goomba(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Goomba::init(){
    if(!Enemy::init()) return false;
    
    // Táº O SPRITE CHO RIÃŠNG GOOMBA
    _sprite = Sprite::create("sprites/skeleton1/idle/idle_1.png");
     _sprite->setScale(1.5f); // tÃ¹y chá»‰nh kÃ­ch cá»¡ hiá»ƒn thá»‹
    _sprite->setPosition(Vec2(0.f, 0.5f));
    addChild(_sprite, 1);
    return true;
}

void Goomba::updateEnemy(float dt) {
    if (!_body) return;

    Vec2 v = _body->getVelocity();
    bool chasing = false;

    // --- Logic Ä‘uá»•i (Chasing) ---
    // Äuá»•i khi báº­t aggro + trong táº§m (giá»›i háº¡n lá»‡ch Y Ä‘á»ƒ khÃ´ng â€œhÃºt xuyÃªn táº§ngâ€)
    if (_aggroEnabled && _target) {
        float dx = _target->getPositionX() - getPositionX();
        float dy = _target->getPositionY() - getPositionY();
        if (std::abs(dx) <= _aggroRange && std::abs(dy) <= 160.f) {
            _dir = (dx >= 0 ? +1 : -1);
            v.x = _dir * _chaseSpeed;
            chasing = true;
        }
    }

    // --- Logic tuáº§n tra (Patrolling) ---
    // KhÃ´ng Ä‘uá»•i -> tuáº§n tra giá»¯a 2 má»‘c
    if (!chasing && _pA != _pB) {
        float x = getPositionX();
        if (_dir > 0 && x >= _pB.x) _dir = -1;
        else if (_dir < 0 && x <= _pA.x) _dir = +1;
        v.x = _dir * _moveSpeed;
    }

    // Giá»›i háº¡n tá»‘c Ä‘á»™ rÆ¡i
    v.y = std::max(v.y, -900.0f);
    _body->setVelocity(v);

    // --- Logic Animation & Sprite Flip ---
    // Kiá»ƒm tra xem enemy cÃ³ Ä‘ang di chuyá»ƒn (v.x != 0) khÃ´ng
    bool isMoving = (v.x != 0); // Enemy di chuyá»ƒn khi chasing HOáº¶C patrolling

    if (isMoving) {
        // play walk animation khi Ä‘ang di chuyá»ƒn (chasing hoáº·c patrolling)
        playAnim("walk", 0.12f, 9, "skeleton1");
    } else {
        // Ä‘á»©ng yÃªn (chasing false VÃ€ _pA == _pB) â†’ idle
        playAnim("idle", 0.18f, 9, "skeleton1");
    }

    // Flip sprite theo hÆ°á»›ng di chuyá»ƒn (trá»« khi _dir chÆ°a Ä‘Æ°á»£c set, nhÆ°ng trong code nÃ y _dir luÃ´n lÃ  +1/-1 khi di chuyá»ƒn)
    if (_sprite) _sprite->setFlippedX(_dir > 0);
}

File Goomba.h
// Goomba.h
#pragma once
#include "game/Enemy.h"
class Goomba : public Enemy {
public:
    static Goomba* create();
    bool init() override;
    void updateEnemy(float dt) override;

};

File Spiker.cpp
// Spiker.cpp
#include "game/enemies/Spiker.h"
#include "game/Player.h"

USING_NS_CC;
Spiker* Spiker::create(){ auto p=new(std::nothrow) Spiker(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Spiker::init(){
    if(!Enemy::init()) return false;
    
    // Táº O SPRITE CHO RIÃŠNG SPIKER
    _sprite = Sprite::create("sprites/fireworm/idle/idle_1.png"); // Thay báº±ng Ä‘Æ°á»ng dáº«n Sprite cá»§a Spiker
     _sprite->setScale(1.4f); // tÃ¹y chá»‰nh kÃ­ch cá»¡ hiá»ƒn thá»‹
    addChild(_sprite, 1);
    
    // Táº¡o PhysicsBody vÃ  cÃ¡c logic váº­t lÃ½ (náº¿u cáº§n)

    setColor(Color3B(180,200,255)); // Giá»¯ láº¡i logic Ä‘á»•i mÃ u
    return true;
}


void Spiker::updateEnemy(float dt) {
    if (!_body) return;

    Vec2 v = _body->getVelocity();
    bool chasing = false;

    // --- Logic Ä‘uá»•i (Chasing) ---
    // Äuá»•i khi báº­t aggro + trong táº§m (giá»›i háº¡n lá»‡ch Y Ä‘á»ƒ khÃ´ng â€œhÃºt xuyÃªn táº§ngâ€)
    if (_aggroEnabled && _target) {
        float dx = _target->getPositionX() - getPositionX();
        float dy = _target->getPositionY() - getPositionY();
        if (std::abs(dx) <= _aggroRange && std::abs(dy) <= 160.f) {
            _dir = (dx >= 0 ? +1 : -1);
            v.x = _dir * _chaseSpeed;
            chasing = true;
        }
    }

    // --- Logic tuáº§n tra (Patrolling) ---
    // KhÃ´ng Ä‘uá»•i -> tuáº§n tra giá»¯a 2 má»‘c
    if (!chasing && _pA != _pB) {
        float x = getPositionX();
        if (_dir > 0 && x >= _pB.x) _dir = -1;
        else if (_dir < 0 && x <= _pA.x) _dir = +1;
        v.x = _dir * _moveSpeed;
    }

    // Giá»›i háº¡n tá»‘c Ä‘á»™ rÆ¡i
    v.y = std::max(v.y, -900.0f);
    _body->setVelocity(v);

    // --- Logic Animation & Sprite Flip ---
    // Kiá»ƒm tra xem enemy cÃ³ Ä‘ang di chuyá»ƒn (v.x != 0) khÃ´ng
    bool isMoving = (v.x != 0); // Enemy di chuyá»ƒn khi chasing HOáº¶C patrolling

    if (isMoving) {
        // play walk animation khi Ä‘ang di chuyá»ƒn (chasing hoáº·c patrolling)
        playAnim("walk", 0.12f, 9, "fireworm");
    } else {
        // Ä‘á»©ng yÃªn (chasing false VÃ€ _pA == _pB) â†’ idle
        playAnim("idle", 0.18f, 9, "fireworm");
    }

    // Flip sprite theo hÆ°á»›ng di chuyá»ƒn (trá»« khi _dir chÆ°a Ä‘Æ°á»£c set, nhÆ°ng trong code nÃ y _dir luÃ´n lÃ  +1/-1 khi di chuyá»ƒn)
    if (_sprite) _sprite->setFlippedX(_dir < 0);
}

File Spiker.h
// Spiker.h
#pragma once
#include "game/Enemy.h"
class Spiker : public Enemy {
public:
    static Spiker* create();
    bool init() override;
    void updateEnemy(float dt) override;
};


Folder Classes/game/loot
File LootTable.cpp
#include "game/loot/LootTable.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "physics/CCPhysicsBody.h"
#include "physics/PhysicsDefs.h"   // <-- thÃªm dÃ²ng nÃ y


using namespace cocos2d;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

const std::vector<DropSpec>& LootTable::defaultEnemyTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    60.f, 1, 3 },
        { DropKind::UPGRADE, 25.f, 1, 1 },
        { DropKind::STAR,     5.f, 1, 1 },
        { DropKind::NONE,    10.f, 0, 0 }
    };
    return T;
}
const std::vector<DropSpec>& LootTable::defaultChestTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    40.f, 3, 6 },
        { DropKind::UPGRADE, 45.f, 1, 2 },
        { DropKind::STAR,    10.f, 1, 1 },
        { DropKind::NONE,     5.f, 0, 0 }
    };
    return T;
}

DropKind LootTable::rollOne(const std::vector<DropSpec>& table, int& outCount){
    float sumW = 0.f;
    for (auto& e : table) sumW += e.weight;
    float r = frand(0.f, sumW), acc = 0.f;
    for (auto& e : table){
        acc += e.weight;
        if (r <= acc){
            outCount = (e.maxCount>=e.minCount)? irand(e.minCount, e.maxCount) : e.minCount;
            return e.kind;
        }
    }
    outCount = 0; return DropKind::NONE;
}

static void asSensorItem(Node* n){
    if (!n) return;
    auto* b = n->getPhysicsBody();
    if (!b){
        const float r = std::max(n->getContentSize().width, n->getContentSize().height) * 0.4f;
        b = PhysicsBody::createCircle(r, PhysicsMaterial(0,0,0));
        b->setDynamic(false);
        n->setPhysicsBody(b);
    }
    b->setGravityEnable(false);

    // mask ITEM sensor chuáº©n theo PhysicsDefs
    b->setCategoryBitmask((int)phys::CAT_ITEM);
    b->setCollisionBitmask(0);                 // sensor-only
    b->setContactTestBitmask((int)phys::CAT_ALL);
    for (auto s : b->getShapes()) s->setSensor(true);
}


void LootTable::spawn(Node* root, const Vec2& p, DropKind k, int count){
    if (!root || k==DropKind::NONE || count<=0) return;
    const float spread = 28.f;

    for (int i=0;i<count;++i){
        Node* item=nullptr;
        switch (k){
            case DropKind::COIN:    item = Coin::create();    break;
            case DropKind::UPGRADE: item = Upgrade::create(); break;
            case DropKind::STAR:    item = Star::create();    break;
            default: break;
        }
        if (!item) continue;
        item->setPosition(p);
        root->addChild(item, 6);

        // sensor & hiá»‡u á»©ng "báº­t" nháº¹
        asSensorItem(item);
        Vec2 dir = Vec2(frand(-1.f,1.f), 1.f).getNormalized();
        float dist = frand(spread*0.4f, spread);
        item->runAction(Sequence::create(
            MoveBy::create(0.25f, dir * dist),
            nullptr
        ));
    }
}

void LootTable::rollAndSpawn(Node* root, const Vec2& p, const std::vector<DropSpec>& table){
    int cnt=0; DropKind k = rollOne(table, cnt);
    spawn(root, p, k, cnt);
}

void LootTable::dropAt(Node* root, const Vec2& p, int count) {
    if (!root) return;
    count = std::max(1, count);
    for (int i = 0; i < count; ++i) {
        rollAndSpawn(root, p, defaultEnemyTable());
    }
}

File LootTable.h
#pragma once
#include <vector>
#include "cocos2d.h"

enum class DropKind { NONE, COIN, UPGRADE, STAR };

struct DropSpec {
    DropKind kind;
    float    weight;    // trá»ng sá»‘ bá»‘c thÄƒm
    int      minCount;
    int      maxCount;
};

class LootTable {
public:
    static const std::vector<DropSpec>& defaultEnemyTable();
    static const std::vector<DropSpec>& defaultChestTable();

    // Roll & spawn táº¡i vá»‹ trÃ­ p (CENTER cá»§a Ä‘á»‘i tÆ°á»£ng cháº¿t/vá»¡)
    static void rollAndSpawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                             const std::vector<DropSpec>& table = defaultEnemyTable());

    // Giá»¯ tÆ°Æ¡ng thÃ­ch code cÅ©: Enemy.cpp cÃ³ thá»ƒ gá»i dropAt(...)
    static void dropAt(cocos2d::Node* root, const cocos2d::Vec2& p, int count = 1);

private:
    static DropKind rollOne(const std::vector<DropSpec>& table, int& outCount);
    static void     spawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                          DropKind k, int count);
};


Folder Classes/game/map
File LevelBuilder.cpp
// Classes/game/map/LevelBuilder.cpp
#include "game/map/LevelBuilder.h"
#include "physics/PhysicsDefs.h"

#include "game/Enemy.h"
#include "game/enemies/Goomba.h"
#include "game/enemies/Spiker.h"
#include "game/bosses/BossGolem.h"

#include "game/objects/Coin.h"
#include "game/objects/Chest.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Star.h"
#include "2d/CCDrawNode.h"
#include "game/enemies/Goomba.h"
#include "game/enemies/Spiker.h"
#include "2d/CCParallaxNode.h"


USING_NS_CC;
namespace levels {

// ===== tuning =====
static const int   HP_BY_SEG[5]   = {3, 4, 5, 7, 36}; // boss á»Ÿ seg5 dÃ¹ng trong BossGolem
static const float SPD_BY_SEG[5]  = {70.f, 85.f, 95.f, 110.f, 0.f};
static const Upgrade::Type UPG_BY_SEG[5] = {
    Upgrade::Type::SPEED,
    Upgrade::Type::JUMP,
    Upgrade::Type::DAMAGE,
    Upgrade::Type::BULLET,
    Upgrade::Type::DOUBLEJUMP
};



static Node* makeSolid(Node* root, const Rect& r, const Color4F& col, const std::string& texturePath = "", const Vec2& startOffset = Vec2::ZERO) {
    Node* visualNode = nullptr;

    if (!texturePath.empty()) {
        // Náº¿u cÃ³ Ä‘Æ°á»ng dáº«n texture, táº¡o Sprite vÃ  láº·p láº¡i náº¿u cáº§n
        // Giáº£ sá»­ báº¡n cÃ³ má»™t sprite cÃ³ kÃ­ch thÆ°á»›c 32x32 cho má»—i tile
        const float TILE_SIZE = 32.0f; // KÃ­ch thÆ°á»›c cá»§a 1 tile trong PNG
        
        // Táº¡o má»™t Node chá»©a nhiá»u Sprite con Ä‘á»ƒ táº¡o hiá»‡u á»©ng láº·p láº¡i
        visualNode = Node::create();
        visualNode->setPosition(r.origin); // Äáº·t vá»‹ trÃ­ gá»‘c cá»§a node nÃ y táº¡i gÃ³c dÆ°á»›i trÃ¡i cá»§a Rect

        // TÃ­nh sá»‘ lÆ°á»£ng tile cáº§n thiáº¿t theo chiá»u rá»™ng vÃ  cao
        int numTilesX = std::ceil(r.size.width / TILE_SIZE);
        int numTilesY = std::ceil(r.size.height / TILE_SIZE);

        for (int y = 0; y < numTilesY; ++y) {
            for (int x = 0; x < numTilesX; ++x) {
                auto tileSprite = Sprite::create(texturePath);
                if (tileSprite) {
                    tileSprite->setAnchorPoint(Vec2(0, 0)); // Quan trá»ng: Äáº·t anchor á»Ÿ gÃ³c dÆ°á»›i trÃ¡i
                    tileSprite->setPosition(startOffset.x + x * TILE_SIZE, startOffset.y + y * TILE_SIZE); // <-- Ãp dá»¥ng offset
                    // CÃ³ thá»ƒ cáº§n scale náº¿u tile trong PNG khÃ´ng Ä‘Ãºng 32x32 hoáº·c muá»‘n Ä‘iá»u chá»‰nh
                    // tileSprite->setScale(TILE_SIZE / tileSprite->getContentSize().width);
                    visualNode->addChild(tileSprite);
                }
            }
        }
        root->addChild(visualNode, 1); // Z-order cho visual node

    } else {
        // Náº¿u khÃ´ng cÃ³ texture, quay láº¡i váº½ mÃ u Ä‘áº·c nhÆ° cÅ©
        auto dn = DrawNode::create();
        dn->drawSolidRect(r.origin, r.origin + r.size, col);
        root->addChild(dn, 1);
        visualNode = dn; // Sá»­ dá»¥ng DrawNode lÃ m visual node
    }
    
    // Pháº§n Physics Body váº«n giá»¯ nguyÃªn
    auto n = Node::create();
    n->setPosition(Vec2::ZERO); // Physics body khÃ´ng cáº§n di chuyá»ƒn, nÃ³ sáº½ dÃ¹ng offset
    auto body = PhysicsBody::createBox(r.size, PhysicsMaterial(0.1f,0,0.6f), r.origin + r.size*0.5f);
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_WORLD);
    body->setCollisionBitmask((int)(phys::CAT_ALL & ~phys::CAT_BULLET));
    body->setContactTestBitmask((int)phys::CAT_ALL);
    n->addComponent(body);
    root->addChild(n, 2);

    return n;
}

static void coinLine(Node* root, const Vec2& start, int n, float stepX){
    for (int i=0;i<n;i++){
        auto c = Coin::create();
        c->setPosition(start + Vec2(i*stepX,0));
        root->addChild(c,5);
    }
}
static void placeChest(Node* root, const Vec2& p){
    if (auto ch = Chest::create()){ ch->setPosition(p); root->addChild(ch,5); }
}
// CHá»ˆ táº¡o Ä‘Ãºng loáº¡i, KHÃ”NG set duration á»Ÿ Ä‘Ã¢y
static void placeUpgrade(Node* root, Upgrade::Type t, const Vec2& p){
    Upgrade* u = Upgrade::create(t);
    if (!u) u = Upgrade::createRandom();
    if (u) { u->setPosition(p); root->addChild(u, 5); }
}

// Spawns
static Enemy* spawnGoomba(Node* root, const Vec2& pos, const Vec2& pa, const Vec2& pb, int hp, float spd){
    auto e = Goomba::create();
    e->enablePhysics(pos, Size(38,38));
    e->setPatrol(pa, pb);
    e->setMaxHp(hp);
    e->setMoveSpeed(spd);
    root->addChild(e, 4);
    return e;
}
static Enemy* spawnSpiker(Node* root, const Vec2& pos, const Vec2& pa, const Vec2& pb, int hp, float spd){
    auto e = Spiker::create();
    e->enablePhysics(pos, Size(40,40));
    e->setPatrol(pa, pb);
    e->setMaxHp(hp);
    e->setMoveSpeed(spd);
    root->addChild(e, 4);
    return e;
}


BuildResult buildLevel1(Node* root, const Size& vs, const Vec2& origin) {
    cocos2d::Size _vs{};
    cocos2d::Vec2 _origin{};
    _vs     = Director::getInstance()->getVisibleSize();
    _origin = Director::getInstance()->getVisibleOrigin();
    cocos2d::ParallaxNode* _parallaxNode = nullptr; 
    const float SCREEN_CENTER_X = origin.x + vs.width * 0.5f; 
    const float SCREEN_CENTER_Y = origin.y + vs.height * 0.5f;
    BuildResult L;
    L.segments     = 5;
    L.segmentWidth = vs.width;
    L.groundTop    = origin.y + 28.f;
    L.playerSpawn  = origin + Vec2(80.f, L.groundTop + 40.f);

    // ground dÃ i
    // makeSolid(root, Rect(origin.x, origin.y, vs.width*L.segments, 24.f), Color4F(0.2f,0.85f,0.2f,1));
    const Vec2 GROUND_TILE_OFFSET(0.0f, -65.0f); // Dá»‹ch chuyá»ƒn táº¥t cáº£ tile ground xuá»‘ng 75px
    makeSolid(root, Rect(origin.x, origin.y, vs.width*L.segments, 24.f),
              Color4F(0.20f,0.85f,0.20f,1), "sprites/tiles/ground_tile.png", GROUND_TILE_OFFSET);
    
    const float JUMP_DY = 70.f;
    const float GAP_X   = 130.f;
    const float P_W     = 180.f;
    const float P_H     = 16.f;

    for (int s=0; s<L.segments; ++s) {
            _parallaxNode = ParallaxNode::create();
    // Äáº·t Z-order ráº¥t tháº¥p Ä‘á»ƒ nÃ³ náº±m sau táº¥t cáº£ map vÃ  Ä‘á»‘i tÆ°á»£ng.
    // addChild(_parallaxNode, -100); 
    root->addChild(_parallaxNode, -100);

    // Lá»šP BACKGROUND 1 (bgFar): DUY NHáº¤T VÃ€ PHá»¦ Äáº¦Y MÃ€N HÃŒNH
    auto bgFar = Sprite::create("sprites/backgrounds/background.png"); 
    if (bgFar) {
        float bgW = bgFar->getContentSize().width;
        float bgH = bgFar->getContentSize().height;
        
        float scaleX = _vs.width / bgW;
        float scaleY = _vs.height / bgH;
        float scale = std::max(scaleX, scaleY); // PhÃ³ng to Ä‘á»ƒ che phá»§ cáº£ width vÃ  height
        
        // CÄƒn tÃ¢m Sprite Ä‘á»ƒ Ä‘áº·t á»Ÿ giá»¯a mÃ n hÃ¬nh
        bgFar->setAnchorPoint(Vec2(0.5f, 0.5f)); 
        bgFar->setScale(scale); 
        
        // Vá»‹ trÃ­: Äáº·t á»Ÿ trung tÃ¢m Viewport
        float startX = SCREEN_CENTER_X; 
        float startY = SCREEN_CENTER_Y; 
        
        // Tá»· lá»‡ di chuyá»ƒn: (0.1f, 1.0f)
        _parallaxNode->addChild(bgFar, -1, Vec2(0.1f, 1.0f), Vec2(startX, startY));
    }
    
    // Lá»šP BACKGROUND 2 (bgNear): CHá»ˆ 1 áº¢NH (KhÃ´ng láº·p láº¡i)
    auto bgNear = Sprite::create("sprites/backgrounds/mountains.png");
    if (bgNear) {
        // Äáº·t anchor point á»Ÿ gÃ³c trÃ¡i dÆ°á»›i (0, 0)
        bgNear->setAnchorPoint(Vec2(0.f, 0.f)); 
        
        // Vá»‹ trÃ­ X: Báº¯t Ä‘áº§u tá»« mÃ©p trÃ¡i mÃ n hÃ¬nh
        float startX = _origin.x; 
        // Vá»‹ trÃ­ Y: Neo theo _groundTop
        float startY = L.groundTop - 100.f; 

        // Tá»· lá»‡ di chuyá»ƒn: (0.5f, 1.0f)
        _parallaxNode->addChild(bgNear, 0, Vec2(0.5f, 1.0f), Vec2(startX, startY)); 
    }

        float baseX = origin.x + s*vs.width;
        float g     = L.groundTop;

        // auto platform = [&](float xPix, float y, float w){
        //     return makeSolid(root, Rect(xPix, g+y, w, P_H),
        //                      Color4F(0.55f,0.58f,0.95f,1));
        // };
                const Vec2 PLATFORM_TILE_OFFSET(-15.0f, -22.0f); // Dá»‹ch chuyá»ƒn táº¥t cáº£ tile platform sang pháº£i 10px vÃ  xuá»‘ng 22px


        auto platform = [&](float xPix, float y, float w){
            return makeSolid(root, Rect(xPix, g+y, w, P_H),
                             Color4F(0.55f,0.58f,0.95f,1),"sprites/tiles/platform_tile.png", PLATFORM_TILE_OFFSET);
        };
        
        // // !platform giá»¯a
        // float platformY = L.groundTop + 70.f;
        // makeSolid(root, Rect(baseX + vs.width*0.40f, platformY, 220.f, 16.f), Color4F(0.55f,0.58f,0.95f,1), "sprites/tiles/platform_tile.png", PLATFORM_TILE_OFFSET);

        int   EHP = HP_BY_SEG[s];
        float ESP = SPD_BY_SEG[s];
        auto  UT  = UPG_BY_SEG[s];

        switch (s) {
        // ===== Segment 1 â€” tutorial, Goomba cháº­m, nháº£y báº­c thang
        case 0: {
            float x1 = baseX + vs.width*0.22f, y1 =  80.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.42f), y2 = y1 + JUMP_DY;
            float x3 = std::min(x2 + GAP_X, baseX + vs.width*0.62f), y3 = y2 + JUMP_DY;
            platform(x1, y1, P_W);
            platform(x2, y2, P_W);
            platform(x3, y3, P_W-10.f);

            // trá»¥ cáº£n nho nhá» cho Ä‘á»¡ trá»‘ng
            const Vec2 WALL_TILE_OFFSET(0.0f, -85.0f);
            makeSolid(root, Rect(baseX+vs.width*0.78f, g, 20, 70), Color4F(0.25f,0.8f,0.25f,1),"sprites/tiles/wall_tile.png", WALL_TILE_OFFSET);

            coinLine(root, {baseX + 140, g+120}, 4, 36.f);
            placeUpgrade(root, UT, {x2 + P_W*0.5f, g + y2 + 26.f});
            placeChest(root, {baseX + vs.width*0.84f, g+36});

            auto e = spawnGoomba(root, {x2 + P_W*0.5f, g+y2 + 22.f},
                                 {x2-80.f, g+y2 + 22.f}, {x2+80.f, g+y2 + 22.f},
                                 EHP, ESP);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x3 + P_W*0.5f, g+y3 + 34.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 2 â€” Spiker, nháº£y chÃ©o
        case 1: {
            float x1 = baseX + vs.width*0.24f, y1 =  90.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.54f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W-10.f);
            platform(x2, y2, P_W);

            // cá»™t Ä‘Ã´i
            makeSolid(root, Rect(baseX+vs.width*0.68f, g, 18, 76), Color4F(0.25f,0.8f,0.25f,1));
            makeSolid(root, Rect(baseX+vs.width*0.73f, g, 18, 60), Color4F(0.25f,0.8f,0.25f,1));

            coinLine(root, {baseX + 160, g+180}, 4, 36.f);
            placeUpgrade(root, UT, {x1 + P_W*0.5f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.82f, g+36});

            auto e = spawnSpiker(root, {x2 + P_W*0.5f, g+y2 + 22.f},
                                 {x2-90.f, g+y2 + 22.f}, {x2+90.f, g+y2 + 22.f},
                                 EHP, ESP);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.3f, g+y2 + 60.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 3 â€” Mix: goomba + spiker, platform rá»™ng
        case 2: {
            float x1 = baseX + vs.width*0.18f, y1 =  90.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.48f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W-20.f);
            platform(x2, y2, P_W+30.f);

            coinLine(root, {baseX + 160, g+165}, 5, 34.f);
            placeUpgrade(root, UT, {x1 + P_W*0.3f, g+y1 + 24.f});
            placeChest(root, {baseX + vs.width*0.80f, g+36});

            auto e1 = spawnGoomba(root, {x1 + P_W*0.3f, g+y1 + 20.f},
                                  {x1-60.f, g+y1 + 20.f}, {x1+60.f, g+y1 + 20.f},
                                  EHP, ESP-10.f);
            auto e2 = spawnSpiker(root, {x2 + P_W*0.4f, g+y2 + 22.f},
                                  {x2-90.f, g+y2 + 22.f}, {x2+90.f, g+y2 + 22.f},
                                  EHP+1, ESP);
            L.enemies.pushBack(e1); L.enemies.pushBack(e2);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.55f, g+y2 + 60.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 4 â€” Spiker nhanh, trá»¥ cao dáº¡ng â€œcÃ¡nh cá»•ngâ€
        case 3: {
            float x1 = baseX + vs.width*0.30f, y1 = 120.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.64f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W);
            platform(x2, y2, P_W-20.f);

            // cá»•ng
            makeSolid(root, Rect(baseX+vs.width*0.20f, g, 22, 96), Color4F(0.25f,0.8f,0.25f,1));
            makeSolid(root, Rect(baseX+vs.width*0.86f, g, 22, 96), Color4F(0.25f,0.8f,0.25f,1));

            coinLine(root, {baseX + 120, g+210}, 6, 30.f);
            placeUpgrade(root, UT, {x1 + P_W*0.4f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.84f, g+36});

            auto e = spawnSpiker(root, {x1 + P_W*0.4f, g+y1 + 22.f},
                                 {x1-90.f, g+y1 + 22.f}, {x1+90.f, g+y1 + 22.f},
                                 EHP+2, ESP+8.f);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.4f, g+y2 + 65.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 5 â€” BOSS (khÃ´ng Ä‘áº·t Star tÄ©nh; Star rÆ¡i tá»« boss)
        default: {
            float x1 = baseX + vs.width*0.22f, y1 = 110.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.48f), y2 = y1 + JUMP_DY;
            float x3 = std::min(x2 + GAP_X, baseX + vs.width*0.74f), y3 = y2 + JUMP_DY;
            platform(x1, y1, P_W-10.f);
            platform(x2, y2, P_W+10.f);
            platform(x3, y3, P_W-20.f);

            coinLine(root, {baseX + 140, g+150}, 6, 34.f);
            placeUpgrade(root, UT, {x1 + P_W*0.4f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.60f, g+36});

            auto boss = BossGolem::create();
            boss->enablePhysics({baseX + vs.width*0.68f, g + 40.f}, Size(72,72));
            // Máº·c Ä‘á»‹nh boss â€œngá»§â€, GameScene sáº½ báº­t aggro á»Ÿ khÃºc cuá»‘i
            boss->setAggroEnabled(false);
            root->addChild(boss, 4);
            L.enemies.pushBack(boss);
            // KHÃ”NG táº¡o Star tÄ©nh á»Ÿ segment boss
        } break;
        }
    }
    return L;
}

} // namespace levels

File LevelBuilder.h
#pragma once

#include "cocos2d.h"

class Enemy;
#include "2d/CCParallaxNode.h"


namespace levels {

struct BuildResult {
    float groundTop = 0.f;
    int   segments  = 5;
    float segmentWidth = 0.f;
    cocos2d::Vec2 playerSpawn{0,0};
    cocos2d::Vector<Enemy*> enemies;
};

BuildResult buildLevel1(cocos2d::Node* root,
                        const cocos2d::Size& vs,
                        const cocos2d::Vec2& origin);

} // namespace levels


Folder Classes/game/objects
File Chest.cpp
#include "game/objects/Chest.h"
#include "game/objects/Coin.h"
#include "game/objects/Upgrade.h"

#include "physics/PhysicsDefs.h"
#include "physics/CCPhysicsBody.h"

#include "2d/CCDrawNode.h"
#include "base/ccRandom.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
USING_NS_CC;

bool Chest::init() {
    if (!Entity::init()) return false;

    _sprite = Sprite::create("sprites/objects/chest/chest_1.png");
    _sprite->setScale(1.3f); // tÃ¹y chá»‰nh kÃ­ch cá»¡ hiá»ƒn thá»‹
    addChild(_sprite, 1);

    // Váº­t lÃ½: item-sensor, chá»‰ cáº§n contact vá»›i Player
    auto body = PhysicsBody::createBox(Size(28, 20));
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask((int)phys::CAT_PLAYER);
    setPhysicsBody(body);

    return true;
}

void Chest::open() {
    if (_opened) return;
    _opened = true;

    auto* parent = getParent();
    if (!parent) { removeFromParent(); return; }

    // RÆ¡i 3â€“5 coin ráº£i xung quanh
    int nCoin = RandomHelper::random_int(3, 5);
    for (int i = 0; i < nCoin; ++i) {
        if (auto* c = Coin::create()) {
            c->setPosition(getPosition() + Vec2(
                RandomHelper::random_real(-12.f, 12.f),
                RandomHelper::random_real(6.f, 16.f)
            ));
            parent->addChild(c, 5);
        }
    }

    // 1 Upgrade (hoáº·c báº¡n chá»‰nh tá»‰ lá»‡ náº¿u muá»‘n)
    if (auto* u = Upgrade::createRandom()) {
        u->setPosition(getPosition() + Vec2(0, 18));
        parent->addChild(u, 5);
    }

    // KHÃ”NG spawn Star á»Ÿ Ä‘Ã¢y
    runAction(Sequence::create(
        FadeOut::create(0.05f),
        CallFunc::create([this] { removeFromParent(); }),
        nullptr
    ));
}

File Chest.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"

class Chest : public Entity {
public:
    CREATE_FUNC(Chest);
    bool init() override;

    // Má»Ÿ rÆ°Æ¡ng: nháº£ loot xong tá»± há»§y
    void open();
    cocos2d::Sprite* _sprite = nullptr;

private:
    bool _opened = false;
};

File Coin.cpp
// Coin.cpp
#include "game/objects/Coin.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Coin* Coin::create(){ auto p=new(std::nothrow) Coin(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Coin::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::COIN);

    _sprite = Sprite::create("sprites/objects/coin/coin_1.png"); // frame Ä‘áº§u tiÃªn
    _sprite->setScale(1.5f); // tÃ¹y chá»‰nh kÃ­ch cá»¡ hiá»ƒn thá»‹
    addChild(_sprite, 1);

    Vector<SpriteFrame*> frames;
    auto firstSize = _sprite->getContentSize();
    for (int i = 1; i <= 4; i++) { // giáº£ sá»­ báº¡n cÃ³ coin_1.png -> coin_5.png
        std::string framePath = StringUtils::format("sprites/objects/coin/coin_%d.png", i);
        auto frame = SpriteFrame::create(framePath, Rect(0, 0, firstSize.width, firstSize.height));
        frame->setOriginalSize(firstSize);
        frames.pushBack(frame);
    }

    auto animation = Animation::createWithSpriteFrames(frames, 0.2f); // 0.4s má»—i frame
    auto animate = Animate::create(animation);
    _sprite->runAction(RepeatForever::create(animate));

   
    auto body = PhysicsBody::createCircle(10);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);               // sensor-only
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Coin.h
// Coin.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
class Coin : public Entity {
public:
    static Coin* create();
    bool init() override;
    cocos2d::Sprite* _sprite = nullptr;
};

File Crate.cpp
// Crate.cpp
#include "game/objects/Crate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Crate* Crate::create(){ auto p=new(std::nothrow) Crate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Crate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::CRATE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-16,-16},{16,16}, Color4F(0.6f,0.4f,0.2f,1));
    addChild(dn);
    auto b = PhysicsBody::createBox(Size(32,32), PhysicsMaterial(0.3f,0,0.9f));
    b->setDynamic(true);
    b->setCategoryBitmask(phys::CAT_CRATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}

File Crate.h
// Crate.h
#pragma once
#include "game/Entity.h"
class Crate : public Entity {
public:
    static Crate* create();
    bool init() override;
};

File Gate.cpp
// Gate.cpp
#include "game/objects/Gate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Gate* Gate::create(){ auto p=new(std::nothrow) Gate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Gate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::GATE);
    _dn = DrawNode::create();
    _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
    addChild(_dn);
    auto b = PhysicsBody::createBox(Size(24,80));
    b->setDynamic(false);
    b->setCategoryBitmask(phys::CAT_GATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}
void Gate::open(bool on){
    _open = on;
    if(auto* b=getPhysicsBody()){
        b->setEnabled(!on);
    }
    _dn->clear();
    if(on) _dn->drawRect({-12,-40},{12,40}, Color4F(0.2f,1,0.2f,1));     // khung trá»‘ng
    else   _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
}

File Gate.h
// Gate.h
#pragma once
#include "game/Entity.h"
class Gate : public Entity {
public:
    static Gate* create();
    bool init() override;
    void open(bool on);
    bool isOpen() const { return _open; }
private:
    bool _open=false;
    cocos2d::DrawNode* _dn=nullptr;
};

File PressurePlate.cpp
#include "game/objects/PressurePlate.h"
#include "physics/PhysicsDefs.h"
#include "cocos2d.h"

USING_NS_CC;

bool PressurePlate::init(){
    if(!Node::init()) return false;

    const float ww = 48.f, hh = 10.f;
    auto body = PhysicsBody::createBox(Size(ww, hh));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_SENSOR);
    body->setCollisionBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    body->setContactTestBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    setPhysicsBody(body);

    setTagEx(phys::Tag::PLATE);

    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-ww/2,-hh/2), Vec2(ww/2,hh/2), Color4F(0.9f,0.2f,0.2f,0.9f));
    addChild(dn);

    return true;
}

File PressurePlate.h
// PressurePlate.h
#pragma once
#include "game/Entity.h"
class PressurePlate : public Entity {
public:
    static PressurePlate* create();
    bool init() override;
    void setCallback(const std::function<void(bool)>& cb){ _cb = cb; }
private:
    std::function<void(bool)> _cb;
    int _pressCount = 0;
};

File Star.cpp
// Star.cpp
#include "game/objects/Star.h"
#include "physics/PhysicsDefs.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
USING_NS_CC;
Star* Star::create(){ auto p=new(std::nothrow) Star(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Star::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::STAR);


    _sprite = Sprite::create("sprites/objects/star/star_1.png"); // frame Ä‘áº§u tiÃªn
    _sprite->setScale(1.7f); // tÃ¹y chá»‰nh kÃ­ch cá»¡ hiá»ƒn thá»‹
    addChild(_sprite, 1);

    Vector<SpriteFrame*> frames;
    auto firstSize = _sprite->getContentSize();
    for (int i = 1; i <= 13; i++) { // giáº£ sá»­ báº¡n cÃ³ star_1.png -> star_5.png
        std::string framePath = StringUtils::format("sprites/objects/star/star_%d.png", i);
        auto frame = SpriteFrame::create(framePath, Rect(0, 0, firstSize.width, firstSize.height));
        frame->setOriginalSize(firstSize);
        frames.pushBack(frame);
    }

    auto animation = Animation::createWithSpriteFrames(frames, 0.085f); // 0.085s má»—i frame
    auto animate = Animate::create(animation);
    _sprite->runAction(RepeatForever::create(animate));


    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Star.h
// Star.h
#pragma once
#include "game/Entity.h"
class Star : public Entity {
public:
    static Star* create();
    bool init() override;
    cocos2d::Sprite* _sprite = nullptr;
};

File Upgrade.cpp
#include "game/objects/Upgrade.h"
#include "physics/PhysicsDefs.h"
#include "base/ccRandom.h"
USING_NS_CC;

// ======= Báº¢NG THá»œI LÆ¯á»¢NG Cá» Äá»ŠNH (Ä‘á»•i 1 chá»— lÃ  xong) =======
static constexpr float DUR_SPEED      = 45.f;
static constexpr float DUR_JUMP       = 45.f;
static constexpr float DUR_DAMAGE     = 30.f;
static constexpr float DUR_BULLET     = 40.f;
static constexpr float DUR_RANGE      = 35.f;
static constexpr float DUR_DOUBLEJUMP = 60.f;
static constexpr float DUR_EXTRALIFE  = 3.f;  // chá»‰ Ä‘á»ƒ HUD hiá»ƒn thá»‹
// ===========================================================

float Upgrade::durationFor(Upgrade::Type t){
    switch(t){
        case Type::SPEED:      return DUR_SPEED;
        case Type::JUMP:       return DUR_JUMP;
        case Type::DAMAGE:     return DUR_DAMAGE;
        case Type::BULLET:     return DUR_BULLET;
        case Type::RANGE:      return DUR_RANGE;
        case Type::DOUBLEJUMP: return DUR_DOUBLEJUMP;
        case Type::EXTRA_LIFE: return DUR_EXTRALIFE;
        default: return 30.f;
    }
}

Upgrade* Upgrade::create(){ return createRandom(); }

Upgrade* Upgrade::create(Upgrade::Type t){
    auto p = new(std::nothrow) Upgrade();
    if (p && p->init()){
        p->autorelease();
        p->set(t);                           // <â€” luÃ´n gÃ¡n duration chuáº©n
        return p;
    }
    CC_SAFE_DELETE(p); return nullptr;
}

Upgrade* Upgrade::createRandom(){
    // Tá»‰ lá»‡ loáº¡i â€” thá»i lÆ°á»£ng sáº½ tá»± láº¥y tá»« durationFor()
    int roll = RandomHelper::random_int(1,100);
    Type t;
    if      (roll<=18) t=Type::SPEED;
    else if (roll<=36) t=Type::JUMP;
    else if (roll<=54) t=Type::DAMAGE;
    else if (roll<=70) t=Type::BULLET;
    else if (roll<=82) t=Type::RANGE;
    else if (roll<=92) t=Type::DOUBLEJUMP;
    else               t=Type::EXTRA_LIFE;
    return create(t);
}

bool Upgrade::init(){
    if(!Entity::init()) return false;
    setTagEx((int)phys::Tag::UPGRADE);

    _sprite = Sprite::create("sprites/objects/upgrade/upgrade_generic.png");
    if(!_sprite){ _sprite = Sprite::create(); _sprite->setTextureRect(Rect(0,0,20,20)); }
    _sprite->setScale(0.1f);
    addChild(_sprite);

    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask((int)phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

void Upgrade::set(Type t){
    _type = t;
    _duration = durationFor(t);     // <â€” á» ÄÃ‚Y: chá»‘t duration
    _refreshVisual();
}

void Upgrade::_refreshVisual(){
    const char* name = "upgrade_generic.png";
    switch(_type){
        case Type::SPEED:      name="upgrade_speed.png"; break;//
        case Type::JUMP:       name="upgrade_jump.png"; break;//
        case Type::DAMAGE:     name="upgrade_damage.png"; break;//
        case Type::BULLET:     name="upgrade_bullet.png"; break;//
        case Type::RANGE:      name="upgrade_range.png"; break;//
        case Type::DOUBLEJUMP: name="upgrade_doublejump.png"; break;//
        case Type::EXTRA_LIFE: name="upgrade_extralife.png"; break;//
    }
    auto path = std::string("sprites/objects/upgrade/") + name;
    if (FileUtils::getInstance()->isFileExist(path)) _sprite->setTexture(path);
}

File Upgrade.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"

class Upgrade : public Entity {
public:
    enum class Type {
        SPEED = 0, JUMP = 1, DAMAGE = 2, BULLET = 3,
        RANGE = 4, DOUBLEJUMP = 5, EXTRA_LIFE = 6
    };

    static Upgrade* create();               // random theo báº£ng loáº¡i, nhÆ°ng thá»i lÆ°á»£ng cá»‘ Ä‘á»‹nh
    static Upgrade* create(Type t);         // táº¡o Ä‘Ãºng loáº¡i, tá»± gÃ¡n duration chuáº©n
    static Upgrade* createRandom();         // pick loáº¡i, gÃ¡n duration chuáº©n

    bool init() override;

    Type  type()     const { return _type; }
    float duration() const { return _duration; }   // EXTRA_LIFE => 3s chá»‰ Ä‘á»ƒ HUD bÃ¡o
    static float durationFor(Type t);              // <â€” HÃ€M CHUáº¨N HOÃ DUY NHáº¤T

    void  set(Type t);                             // gÃ¡n loáº¡i + duration chuáº©n

private:
    cocos2d::Sprite* _sprite = nullptr;
    Type   _type      = Type::SPEED;
    float  _duration  = 0.f;

    void   _refreshVisual();
};


Folder Classes/game/upgrades
File UpgradeSystem.cpp
#include "game/upgrades/UpgradeSystem.h"
using namespace cocos2d;
using namespace upgrades;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

UpgradeSystem::Effect UpgradeSystem::roll(int segIndex, const RollSpec& spec) {
    // Chá»n type
    Type T;
    switch (irand(0,4)) {
        case 0: T = Type::MOVE_SPEED;  break;
        case 1: T = Type::JUMP_POWER;  break;
        case 2: T = Type::DAMAGE_MULT; break;
        case 3: T = Type::BULLET_COUNT;break;
        default:T = Type::SLASH_RANGE; break;
    }

    // BiÃªn Ä‘á»™ â€œmá»m tayâ€
    float mag = 0.f;
    switch (T) {
        case Type::MOVE_SPEED:   mag = frand(18.f, 40.f);   break;
        case Type::JUMP_POWER:   mag = frand(24.f, 60.f);   break;
        case Type::DAMAGE_MULT:  mag = frand(1.15f, 1.45f); break;
        case Type::BULLET_COUNT: mag = (float)irand(1,2);   break;
        case Type::SLASH_RANGE:  mag = frand(1.15f, 1.40f); break;
    }

    // 50% TIMED, cÃ²n láº¡i theo defaultScope
    Scope sc  = spec.defaultScope;
    float dur = 0.f;
    if (spec.allowTimed && RandomHelper::random_int(0,1)==1) {
        sc  = Scope::TIMED;
        dur = spec.timedDuration + segIndex * 3.f; // mini sau lÃ¢u hÆ¡n chÃºt
    }

    return Effect{ T, mag, sc, dur };
}

File UpgradeSystem.h
#pragma once
#include "cocos2d.h"

namespace upgrades {

// Thá»i háº¡n hiá»‡u lá»±c
enum class Scope : int { TIMED, SEGMENT, PERSIST };

// Loáº¡i nÃ¢ng cáº¥p
enum class Type  : int {
    MOVE_SPEED,     // +px/s
    JUMP_POWER,     // +impulse
    DAMAGE_MULT,    // Ã— sÃ¡t thÆ°Æ¡ng (Ä‘áº¡n + chÃ©m)
    BULLET_COUNT,   // +sá»‘ Ä‘áº¡n má»—i phÃ¡t
    SLASH_RANGE     // Ã— táº§m chÃ©m
};

// Hiá»‡u á»©ng cá»¥ thá»ƒ
struct Effect {
    Type  type;
    float magnitude;    // + hoáº·c Ã— (tuá»³ loáº¡i)
    Scope scope;
    float durationSec;  // dÃ¹ng khi TIMED; SEGMENT/PERSIST = 0
};

// Tham sá»‘ roll gacha
struct RollSpec {
    Scope defaultScope  = Scope::SEGMENT; // máº·c Ä‘á»‹nh háº¿t mini thÃ¬ háº¿t
    float timedDuration = 20.f;           // base thá»i gian khi TIMED
    bool  allowTimed    = true;           // 50% ra TIMED náº¿u true
};

class UpgradeSystem {
public:
    // Tráº£ vá» 1 hiá»‡u á»©ng ngáº«u nhiÃªn theo mini (segIndex) vÃ  rule
    static Effect roll(int segIndex, const RollSpec& spec = {});
};

} // namespace upgrades


Folder Classes/game/weapon
File Bullet.cpp
#include "game/weapon/Bullet.h"
#include "physics/PhysicsDefs.h"          // <-- cáº§n Ä‘á»ƒ dÃ¹ng phys::CAT_*, MASK_*, Tag
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include <algorithm>                       // <-- std::max

using namespace cocos2d;

Bullet* Bullet::create(const Vec2& origin, const Vec2& velocity, float lifeSec) {
    auto p = new (std::nothrow) Bullet();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay + name cho dá»… debug / lá»c va cháº¡m
        p->setTagEx(phys::Tag::BULLET);
        p->setName("player_proj");

        // Vá»‹ trÃ­ ban Ä‘áº§u
        p->setPosition(origin);

        // Váº½ dáº¥u cháº¥m nhá» cho dá»… nhÃ¬n
        auto dot = DrawNode::create();
        dot->drawSolidCircle(Vec2::ZERO, 4.5f, 0, 12, Color4F(1.f, 0.95f, 0.2f, 1.f));
        p->addChild(dot);

        // ThÃ¢n váº­t lÃ½
        auto body = PhysicsBody::createCircle(4.5f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Masks: Ä‘á»ƒ Ä‘áº¡n ngÆ°á»i chÆ¡i cÃ³ thá»ƒ "Ä‘á»¥ng" ENEMY + ENEMY_PROJ (Ä‘Ã£ cÃ³ trong MASK_BULLET)
        body->setCategoryBitmask(static_cast<int>(phys::CAT_BULLET));
        body->setCollisionBitmask(static_cast<int>(phys::MASK_BULLET));
        body->setContactTestBitmask(static_cast<int>(phys::MASK_BULLET));

        // Gáº¯n tag lÃªn shape Ä‘á»ƒ contact listener nháº­n diá»‡n nhanh
        if (!body->getShapes().empty())
            body->getShapes().front()->setTag(static_cast<int>(phys::Tag::BULLET));

        p->addComponent(body);

        // Bay theo váº­n tá»‘c Ä‘áº§u vÃ o
        body->setVelocity(velocity);

        // Tá»± há»§y sau lifeSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Bullet.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Bullet : public Entity {
public:
    CREATE_FUNC(Bullet);

    // Táº¡o bullet táº¡i origin, bay vá»›i velocity, tá»± há»§y sau lifeSec
    static Bullet* create(const cocos2d::Vec2& origin,
                          const cocos2d::Vec2& velocity,
                          float lifeSec);

protected:
    bool init() override { return Entity::init(); }
};

File Slash.cpp
#include "game/weapon/Slash.h"
#include "physics/PhysicsDefs.h"          // <-- CAT_SENSOR, MASK_SENSOR, ShapeTag::SLASH
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include <algorithm>
#include <cmath>

using namespace cocos2d;

Slash* Slash::create(const Vec2& origin, float angleRad, float sizeOrRange, float durationSec) {
    auto p = new (std::nothrow) Slash();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay + name Ä‘á»ƒ phÃ¢n biá»‡t trong onContact
        p->setTagEx(phys::Tag::SLASH);
        p->setName("player_slash");

        p->setPosition(origin);

        // (Optional) Visual debug â€” giá»¯ nguyÃªn táº¯t Ä‘i Ä‘á»ƒ gá»n
        // auto dn = DrawNode::create();
        float r  = std::max(8.0f, sizeOrRange);

        Vec2 a( std::cos(angleRad), std::sin(angleRad) );
        Vec2 p0 = Vec2::ZERO;
        Vec2 p1 = a * r;
        Vec2 p2 = a.rotateByAngle(Vec2::ZERO, 0.35f) * (r * 0.75f);
        Vec2 tri[3] = { p0, p1, p2 };
        // dn->drawSolidPoly(tri, 3, Color4F(1.f, 1.f, 0.4f, 0.35f));
        // p->addChild(dn);

        // Body sensor hÃ¬nh há»™p má»ng, Ä‘áº·t lá»‡ch vá» hÆ°á»›ng táº¥n cÃ´ng
        auto body = PhysicsBody::create();
        body->setDynamic(false);
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Há»™p má»ng theo hÆ°á»›ng chÃ©m (offset theo vector a)
        const float boxW = r * 0.9f;
        const float boxH = std::max(10.0f, r * 0.35f);
        Vec2 offset = a * (r * 0.45f);

        auto shape = PhysicsShapeBox::create(Size(boxW, boxH), PhysicsMaterial(0,0,0), offset);
        shape->setSensor(true);
        shape->setTag(static_cast<int>(phys::ShapeTag::SLASH));
        body->addShape(shape);

        // Masks: sensor chá»‰ cáº§n contact (MASK_SENSOR = CAT_ALL) Ä‘á»ƒ báº¯t ENEMY vÃ  ENEMY_PROJ
        body->setCategoryBitmask(static_cast<int>(phys::CAT_SENSOR));
        body->setCollisionBitmask(0);
        body->setContactTestBitmask(static_cast<int>(phys::MASK_SENSOR));

        p->addComponent(body);

        // Xoay Ä‘á»ƒ visual khá»›p hÆ°á»›ng
        p->setRotation(-CC_RADIANS_TO_DEGREES(angleRad));

        // Tá»± há»§y sau durationSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, durationSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Slash.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

#pragma once
#include "game/Entity.h"

class Slash : public Entity {
public:
    static Slash* create(const cocos2d::Vec2& origin, float angleRad,
                         float sizeOrRange, float durationSec = 0.15f);
    bool init() override { return Entity::init(); }
};


Folder Classes/physics
File PhysicsDefs.h
#pragma once
#include <cstdint>
#include <initializer_list>
#include "cocos2d.h"

namespace phys {

// ==============================
// Bit/Mask cÆ¡ báº£n
// ==============================
using Mask = std::uint32_t;

enum : Mask {
    CAT_NONE       = 0u,
    CAT_WORLD      = 1u << 0,  // ground/map/platform
    CAT_PLAYER     = 1u << 1,
    CAT_ENEMY      = 1u << 2,
    CAT_ITEM       = 1u << 3,  // coin/star/upgradeâ€¦
    CAT_BULLET     = 1u << 4,  // projectile cá»§a ngÆ°á»i chÆ¡i
    CAT_SENSOR     = 1u << 5,  // generic sensors
    CAT_CRATE      = 1u << 6,
    CAT_GATE       = 1u << 7,
    CAT_SOLID      = 1u << 8,  // tÆ°á»ng/váº­t thá»ƒ ráº¯n khÃ¡c

    // TÃCH BIT RIÃŠNG cho Ä‘áº¡n/aoe cá»§a káº» Ä‘á»‹ch (khÃ´ng Ä‘Ã¨ CRATE)
    CAT_ENEMY_PROJ = 1u << 9,

    CAT_ALL        = 0xFFFFFFFFu
};

// ==============================
// Tag gameplay cho Entity
// ==============================
enum class Tag : int {
    NONE    = 0,
    COIN    = 1,
    STAR    = 2,
    UPGRADE = 3,
    GATE    = 4,
    CRATE   = 5,
    BULLET  = 6,
    SLASH   = 7,
    PLATE   = 8,
    PLAYER  = 9,
    ENEMY   = 10
};

// ==============================
// Tag cho PhysicsShape (sensor/fixture)
// ==============================
enum class ShapeTag : int {
    NONE  = 0,
    FOOT  = 1,  // chÃ¢n player Ä‘á»ƒ báº¯t tiáº¿p Ä‘áº¥t
    SLASH = 2   // hitbox chÃ©m
};

// Alias sá»‘ nguyÃªn Ä‘á»ƒ code cÅ© gá»i phys::FOOT/SLASH váº«n cháº¡y
constexpr int FOOT  = static_cast<int>(ShapeTag::FOOT);
constexpr int SLASH = static_cast<int>(ShapeTag::SLASH);

// ==============================
// Masks giá»¯ láº¡i cho back-compat
// ==============================
// CHÃš Ã: Bullet cá»§a player sáº½ contact vá»›i ENEMY_PROJ Ä‘á»ƒ báº¯n ná»• Ä‘áº¡n quÃ¡i
constexpr Mask MASK_BULLET = (CAT_WORLD | CAT_ENEMY | CAT_ENEMY_PROJ | CAT_GATE | CAT_CRATE);
constexpr Mask MASK_SENSOR = CAT_ALL;

// ==============================
// Helpers cho mask
// ==============================
inline Mask all() { return CAT_ALL; }

// all({ A, B, C }) â€” C++14, khÃ´ng dÃ¹ng fold-expression
inline Mask all(std::initializer_list<Mask> xs) {
    Mask m = 0u;
    for (Mask v : xs) m |= v;
    return m;
}

inline bool any(Mask m, Mask flags) { return (m & flags) != 0u; }

// ==============================
// Helpers thao tÃ¡c vá»›i PhysicsBody / Node
// ==============================
inline bool hasCat(const cocos2d::PhysicsBody* body, Mask cat) {
    return body && ((static_cast<Mask>(body->getCategoryBitmask()) & cat) != 0u);
}
inline bool hasCat(const cocos2d::Node* node, Mask cat) {
    return node && hasCat(node->getPhysicsBody(), cat);
}

inline void setMasks(cocos2d::PhysicsBody* body, Mask category, Mask collide, Mask contact) {
    if (!body) return;
    body->setCategoryBitmask(static_cast<int>(category));
    body->setCollisionBitmask(static_cast<int>(collide));
    body->setContactTestBitmask(static_cast<int>(contact));
}
inline void setMasks(cocos2d::Node* node, Mask category, Mask collide, Mask contact) {
    if (!node) return;
    setMasks(node->getPhysicsBody(), category, collide, contact);
}

// Ä‘áº·t TÃ‚M thÃ¢n á»Ÿ ngay phÃ­a trÃªn mÃ©p trÃªn topY, cÃ³ skin nhá» Ä‘á»ƒ khÃ´ng "lÃºn"
inline float yOnTop(float topY, float bodyH, float skin = 0.5f) {
    return topY + bodyH * 0.5f + skin;
}

} // namespace phys

// ------------------------------------------------------------
// Legacy forwarders: cho nhá»¯ng chá»— gá»i all(...) khÃ´ng cÃ³ tiá»n tá»‘ phys::
// ------------------------------------------------------------
inline phys::Mask all() { return phys::all(); }
inline phys::Mask all(std::initializer_list<phys::Mask> xs) { return phys::all(xs); }


Folder Classes/scenes
File CreditsScene.cpp
#include "scenes/CreditsScene.h"
#include "scenes/MenuScene.h"

#include "cocos2d.h"
#include "ui/CocosGUI.h"

USING_NS_CC;
using namespace cocos2d::ui;

Scene* CreditsScene::createScene(){ return CreditsScene::create(); }

bool CreditsScene::init(){
    if(!Scene::init()) return false;

    auto bg = LayerGradient::create(Color4B(8,10,16,255), Color4B(14,18,26,255));
    addChild(bg, -1);

    _buildUI();
    _bindInput();
    return true;
}

void CreditsScene::_buildUI(){
    auto D   = Director::getInstance();
    auto vs  = D->getVisibleSize();
    auto org = D->getVisibleOrigin();

    auto title = Label::createWithSystemFont("CREDITS", "Arial", 48);
    title->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.78f));
    addChild(title);

    std::string lines =
        "Game Design: You & Team\n"
        "Programming: You (& Chat teammate)\n"
        "Art: Placeholder Pack\n"
        "Audio: Placeholder Pack\n"
        "Engine: cocos2d-x 4.x\n\n"
        "Special Thanks: Friends & Community";
    auto body = Label::createWithSystemFont(lines, "Arial", 22);
    body->setAlignment(TextHAlignment::CENTER);
    body->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.52f));
    addChild(body);

    auto hint = Label::createWithSystemFont("[ESC] Back to Menu", "Arial", 18);
    hint->setOpacity(170);
    hint->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.12f));
    addChild(hint);

    auto back = Button::create();
    back->setTitleFontName("Arial"); back->setTitleFontSize(24);
    back->setTitleText("BACK");
    back->setScale9Enabled(true); back->ignoreContentAdaptWithSize(false);
    back->setContentSize({220,54});
    back->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.28f));
    auto box = LayerColor::create(Color4B(232,232,236,255));
    box->setContentSize(back->getContentSize());
    box->setIgnoreAnchorPointForPosition(false);
    box->setAnchorPoint({0.5f,0.5f});
    box->setPosition(back->getContentSize()*0.5f);
    back->addChild(box, -1);
    back->addClickEventListener([](Ref*){ Director::getInstance()->popScene(); });
    addChild(back);
}

void CreditsScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyReleased = [](EventKeyboard::KeyCode k, Event*){
        if (k == EventKeyboard::KeyCode::KEY_ESCAPE) Director::getInstance()->popScene();
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}

void CreditsScene::onExit(){
    if (_kb) { _eventDispatcher->removeEventListener(_kb); _kb=nullptr; }
    Scene::onExit();
}

File CreditsScene.h
#pragma once
#include "cocos2d.h"

class CreditsScene : public cocos2d::Scene {
public:
    CREATE_FUNC(CreditsScene);
    static cocos2d::Scene* createScene();

    bool init() override;
    void onExit() override;

private:
    void _buildUI();
    void _bindInput();

    cocos2d::EventListenerKeyboard* _kb = nullptr;
};

File EndScene.cpp
#include "scenes/EndScene.h"
#include "scenes/MenuScene.h"

#include "cocos2d.h"
#include "ui/CocosGUI.h"

USING_NS_CC;
using namespace cocos2d::ui;

EndScene* EndScene::createWithText(const std::string& msg){
    auto p = new (std::nothrow) EndScene();
    if (p && p->initWithText(msg)) { p->autorelease(); return p; }
    CC_SAFE_DELETE(p); return nullptr;
}

bool EndScene::initWithText(const std::string& msg){
    if(!Scene::init()) return false;

    auto bg = LayerGradient::create(Color4B(6,10,14,255), Color4B(14,22,30,255));
    addChild(bg, -1);

    _buildUI(msg);

    // ESC/ENTER -> vá» menu
    auto l = EventListenerKeyboard::create();
    l->onKeyReleased = [](EventKeyboard::KeyCode k, Event*){
        if (k==EventKeyboard::KeyCode::KEY_ESCAPE ||
            k==EventKeyboard::KeyCode::KEY_ENTER ||
            k==EventKeyboard::KeyCode::KEY_KP_ENTER) {
            Director::getInstance()->replaceScene(
                TransitionFade::create(0.2f, MenuScene::createScene()));
        }
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    return true;
}

void EndScene::_buildUI(const std::string& msg){
    auto D   = Director::getInstance();
    auto vs  = D->getVisibleSize();
    auto org = D->getVisibleOrigin();

    auto t = Label::createWithSystemFont(msg.empty() ? "THE END" : msg, "Arial", 48);
    t->setAlignment(TextHAlignment::CENTER);
    t->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.55f));
    addChild(t);

    auto hint = Label::createWithSystemFont("[Enter] Back to Menu", "Arial", 20);
    hint->setOpacity(170);
    hint->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.18f));
    addChild(hint);

    auto back = Button::create();
    back->setTitleFontName("Arial"); back->setTitleFontSize(24);
    back->setTitleText("BACK TO MENU");
    back->setScale9Enabled(true); back->ignoreContentAdaptWithSize(false);
    back->setContentSize({300,56});
    back->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.32f));
    auto box = LayerColor::create(Color4B(232,232,236,255));
    box->setContentSize(back->getContentSize());
    box->setIgnoreAnchorPointForPosition(false);
    box->setAnchorPoint({0.5f,0.5f});
    box->setPosition(back->getContentSize()*0.5f);
    back->addChild(box, -1);
    back->addClickEventListener([](Ref*){
        Director::getInstance()->replaceScene(
            TransitionFade::create(0.2f, MenuScene::createScene()));
    });
    addChild(back);
}

File EndScene.h
#pragma once
#include "cocos2d.h"

class EndScene : public cocos2d::Scene {
public:
    static EndScene* createWithText(const std::string& msg);
    virtual bool initWithText(const std::string& msg);

private:
    void _buildUI(const std::string& msg);
};

File GameScene.cpp
#include "scenes/GameScene.h"
#include "ui/HUDLayer.h"
#include "game/map/LevelBuilder.h"

#include "game/Enemy.h"
#include "game/bosses/BossGolem.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Chest.h"

#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include "physics/PhysicsDefs.h"
#include <algorithm>
#include <vector>

#include "ui/PauseLayer.h"
#include "scenes/MenuScene.h"

// Ã‚m thanh
#include "audio/Sound.h"

USING_NS_CC;

// ---------------------------
// Helpers file-scope
// ---------------------------
static inline bool isSlashShape(cocos2d::PhysicsShape* s) {
    return s && s->getTag() == (int)phys::ShapeTag::SLASH;
}

static bool hasCat(cocos2d::Node* n, phys::Mask catMask){
    if (!n) return false;
    auto* body = n->getPhysicsBody();
    return body && ((static_cast<phys::Mask>(body->getCategoryBitmask()) & catMask) != 0u);
}

// SFX pickup gá»n, náº¿u file thiáº¿u AudioEngine sáº½ bá» qua, khÃ´ng crash
static inline void playPickupSfx() { snd::sfxCoin(); }

// ======================================================================

Scene* GameScene::createScene() {
    auto scene = Scene::createWithPhysics();
    auto layer = GameScene::create();
    layer->setPhysicsWorld(scene->getPhysicsWorld());
    scene->addChild(layer);
    return scene;
}

bool GameScene::init() {
    if (!Layer::init()) return false;

    _vs     = Director::getInstance()->getVisibleSize();
    _origin = Director::getInstance()->getVisibleOrigin();

    buildUICamera();
    buildHUD();

    // build map
    auto L = levels::buildLevel1(this, _vs, _origin);
    _groundTop    = L.groundTop;
    _segmentCount = L.segments;
    _segmentWidth = L.segmentWidth;

    _segment = 0;
    _camL = _origin.x + _segment * _segmentWidth;
    _camR = _camL + _segmentWidth;

    // Player
    _player = Player::create();
    addChild(_player, 5);
    _player->enablePhysics({ L.playerSpawn.x, _groundTop + 220.f });

    // GÃN TARGET + cáº¥u hÃ¬nh aggro (boss máº·c Ä‘á»‹nh ngá»§)
    for (auto* e : L.enemies) {
        _enemies.pushBack(e);
        e->setTarget(_player);
        e->setAggroEnabled(true);
        e->setAggroRange(220.f);
        e->setChaseSpeed(130.f);
        if (auto boss = dynamic_cast<BossGolem*>(e)) {
            boss->setAggroEnabled(false);    // chá»‰ báº­t á»Ÿ mini cuá»‘i
            boss->setAggroRange(320.f);
            boss->setChaseSpeed(110.f);
        }
    }

    // HUD
    _lives = 3; _score = 0; _starsHave = 0;
    _starsNeed = _segmentCount;      // 1 sao / mini
    if (_hud) {
        _hud->setZone(1, _segmentCount);
        _hud->setLives(_lives);
        _hud->setScore(_score);
        _hud->setStars(_starsHave, _starsNeed);
        _hud->setHP(_player->hp(), _player->maxHp());
    }

    // --- Sao theo mini + barrier + portal ---
    _starsSeg.assign(_segmentCount, 0);

    // Barrier khoÃ¡ giá»¯a cÃ¡c mini
    for (int i=0; i<_segmentCount-1; ++i) {
        float x = _origin.x + (i+1)*_segmentWidth - 3.f;
        auto n = Node::create();
        auto body = PhysicsBody::createBox(Size(6, _vs.height));
        body->setDynamic(false);
        body->setCategoryBitmask((int)phys::CAT_GATE);
        body->setCollisionBitmask((int)(phys::CAT_PLAYER | phys::CAT_ENEMY));
        body->setContactTestBitmask((int)(phys::CAT_PLAYER | phys::CAT_ENEMY));

        n->addComponent(body);
        n->setPosition({x, _groundTop + _vs.height*0.5f});
        addChild(n, 2);
        _locks.push_back(n);
    }

    // Portal cuá»‘i (visual)
    auto dn = DrawNode::create();
    dn->drawSolidCircle(Vec2::ZERO, 24, 0, 28, Color4F(0.7f,0.9f,1.f,0.85f));
    _endPortal = dn;
    _endPortal->setPosition(_origin + Vec2(_segmentCount*_segmentWidth - 64.f, _groundTop + 64.f));
    addChild(_endPortal, 3);

    _bindInput();

    auto cl = EventListenerPhysicsContact::create();
    cl->onContactBegin    = CC_CALLBACK_1(GameScene::_onContactBegin, this);
    cl->onContactSeparate = CC_CALLBACK_1(GameScene::_onContactSeparate, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(cl, this);
    _contact = cl;

    scheduleUpdate();
    return true;
}

void GameScene::onEnter() {
    Layer::onEnter();
    if (!_world && getScene()) _world = getScene()->getPhysicsWorld();
    CCASSERT(_world, "GameScene must be under a Scene with physics");
    _world->setGravity(Vec2(0, -980));

    // BGM: náº¿u file khÃ´ng tá»“n táº¡i thÃ¬ AudioEngine bá» qua, khÃ´ng crash
    snd::playBgm("audio/bgm_main.mp3", true);
}

void GameScene::onExit() {
    Layer::onExit();
}

// ======================================================================
// UI
// ======================================================================
void GameScene::buildUICamera() {
    _uiCam = Camera::createOrthographic(_vs.width, _vs.height, 1.0f, 1024.0f);
    _uiCam->setCameraFlag(CameraFlag::USER1);
    _uiCam->setPosition(_origin + Vec2(_vs.width*0.5f, _vs.height*0.5f));
    addChild(_uiCam, 999);
}

void GameScene::buildHUD() {
    _hud = HUDLayer::create();
    _hud->setCameraMask((unsigned short)CameraFlag::USER1);
    addChild(_hud, 100);
}

// ======================================================================
// Input
// ======================================================================
void GameScene::_bindInput() {
    auto l = EventListenerKeyboard::create();

    // -------------- Key Pressed --------------
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*) {
        // Äang á»Ÿ mÃ n endflow
        if (_gameOver || _gameWin) {
            if (_gameOver && c == EventKeyboard::KeyCode::KEY_R) {
                _restartLevel();
            }
            if (_gameWin && (c == EventKeyboard::KeyCode::KEY_ENTER ||
                             c == EventKeyboard::KeyCode::KEY_KP_ENTER)) {
                _returnMenu();
            }
            return;
        }

        if (!_player) return;

        switch (c) {
            case EventKeyboard::KeyCode::KEY_ESCAPE: {
                // má»Ÿ PauseOverlay náº¿u chÆ°a cÃ³
                if (!this->getChildByName("PauseOverlay")) {
                    auto p = PauseLayer::create();
                    p->setName("PauseOverlay");
                    this->addChild(p, 10000);
                }
                break;
            }
            case EventKeyboard::KeyCode::KEY_A:
            case EventKeyboard::KeyCode::KEY_LEFT_ARROW:
                _player->setMoveDir({-1.f, 0.f}); break;

            case EventKeyboard::KeyCode::KEY_D:
            case EventKeyboard::KeyCode::KEY_RIGHT_ARROW:
                _player->setMoveDir({ 1.f, 0.f}); break;

            case EventKeyboard::KeyCode::KEY_W:
            case EventKeyboard::KeyCode::KEY_UP_ARROW:
            case EventKeyboard::KeyCode::KEY_SPACE:
                _player->jump(); break;

            case EventKeyboard::KeyCode::KEY_J:
                _player->doShoot(); break;

            case EventKeyboard::KeyCode::KEY_K:
                _player->doSlash(); break;

            default: break;
        }
    };

    // -------------- Key Released --------------
    l->onKeyReleased = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin || !_player) return;

        if (c == EventKeyboard::KeyCode::KEY_A ||
            c == EventKeyboard::KeyCode::KEY_LEFT_ARROW ||
            c == EventKeyboard::KeyCode::KEY_D ||
            c == EventKeyboard::KeyCode::KEY_RIGHT_ARROW) {
            _player->setMoveDir({0.f, 0.f});
        }
    };

    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l; // lÆ°u listener
}

// ======================================================================
// Contact
// ======================================================================
bool GameScene::_onContactBegin(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();

    // FOOT â†” WORLD
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(1);
        return true;
    }

    // Player â†” Item
    Node* item = nullptr;
    if (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ITEM)) item=b;
    else if (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ITEM)) item=a;

    if (item) {
        int segByItem = (int)((item->getPositionX() - _origin.x) / _segmentWidth);
        segByItem = std::max(0, std::min(segByItem, _segmentCount-1));

        if (auto star = dynamic_cast<Star*>(item)) {
            playPickupSfx(); // gom sfx coin cho má»i pickup
            _starsSeg[segByItem] += 1;
            _setStars(_starsHave+1, _starsNeed);
            _addScore(50);

            // má»Ÿ barrier cá»§a mini nÃ y (náº¿u chÆ°a lÃ  mini cuá»‘i)
            if (segByItem < _segmentCount-1 && segByItem >= 0 && segByItem < (int)_locks.size()) {
                if (_locks[segByItem]) {
                    _locks[segByItem]->removeFromParent();
                    _locks[segByItem] = nullptr;
                    _showOverlay("Gate opened!");
                }
            }

            item->removeFromParent();
            _checkWin();
            return false;
        }

        if (auto coin = dynamic_cast<Coin*>(item)) {
            playPickupSfx();
            _addScore(10);
            item->removeFromParent();
            return false;
        }

        if (auto up = dynamic_cast<Upgrade*>(item)) {
            using T = Upgrade::Type;
            const auto t = up->type();
            playPickupSfx();
            _addScore(25);

            if (_player) {
                if (t == T::EXTRA_LIFE) {
                    _setLives(_lives + 1);
                    if (_hud) _hud->addBuff("Extra Life +1", 3.f);
                } else {
                    _player->applyUpgrade((int)t, up->duration());
                    if (_hud) {
                        std::string n;
                        switch (t) {
                            case T::SPEED:      n="Speed +25%"; break;
                            case T::JUMP:       n="Jump +15%"; break;
                            case T::DAMAGE:     n="Damage +1"; break;
                            case T::BULLET:     n="Bullet +1"; break;
                            case T::RANGE:      n="Range +"; break;
                            case T::DOUBLEJUMP: n="Double Jump"; break;
                            default:            n="Upgrade"; break;
                        }
                        _hud->addBuff(n, std::max(0.1f, up->duration()));
                    }
                }
            }
            item->removeFromParent();
            return false;
        }

        if (auto chest = dynamic_cast<Chest*>(item)) {
            playPickupSfx();
            chest->open();
            return false;
        }
    }

    // Player Bullet/Slash â†” Enemy Projectile => phÃ¡ cáº£ hai
    if ( ((hasCat(a, phys::CAT_BULLET) || isSlashShape(A)) && hasCat(b, phys::CAT_ENEMY_PROJ)) ||
         ((hasCat(b, phys::CAT_BULLET) || isSlashShape(B)) && hasCat(a, phys::CAT_ENEMY_PROJ)) ) {

        if (hasCat(a, phys::CAT_ENEMY_PROJ)) a->removeFromParent();
        if (hasCat(b, phys::CAT_ENEMY_PROJ)) b->removeFromParent();
        if (hasCat(a, phys::CAT_BULLET))     a->removeFromParent();
        if (hasCat(b, phys::CAT_BULLET))     b->removeFromParent();
        return false; // cháº·n pháº£n á»©ng váº­t lÃ½ máº·c Ä‘á»‹nh
    }

    // Player â†” Enemy Projectile => player máº¥t mÃ¡u + xoÃ¡ Ä‘áº¡n quÃ¡i
    if ( (hasCat(a, phys::CAT_PLAYER) && hasCat(b, phys::CAT_ENEMY_PROJ)) ||
         (hasCat(b, phys::CAT_PLAYER) && hasCat(a, phys::CAT_ENEMY_PROJ)) ) {

        if (_player && !_player->invincible()) {
            _player->hurt(10);
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
            if (_player->isDead()) {
                _setLives(_lives - 1);
                if (_lives <= 0) {
                    _gameOver = true; _showOverlay("YOU DIED\nPress [R] to restart");
                } else {
                    _player->restoreFullHP();
                    if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
                    if (auto body = _player->getPhysicsBody()) body->setVelocity(Vec2::ZERO);
                    _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f, _groundTop + 40.f));
                }
            }
        }
        if (hasCat(a, phys::CAT_ENEMY_PROJ)) a->removeFromParent();
        if (hasCat(b, phys::CAT_ENEMY_PROJ)) b->removeFromParent();
        return false;
    }

    // Bullet/Slash â†” Enemy
    Node* enemyNode = nullptr;
    if ((hasCat(a,phys::CAT_BULLET) || isSlashShape(A)) && hasCat(b,phys::CAT_ENEMY)) enemyNode = b;
    else if ((hasCat(b,phys::CAT_BULLET) || isSlashShape(B)) && hasCat(a,phys::CAT_ENEMY)) enemyNode = a;

    if (enemyNode) {
        // Va cháº¡m cÃ³ thá»ƒ rÆ¡i vÃ o node con (hurtbox). Leo lÃªn cha Ä‘á»ƒ tÃ¬m Enemy tháº­t.
        Node* cur = enemyNode;
        Enemy* e = nullptr;
        while (cur && !(e = dynamic_cast<Enemy*>(cur))) cur = cur->getParent();

        if (e) {
            int base = (isSlashShape(A) || isSlashShape(B)) ? 2 : 1;
            int dmg  = base + (_player ? _player->atkBonus() : 0);
            e->takeHit(dmg);
            _addScore(20);
        }

        // Dá»n Ä‘áº¡n cá»§a player
        if (hasCat(a,phys::CAT_BULLET)) a->removeFromParent();
        if (hasCat(b,phys::CAT_BULLET)) b->removeFromParent();

        return false; // cháº·n pháº£n á»©ng váº­t lÃ½ máº·c Ä‘á»‹nh
    }

    // Enemy (thÃ¢n) â†” Player
    if ((hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ENEMY)) ||
        (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ENEMY)) ) {
        if (_player && !_player->invincible()) {
            _player->hurt(10);
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());

            // náº¿u node lÃ  projectile gáº¯n tÃªn "enemy_proj" thÃ¬ dá»n luÃ´n
            if (a && a->getName()=="enemy_proj") a->removeFromParent();
            if (b && b->getName()=="enemy_proj") b->removeFromParent();

            if (_player->isDead()) {
                _setLives(_lives-1);
                if (_lives<=0) {
                    _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart");
                } else {
                    _player->restoreFullHP();
                    if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
                    if (auto body = _player->getPhysicsBody()) body->setVelocity(Vec2::ZERO);
                    _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f,
                                                        _groundTop + 40.f));
                }
            }
        }
        return true;
    }

    // Ä‘áº£m báº£o má»i Ä‘Æ°á»ng Ä‘i Ä‘á»u return cho hÃ m bool
    return true;
}

void GameScene::_onContactSeparate(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(-1);
    }
}

// ======================================================================
// Update
// ======================================================================
void GameScene::update(float dt) {
    if (_gameOver || _gameWin || !_player) return;

    if (_hud) _hud->tick(dt);

    // Camera follow trong biÃªn cá»§a Ä‘oáº¡n hiá»‡n táº¡i
    if (auto* scene = this->getScene()) {
        if (auto* cam = scene->getDefaultCamera()) {
            float x      = _player->getPositionX();
            float halfW  = _vs.width * 0.5f;
            float target = cocos2d::clampf(x, _camL + halfW, _camR - halfW);
            cam->setPositionX(target);
        }
    }

    // Sang Ä‘oáº¡n káº¿
    if (_player->getPositionX() > _camR - 4.0f && _segment < _segmentCount - 1) {
        _segment++;
        _camL = _origin.x + _segment * _segmentWidth;
        _camR = _camL + _segmentWidth;
        if (_hud) _hud->setZone(_segment + 1, _segmentCount);
    }

    // Khi vÃ o mini cuá»‘i => báº­t boss
    if (!_bossAggroOn && _segment == _segmentCount - 1) {
        for (auto* e : _enemies)
            if (auto b = dynamic_cast<BossGolem*>(e)) b->setAggroEnabled(true);
        _bossAggroOn = true;
    }

    // RÆ¡i khá»i map => trá»« máº¡ng + respawn
    if (_player->getPositionY() < _groundTop - 200.f) {
        _setLives(_lives - 1);
        if (_lives <= 0) {
            _gameOver = true;
            _showOverlay("YOU DIED\nPress [R] to restart");
        } else {
            _player->restoreFullHP();
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
            if (auto body = _player->getPhysicsBody())
                body->setVelocity(Vec2::ZERO);
            _player->setPosition(_origin + Vec2(
                _segment * _segmentWidth + _vs.width * 0.15f,
                _groundTop + 40.f
            ));
        }
    }

    // Äá»§ sao â†’ Ä‘áº¿n gáº§n portal Ä‘á»ƒ Win
    if (!_gameWin && _starsHave >= _starsNeed && _endPortal && _player) {
        float dist = _player->getPosition().distance(_endPortal->getPosition());
        if (dist < 36.f) {
            _gameWin = true;
            _showOverlay("YOU WIN!\nPress [Enter] to Menu");
        }
    }
}

// ======================================================================
// HUD helpers
// ======================================================================
void GameScene::_setLives(int v){ _lives = std::max(0, v); if (_hud) _hud->setLives(_lives); }
void GameScene::_addScore(int v){ _score += v; if (_hud) _hud->setScore(_score); }
void GameScene::_setStars(int have, int need){ _starsHave = have; _starsNeed = need; if (_hud) _hud->setStars(_starsHave, _starsNeed); }
void GameScene::_checkWin(){
    if (_starsHave >= _starsNeed && !_gameWin){
        _gameWin = true;
        _showOverlay("YOU WIN!\nPress [Enter] to Menu");
    }
}
void GameScene::_restartLevel(){ Director::getInstance()->replaceScene(GameScene::createScene()); }
void GameScene::_returnMenu(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, MenuScene::createScene()));
}

void GameScene::_showOverlay(const std::string& text){
    if(!_overlay){
        _overlay = Label::createWithSystemFont(text, "Arial", 46);
        _overlay->setAlignment(TextHAlignment::CENTER);
        _overlay->setAnchorPoint({0.5f,0.5f});
        _overlay->setColor(Color3B::WHITE);
        _overlay->enableShadow();
        addChild(_overlay, 99);
    }
    _overlay->setString(text);
    _overlay->setPosition(_origin + Vec2(_camL + _segmentWidth*0.5f, _vs.height*0.6f));
}

File GameScene.h
#pragma once
#include "cocos2d.h"
#include "game/Player.h"
#include "game/Enemy.h"
#include "game/map/LevelBuilder.h"
#include "2d/CCParallaxNode.h"

class HUDLayer;

class GameScene : public cocos2d::Layer {
public:
    static cocos2d::Scene* createScene();
    CREATE_FUNC(GameScene);

    bool init() override;
    void onEnter() override;
    void onExit() override;
    void update(float dt) override;

    void setPhysicsWorld(cocos2d::PhysicsWorld* w) { _world = w; }

private:
    // world / view
    cocos2d::PhysicsWorld* _world = nullptr;
    cocos2d::Size _vs{};
    cocos2d::Vec2 _origin{};

    // UI
    cocos2d::Camera* _uiCam = nullptr;
    HUDLayer*        _hud   = nullptr;
    cocos2d::Label*  _overlay = nullptr;

    // actors
    Player* _player = nullptr;
    cocos2d::Vector<Enemy*> _enemies;

    // level state
    float _groundTop = 0.f;
    int   _segment = 0, _segmentCount = 1;
    float _segmentWidth = 0.f;
    float _camL = 0.f, _camR = 0.f;

    int  _score=0, _lives=3, _starsHave=0, _starsNeed=5;
    bool _gameOver=false, _gameWin=false;
    bool _bossAggroOn=false; // chá»‰ báº­t khi vÃ o mini cuá»‘i

    // listeners
    cocos2d::EventListenerKeyboard*       _kb      = nullptr;
    cocos2d::EventListenerPhysicsContact* _contact = nullptr;

    // UI helpers
    void buildUICamera();
    void buildHUD();
    void _showOverlay(const std::string& text);

    // input
    void _bindInput();

    // contact
    bool _onContactBegin(cocos2d::PhysicsContact& c);
    void _onContactSeparate(cocos2d::PhysicsContact& c);

    // HUD/state
    void _setLives(int v);
    void _addScore(int v);
    void _setStars(int have, int need);
    void _checkWin();
    void _restartLevel();
    void _returnMenu();

    // stars by segment + gates + end portal
    std::vector<int> _starsSeg;
    std::vector<cocos2d::Node*> _locks;
    cocos2d::Node* _endPortal = nullptr;
};

File MenuScene.cpp
#include "scenes/MenuScene.h"
#include "scenes/GameScene.h"

// Chá»‰ 2 include nÃ y lÃ  Ä‘á»§ cho má»i thá»© trong file
#include "cocos2d.h"
#include "ui/CocosGUI.h"

using namespace cocos2d;
using namespace cocos2d::ui;

// --- Báº­t/táº¯t Settings & Credits theo macro (trÃ¡nh __has_include) ---
#ifndef USE_SETTINGS_SCENE
#define USE_SETTINGS_SCENE 0   // Ä‘á»•i thÃ nh 1 náº¿u báº¡n Ä‘Ã£ cÃ³ scenes/SettingsScene.h
#endif
#ifndef USE_CREDITS_SCENE
#define USE_CREDITS_SCENE 0    // Ä‘á»•i thÃ nh 1 náº¿u báº¡n Ä‘Ã£ cÃ³ scenes/CreditsScene.h
#endif

#if USE_SETTINGS_SCENE
  #include "scenes/SettingsScene.h"
#endif
#if USE_CREDITS_SCENE
  #include "scenes/CreditsScene.h"
#endif
// -------------------------------------------------------------------

Scene* MenuScene::createScene(){ return MenuScene::create(); }

bool MenuScene::init(){
    if(!Scene::init()) return false;

    _buildUI();
    _disableLegacyMenus();  // náº¿u template cÅ© cÃ³ Menu* thÃ¬ vÃ´ hiá»‡u
    _bindInput();
    return true;
}

void MenuScene::_buildUI(){
    auto* D  = Director::getInstance();
    auto  vs = D->getVisibleSize();
    auto  org= D->getVisibleOrigin();

    // Ná»n gradient nháº¹ (dÃ¹ng class tá»« cocos2d.h)
    auto bg = LayerGradient::create(Color4B(8,12,20,255), Color4B(16,20,28,255));
    addChild(bg, -10);

    auto title = Label::createWithSystemFont("FATERIAL", "Arial", 52);
    title->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.74f));
    title->setOpacity(0);
    title->runAction(FadeIn::create(0.25f));
    addChild(title);

    auto tagline = Label::createWithSystemFont(
        "Mini-zones â€¢ Stars â€¢ Boss â€¢ Bullet vs Projectile",
        "Arial", 18);
    tagline->setOpacity(180);
    tagline->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.68f));
    addChild(tagline);

    // helper táº¡o nÃºt pháº³ng (khÃ´ng cáº§n sprite ngoÃ i)
// helper táº¡o nÃºt pháº³ng (khÃ´ng cáº§n sprite ngoÃ i)
    auto makeBtn = [&](const std::string& text, float y, std::function<void()> cb){
        auto btn = ui::Button::create();
        btn->setTitleFontName("Arial");
        btn->setTitleFontSize(26);
        btn->setTitleText(text);

        // QUAN TRá»ŒNG: Ä‘á»ƒ size cÃ³ hiá»‡u lá»±c vá»›i UI::Widget
        btn->setScale9Enabled(true);
        btn->ignoreContentAdaptWithSize(false);
        btn->setContentSize(Size(300, 56));

        // anchor á»Ÿ giá»¯a vÃ  Ä‘áº·t Ä‘Ãºng tÃ¢m
        btn->setAnchorPoint(Vec2(0.5f, 0.5f));
        auto* D = cocos2d::Director::getInstance();
        auto  vs = D->getVisibleSize();
        auto  org= D->getVisibleOrigin();
        btn->setPosition(org + Vec2(vs.width * 0.5f, y));
        btn->setZoomScale(0.06f);

        // Ná»€N há»™p sÃ¡ng â€” cÄƒn GIá»®A nÃºt (khÃ´ng Ä‘á»ƒ (0,0) ná»¯a)
        auto box = LayerColor::create(Color4B(232,232,236,255));
        box->setContentSize(btn->getContentSize());
        box->setIgnoreAnchorPointForPosition(false);
        box->setAnchorPoint(Vec2(0.5f, 0.5f));
        box->setPosition(btn->getContentSize() * 0.5f);
        btn->addChild(box, -1);

        btn->addClickEventListener([cb](Ref*){ cb(); });
        addChild(btn);
        return btn;
    };


    makeBtn("PLAY",     vs.height*0.50f, [this]{ _goGame();     });
    makeBtn("SETTINGS", vs.height*0.40f, [this]{ _goSettings(); });
    makeBtn("CREDITS",  vs.height*0.30f, [this]{ _goCredits();  });
    makeBtn("QUIT",     vs.height*0.20f, [this]{ _quit();       });

    auto hint = Label::createWithSystemFont(
        "ENTER=Play â€¢ S=Settings â€¢ C=Credits â€¢ ESC=Quit",
        "Arial", 18);
    hint->setOpacity(170);
    hint->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.09f));
    addChild(hint);
}

void MenuScene::_disableLegacyMenus(){
    for (auto ch : getChildren())
        if (auto m = dynamic_cast<Menu*>(ch)) m->setEnabled(false);
}

void MenuScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyReleased = [this](EventKeyboard::KeyCode k, Event*){
        switch(k){
            case EventKeyboard::KeyCode::KEY_ENTER:
            case EventKeyboard::KeyCode::KEY_KP_ENTER: _goGame(); break;
            case EventKeyboard::KeyCode::KEY_S:         _goSettings(); break;
            case EventKeyboard::KeyCode::KEY_C:         _goCredits();  break;
            case EventKeyboard::KeyCode::KEY_ESCAPE:    _quit();       break;
            default: break;
        }
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}

void MenuScene::onExit(){
    if (_kb) { _eventDispatcher->removeEventListener(_kb); _kb = nullptr; }
    Scene::onExit();
}

// ----------------- Actions -----------------
void MenuScene::_goGame(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, GameScene::createScene()));
}
void MenuScene::_goSettings(){
#if USE_SETTINGS_SCENE
    Director::getInstance()->pushScene(TransitionFade::create(0.20f, SettingsScene::create()));
#else
    _toastWIP("Settings scene chÆ°a Ä‘Æ°á»£c thÃªm (WIP). Äáº·t USE_SETTINGS_SCENE=1 náº¿u Ä‘Ã£ cÃ³.");
#endif
}
void MenuScene::_goCredits(){
#if USE_CREDITS_SCENE
    Director::getInstance()->pushScene(TransitionFade::create(0.20f, CreditsScene::create()));
#else
    _toastWIP("Credits scene chÆ°a Ä‘Æ°á»£c thÃªm (WIP). Äáº·t USE_CREDITS_SCENE=1 náº¿u Ä‘Ã£ cÃ³.");
#endif
}
void MenuScene::_quit(){
    Director::getInstance()->end();
}

// ----------------- Helper -----------------
void MenuScene::_toastWIP(const std::string& msg){
    auto* D = Director::getInstance();
    auto vs  = D->getVisibleSize();
    auto org = D->getVisibleOrigin();

    auto toast = Label::createWithSystemFont(msg, "Arial", 20);
    toast->setTextColor(Color4B(255,240,180,255));
    toast->enableOutline(Color4B(0,0,0,160), 2);
    toast->setOpacity(0);
    toast->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.12f));
    addChild(toast, 999);

    toast->runAction(Sequence::create(
        FadeIn::create(0.12f),
        DelayTime::create(1.1f),
        FadeOut::create(0.25f),
        RemoveSelf::create(),
        nullptr
    ));
}

File MenuScene.h
#pragma once
#include "cocos2d.h"

class MenuScene : public cocos2d::Scene {
public:
    CREATE_FUNC(MenuScene);
    static cocos2d::Scene* createScene();

    bool init() override;
    void onExit() override;

private:
    // UI + input
    void _buildUI();
    void _bindInput();

    // actions
    void _goGame();
    void _goSettings();
    void _goCredits();
    void _quit();

    // helper
    void _disableLegacyMenus();
    void _toastWIP(const std::string& msg);

    cocos2d::EventListenerKeyboard* _kb = nullptr; // gá»¡ listener khi rá»i scene
};

File SettingsScene.cpp
#include "scenes/SettingsScene.h"
#include "scenes/MenuScene.h"

#include "cocos2d.h"
#include "ui/CocosGUI.h"

USING_NS_CC;
using namespace cocos2d::ui;

Scene* SettingsScene::createScene(){ return SettingsScene::create(); }

bool SettingsScene::init(){
    if(!Scene::init()) return false;

    // ná»n
    auto bg = LayerGradient::create(Color4B(10,14,22,255), Color4B(18,24,32,255));
    addChild(bg, -1);

    _loadValues();
    _buildUI();
    _bindInput();
    return true;
}

void SettingsScene::_buildUI(){
    auto D   = Director::getInstance();
    auto vs  = D->getVisibleSize();
    auto org = D->getVisibleOrigin();

    auto title = Label::createWithSystemFont("SETTINGS","Arial",48);
    title->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.78f));
    addChild(title);

    auto hint = Label::createWithSystemFont("[ESC] Back to Menu", "Arial", 18);
    hint->setOpacity(170);
    hint->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.12f));
    addChild(hint);

    // ---- THAY THáº¾ Háº²N HÃ€M mkRow Báº°NG Báº¢N NÃ€Y ----
    auto mkRow = [&](const std::string& name, float y, float* pv, bool isMusic){
        auto lbl = Label::createWithSystemFont(name, "Arial", 26);
        lbl->setAnchorPoint({1,0.5f});
        lbl->setPosition(org + Vec2(vs.width*0.5f - 120, y));
        addChild(lbl);

        auto valLbl = Label::createWithSystemFont(StringUtils::format("%d%%", (int)roundf((*pv)*100)), "Arial", 24);
        valLbl->setAnchorPoint({0.5f,0.5f});
        valLbl->setPosition(org + Vec2(vs.width*0.5f, y));
        addChild(valLbl);

        auto makeBtn = [&](const char* text, const Vec2& pos, std::function<void()> onClick){
            auto b = ui::Button::create();
            b->setTitleFontName("Arial"); b->setTitleFontSize(28);
            b->setTitleText(text);
            b->setScale9Enabled(true);
            b->ignoreContentAdaptWithSize(false);
            b->setContentSize({52,52});
            b->setPosition(pos);
            auto box = LayerColor::create(Color4B(232,232,236,255));
            box->setContentSize(b->getContentSize());
            box->setIgnoreAnchorPointForPosition(false);
            box->setAnchorPoint({0.5f,0.5f});
            box->setPosition(b->getContentSize()*0.5f);
            b->addChild(box, -1);
            b->addClickEventListener([onClick](Ref*){ onClick(); });
            addChild(b);
            return b;
        };

        // NÃºt -
        makeBtn("-", org + Vec2(vs.width*0.5f + 120, y), [this, pv, valLbl, isMusic](){
            *pv = clampf((*pv) - 0.05f, 0.f, 1.f);
            valLbl->setString(StringUtils::format("%d%%", (int)roundf((*pv)*100)));
            if (isMusic) _applyMusic(*pv); else _applySfx(*pv);
            _saveValues();
        });

        // NÃºt +
        makeBtn("+", org + Vec2(vs.width*0.5f + 190, y), [this, pv, valLbl, isMusic](){
            *pv = clampf((*pv) + 0.05f, 0.f, 1.f);
            valLbl->setString(StringUtils::format("%d%%", (int)roundf((*pv)*100)));
            if (isMusic) _applyMusic(*pv); else _applySfx(*pv);
            _saveValues();
        });
    };

    // ---- THAY 2 Lá»œI Gá»ŒI CÅ¨ ----
    // mkRow("Music", vs.height*0.58f, _music);
    // mkRow("SFX",   vs.height*0.46f, _sfx);

    // ---- Báº°NG 2 Lá»œI Gá»ŒI Má»šI DÃ™NG CON TRá» ----
    mkRow("Music", vs.height*0.58f, &_music, true);
    mkRow("SFX",   vs.height*0.46f, &_sfx,   false);


    // NÃºt Back
    auto back = Button::create();
    back->setTitleFontName("Arial"); back->setTitleFontSize(24);
    back->setTitleText("BACK");
    back->setScale9Enabled(true);
    back->ignoreContentAdaptWithSize(false);
    back->setContentSize({220,54});
    back->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.28f));
    auto box = LayerColor::create(Color4B(232,232,236,255));
    box->setContentSize(back->getContentSize());
    box->setIgnoreAnchorPointForPosition(false);
    box->setAnchorPoint({0.5f,0.5f});
    box->setPosition(back->getContentSize()*0.5f);
    back->addChild(box, -1);
    back->addClickEventListener([](Ref*){
        Director::getInstance()->popScene();
    });
    addChild(back);
}

void SettingsScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyReleased = [](EventKeyboard::KeyCode k, Event*){
        if (k == EventKeyboard::KeyCode::KEY_ESCAPE) {
            Director::getInstance()->popScene();
        }
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}

void SettingsScene::onExit(){
    if (_kb) { _eventDispatcher->removeEventListener(_kb); _kb=nullptr; }
    Scene::onExit();
}

void SettingsScene::_loadValues(){
    auto ud = UserDefault::getInstance();
    _music = clampf(ud->getFloatForKey("cfg.music", 0.8f), 0.f, 1.f);
    _sfx   = clampf(ud->getFloatForKey("cfg.sfx",   0.8f), 0.f, 1.f);
}
void SettingsScene::_saveValues(){
    auto ud = UserDefault::getInstance();
    ud->setFloatForKey("cfg.music", _music);
    ud->setFloatForKey("cfg.sfx",   _sfx);
    ud->flush();
}
void SettingsScene::_applyMusic(float v){ CCLOG("Music volume=%.2f (saved only)", v); }
void SettingsScene::_applySfx(float v){   CCLOG("SFX   volume=%.2f (saved only)", v); }

File SettingsScene.h
#pragma once
#include "cocos2d.h"

class SettingsScene : public cocos2d::Scene {
public:
    CREATE_FUNC(SettingsScene);
    static cocos2d::Scene* createScene();

    bool init() override;
    void onExit() override;

private:
    void _buildUI();
    void _bindInput();
    void _loadValues();
    void _saveValues();

    void _applyMusic(float v); // chá»‰ lÆ°u vÃ o UserDefault (khÃ´ng gá»i AudioEngine)
    void _applySfx(float v);

    float _music = 0.8f;
    float _sfx   = 0.8f;

    cocos2d::EventListenerKeyboard* _kb = nullptr;
};


Folder Classes/ui
File HUDLayer.cpp
#include "ui/HUDLayer.h"
using namespace cocos2d;

bool HUDLayer::init(){
    if(!Layer::init()) return false;

    // text gÃ³c
    _lLives = Label::createWithSystemFont("HP: â¤â¤â¤", "Arial", 22);
    _lScore = Label::createWithSystemFont("Score: 0", "Arial", 22);
    _lStars = Label::createWithSystemFont("â˜… 0/5", "Arial", 22);
    _lZone  = Label::createWithSystemFont("Zone 1/5", "Arial", 22);
    for(auto* L : {_lLives,_lScore,_lStars,_lZone}){
        L->setColor(Color3B::WHITE);
        L->enableShadow(Color4B(0,0,0,128), Size(1,-1), 1);
        addChild(L);
    }

    // HP bar (trÃªn cÃ¹ng, trÃ¡i)
    _hpBarBG = DrawNode::create(); addChild(_hpBarBG);
    _hpBarFG = DrawNode::create(); addChild(_hpBarFG);
    _lHPText = Label::createWithSystemFont("100/100", "Arial", 18);
    _lHPText->enableShadow();
    addChild(_lHPText);

    schedule([this](float dt){ tick(dt); }, "hud.tick");
    _layout();
    _redrawHP();
    return true;
}

void HUDLayer::onEnter(){
    Layer::onEnter();
    _layout();
}

void HUDLayer::_layout(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();

    // text
    _lLives->setAnchorPoint({0,1});  _lLives->setPosition(org + Vec2(16, vs.height-12));
    _lScore->setAnchorPoint({0,1});  _lScore->setPosition(org + Vec2(16, vs.height-40));

    _lStars->setAnchorPoint({1,1});  _lStars->setPosition(org + Vec2(vs.width-16, vs.height-12));
    _lZone ->setAnchorPoint({1,1});  _lZone ->setPosition(org + Vec2(vs.width-16, vs.height-40));

    // HP bar
    const float x = org.x + 16;
    const float y = org.y + vs.height - 72;
    const Size  sz(220, 14);
    _hpBarBG->clear();
    _hpBarBG->drawSolidRect({x-2,y-2}, {x+sz.width+2, y+sz.height+2}, Color4F(0,0,0,0.6f));
    _hpBarFG->setPosition(Vec2::ZERO);
    _lHPText->setAnchorPoint({0,0.5f});
    _lHPText->setPosition({x, y-18});
    _redrawHP();

    // Buff strip
    _layoutBuffs();
}

void HUDLayer::_redrawHP(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();
    const float x = org.x + 16;
    const float y = org.y + vs.height - 72;
    const Size  sz(220, 14);

    float t = (_hpMax>0) ? std::max(0.f, std::min(1.f, _hpCur/(float)_hpMax)) : 0.f;
    _hpBarFG->clear();
    _hpBarFG->drawSolidRect({x,y}, {x+sz.width*t, y+sz.height}, Color4F(0.9f,0.2f,0.2f,1.f));
    _lHPText->setString(StringUtils::format("%d/%d", _hpCur,_hpMax));
}

void HUDLayer::setLives(int v){
    _lives = std::max(0,v);
    std::string hearts;
    for(int i=0;i<_lives;i++) hearts += u8"â¤";
    if(hearts.empty()) hearts="0";
    _lLives->setString("HP: " + hearts);
}
void HUDLayer::setScore(int v){ _lScore->setString("Score: " + std::to_string(v)); }
void HUDLayer::setStars(int have, int need){ _lStars->setString("â˜… " + std::to_string(have)+"/"+std::to_string(need)); }
void HUDLayer::setZone(int cur, int total){ _lZone->setString("Zone " + std::to_string(cur)+"/"+std::to_string(total)); }

void HUDLayer::setHP(int cur, int max){
    _hpCur=std::max(0,cur); _hpMax=std::max(1,max); _redrawHP();
}

// ===== Buff strip =====
int HUDLayer::addBuff(const std::string& name, float dur){
    BuffUI ui; ui.id=_nextBuffId++; ui.dur=dur; ui.remain=dur;
    ui.root = Node::create(); addChild(ui.root);
    ui.name = Label::createWithSystemFont(name, "Arial", 18);
    ui.name->enableShadow();
    ui.bar  = DrawNode::create();
    ui.root->addChild(ui.name);
    ui.root->addChild(ui.bar);
    _buffs.push_back(ui);
    _layoutBuffs();
    return ui.id;
}
void HUDLayer::removeBuff(int id){
    for(size_t i=0;i<_buffs.size();++i){
        if(_buffs[i].id==id){
            _buffs[i].root->removeFromParent();
            _buffs.erase(_buffs.begin()+i);
            break;
        }
    }
    _layoutBuffs();
}
void HUDLayer::_layoutBuffs(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();
    const float startY = org.y + vs.height - 110;
    const float centerX= org.x + vs.width * 0.5f;

    const float itemW=220, itemH=18, gap=6;
    float totalW = (float)_buffs.size()*itemW + std::max(0,(int)_buffs.size()-1)*gap;

    float x0 = centerX - totalW*0.5f;
    for(size_t i=0;i<_buffs.size();++i){
        auto& b = _buffs[i];
        b.root->setPosition({x0 + i*(itemW+gap), startY});
        b.name->setAnchorPoint({0,0.5f});
        b.name->setPosition({0, itemH+6});
        // redraw bar: co dáº§n tá»« trÃ¡i -> pháº£i (tua "ngÆ°á»£c")
        b.bar->clear();
        b.bar->drawSolidRect({0,0}, {itemW, itemH}, Color4F(0,0,0,0.55f));
        float t = (b.dur>0)? (b.remain / b.dur) : 0.f;
        t = std::max(0.f,std::min(1.f,t));
        b.bar->drawSolidRect({0,0}, {itemW*t, itemH}, Color4F(0.2f,0.8f,1.f,0.9f));
    }
}
void HUDLayer::tick(float dt){
    bool changed=false;
    for(auto& b : _buffs){
        if(b.dur>0){
            b.remain -= dt;
            if(b.remain < 0) b.remain = 0;
        }
    }
    for(int i=(int)_buffs.size()-1;i>=0;--i){
        if(_buffs[i].dur>0 && _buffs[i].remain<=0.f){
            _buffs[i].root->removeFromParent();
            _buffs.erase(_buffs.begin()+i);
            changed=true;
        }
    }
    // luÃ´n váº½ láº¡i Ä‘á»™ dÃ i bar (mÆ°á»£t theo tá»«ng frame)
    _layoutBuffs();
}

File HUDLayer.h
#pragma once
#include <vector>
#include <string>
#include "cocos2d.h"

class HUDLayer : public cocos2d::Layer {
public:
    CREATE_FUNC(HUDLayer);
    bool init() override;
    void onEnter() override;

    // ===== API tá»« GameScene/Player =====
    void setLives(int v);
    void setScore(int v);
    void setStars(int have, int need);
    void setZone(int cur, int total);
    void setHP(int cur, int max);

    // Buff UI: tráº£ vá» id náº¿u muá»‘n quáº£n lÃ½ thá»§ cÃ´ng; bÃ¬nh thÆ°á»ng cá»© Ä‘á»ƒ HUD tá»± Ä‘áº¿m
    int  addBuff(const std::string& name, float durationSec);
    void removeBuff(int id);
    void tick(float dt);

private:
    cocos2d::Label* _lLives = nullptr;
    cocos2d::Label* _lScore = nullptr;
    cocos2d::Label* _lStars = nullptr;
    cocos2d::Label* _lZone  = nullptr;

    // HP bar (trÃªn trÃ¡i)
    cocos2d::DrawNode* _hpBarBG = nullptr;
    cocos2d::DrawNode* _hpBarFG = nullptr;
    cocos2d::Label*    _lHPText = nullptr;
    int _hpCur = 100, _hpMax = 100;

    // Buff strip (trÃªn cÃ¹ng, giá»¯a)
    struct BuffUI {
        int id;
        cocos2d::Node*     root;
        cocos2d::Label*    name;
        cocos2d::DrawNode* bar;
        float dur, remain;
    };
    std::vector<BuffUI> _buffs;
    int _nextBuffId = 1;

    int _lives = 3;

    void _layout();
    void _layoutBuffs();
    void _redrawHP();
};

File PauseLayer.cpp
#include "ui/PauseLayer.h"
#include "cocos2d.h"
#include "ui/CocosGUI.h"

#include "scenes/MenuScene.h"
#include "scenes/SettingsScene.h" // náº¿u chÆ°a cÃ³, cÃ³ thá»ƒ comment 2 dÃ²ng liÃªn quan
#include "scenes/GameScene.h"

USING_NS_CC;
using namespace cocos2d::ui;

PauseLayer* PauseLayer::create() {
    auto p = new (std::nothrow) PauseLayer();
    if (p && p->init()) { p->autorelease(); return p; }
    CC_SAFE_DELETE(p); return nullptr;
}

bool PauseLayer::init() {
    if (!LayerColor::initWithColor(Color4B(0,0,0,156))) return false;

    auto vs  = Director::getInstance()->getVisibleSize();
    auto org = Director::getInstance()->getVisibleOrigin();
    setContentSize(vs);
    setIgnoreAnchorPointForPosition(false);
    setPosition(org);
    setLocalZOrder(9999);

    _buildUI();

    // ESC = Resume
    auto kb = EventListenerKeyboard::create();
    kb->onKeyReleased = [this](EventKeyboard::KeyCode k, Event*){
        if (k == EventKeyboard::KeyCode::KEY_ESCAPE) this->removeFromParent();
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(kb, this);

    // cháº·n input xuyÃªn xuá»‘ng gameplay
    auto touch = EventListenerTouchOneByOne::create();
    touch->setSwallowTouches(true);
    touch->onTouchBegan = [](Touch*, Event*){ return true; };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(touch, this);
    return true;
}

void PauseLayer::_buildUI() {
    auto vs  = Director::getInstance()->getVisibleSize();
    auto org = Director::getInstance()->getVisibleOrigin();

    auto title = Label::createWithSystemFont("PAUSED", "Arial", 44);
    title->setPosition(org + Vec2(vs.width*0.5f, vs.height*0.70f));
    addChild(title);

    auto makeBtn = [&](const std::string& text, float y, std::function<void()> cb){
        auto btn = Button::create();
        btn->setTitleFontName("Arial");
        btn->setTitleFontSize(26);
        btn->setTitleText(text);
        btn->setScale9Enabled(true);
        btn->ignoreContentAdaptWithSize(false);
        btn->setContentSize(Size(300,56));
        btn->setAnchorPoint(Vec2(0.5f,0.5f));
        btn->setPosition(org + Vec2(vs.width*0.5f, y));
        btn->setZoomScale(0.06f);

        auto box = LayerColor::create(Color4B(232,232,236,255));
        box->setContentSize(btn->getContentSize());
        box->setIgnoreAnchorPointForPosition(false);
        box->setAnchorPoint(Vec2(0.5f,0.5f));
        box->setPosition(btn->getContentSize()*0.5f);
        btn->addChild(box, -1);

        btn->addClickEventListener([cb](Ref*){ cb(); });
        addChild(btn);
    };

    makeBtn("RESUME  [ESC]", vs.height*0.54f, [this]{ this->removeFromParent(); });
    makeBtn("RESTART",       vs.height*0.44f, []{
        Director::getInstance()->resume();
        Director::getInstance()->replaceScene(TransitionFade::create(0.2f, GameScene::createScene()));
    });
    makeBtn("SETTINGS",      vs.height*0.34f, []{
        // náº¿u chÆ°a cÃ³ SettingsScene, comment dÃ²ng dÆ°á»›i
        Director::getInstance()->pushScene(TransitionFade::create(0.2f, SettingsScene::create()));
    });
    makeBtn("MAIN MENU",     vs.height*0.24f, []{
        Director::getInstance()->resume();
        Director::getInstance()->replaceScene(TransitionFade::create(0.2f, MenuScene::createScene()));
    });
    makeBtn("QUIT",          vs.height*0.14f, []{
        Director::getInstance()->end();
    });
}

void PauseLayer::onEnter() {
    LayerColor::onEnter();
    // Pause â€œcá»©ngâ€ â€“ dá»«ng scheduler + actions cho má»i thá»© bÃªn dÆ°á»›i
    Director::getInstance()->pause();
}

void PauseLayer::onExit() {
    // Resume khi Ä‘Ã³ng overlay
    Director::getInstance()->resume();
    LayerColor::onExit();
}

File PauseLayer.h
#pragma once
#include "cocos2d.h"

class PauseLayer : public cocos2d::LayerColor {
public:
    static PauseLayer* create();
    bool init() override;

    void onEnter() override;  // pause toÃ n game
    void onExit()  override;  // resume toÃ n game

private:
    void _buildUI();
};


