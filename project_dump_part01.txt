===== PROJECT TREE =====
./
├── CMakeLists.txt
└── Classes
    ├── main.cpp
    ├── core
    │   ├── AppDelegate.cpp
    │   ├── AppDelegate.h
    │   └── CrashGuard.h
    ├── game
    │   ├── Enemy.cpp
    │   ├── Enemy.h
    │   ├── Entity.cpp
    │   ├── Entity.h
    │   ├── Player.cpp
    │   ├── Player.h
    │   ├── bosses
    │   │   ├── BossGolem.cpp
    │   │   └── BossGolem.h
    │   ├── enemies
    │   │   ├── Goomba.cpp
    │   │   ├── Goomba.h
    │   │   ├── Spiker.cpp
    │   │   └── Spiker.h
    │   ├── loot
    │   │   ├── LootTable.cpp
    │   │   └── LootTable.h
    │   ├── map
    │   │   ├── LevelBuilder.cpp
    │   │   └── LevelBuilder.h
    │   ├── objects
    │   │   ├── Chest.cpp
    │   │   ├── Chest.h
    │   │   ├── Coin.cpp
    │   │   ├── Coin.h
    │   │   ├── Crate.cpp
    │   │   ├── Crate.h
    │   │   ├── Gate.cpp
    │   │   ├── Gate.h
    │   │   ├── PressurePlate.cpp
    │   │   ├── PressurePlate.h
    │   │   ├── Star.cpp
    │   │   ├── Star.h
    │   │   ├── Upgrade.cpp
    │   │   └── Upgrade.h
    │   ├── upgrades
    │   │   ├── UpgradeSystem.cpp
    │   │   └── UpgradeSystem.h
    │   └── weapon
    │       ├── Bullet.cpp
    │       ├── Bullet.h
    │       ├── Slash.cpp
    │       └── Slash.h
    ├── physics
    │   └── PhysicsDefs.h
    ├── scenes
    │   ├── GameScene.cpp
    │   ├── GameScene.h
    │   ├── MenuScene.cpp
    │   └── MenuScene.h
    └── ui
        ├── HUDLayer.cpp
        └── HUDLayer.h

===== FILE MANIFEST =====
- CMakeLists.txt — 7139 bytes — ok
- Classes/main.cpp — 178 bytes — ok
- Classes/core/AppDelegate.cpp — 1209 bytes — ok
- Classes/core/AppDelegate.h — 362 bytes — ok
- Classes/core/CrashGuard.h — 195 bytes — ok
- Classes/game/Enemy.cpp — 4865 bytes — ok
- Classes/game/Enemy.h — 1659 bytes — ok
- Classes/game/Entity.cpp — 187 bytes — ok
- Classes/game/Entity.h — 788 bytes — ok
- Classes/game/Player.cpp — 9706 bytes — ok
- Classes/game/Player.h — 2927 bytes — ok
- Classes/game/bosses/BossGolem.cpp — 10008 bytes — ok
- Classes/game/bosses/BossGolem.h — 658 bytes — ok
- Classes/game/enemies/Goomba.cpp — 327 bytes — ok
- Classes/game/enemies/Goomba.h — 153 bytes — ok
- Classes/game/enemies/Spiker.cpp — 328 bytes — ok
- Classes/game/enemies/Spiker.h — 153 bytes — ok
- Classes/game/loot/LootTable.cpp — 3517 bytes — ok
- Classes/game/loot/LootTable.h — 1041 bytes — ok
- Classes/game/map/LevelBuilder.cpp — 9491 bytes — ok
- Classes/game/map/LevelBuilder.h — 442 bytes — ok
- Classes/game/objects/Chest.cpp — 1863 bytes — ok
- Classes/game/objects/Chest.h — 246 bytes — ok
- Classes/game/objects/Coin.cpp — 1583 bytes — ok
- Classes/game/objects/Coin.h — 279 bytes — ok
- Classes/game/objects/Crate.cpp — 792 bytes — ok
- Classes/game/objects/Crate.h — 152 bytes — ok
- Classes/game/objects/Gate.cpp — 1059 bytes — ok
- Classes/game/objects/Gate.h — 287 bytes — ok
- Classes/game/objects/PressurePlate.cpp — 725 bytes — ok
- Classes/game/objects/PressurePlate.h — 320 bytes — ok
- Classes/game/objects/Star.cpp — 826 bytes — ok
- Classes/game/objects/Star.h — 149 bytes — ok
- Classes/game/objects/Upgrade.cpp — 3391 bytes — ok
- Classes/game/objects/Upgrade.h — 1042 bytes — ok
- Classes/game/upgrades/UpgradeSystem.cpp — 1454 bytes — ok
- Classes/game/upgrades/UpgradeSystem.h — 1099 bytes — ok
- Classes/game/weapon/Bullet.cpp — 2103 bytes — ok
- Classes/game/weapon/Bullet.h — 473 bytes — ok
- Classes/game/weapon/Slash.cpp — 2586 bytes — ok
- Classes/game/weapon/Slash.h — 381 bytes — ok
- Classes/physics/PhysicsDefs.h — 3795 bytes — ok
- Classes/scenes/GameScene.cpp — 18338 bytes — ok
- Classes/scenes/GameScene.h — 1950 bytes — ok
- Classes/scenes/MenuScene.cpp — 1644 bytes — ok
- Classes/scenes/MenuScene.h — 375 bytes — ok
- Classes/ui/HUDLayer.cpp — 5546 bytes — ok
- Classes/ui/HUDLayer.h — 1408 bytes — ok



Folder .
File CMakeLists.txt
cmake_minimum_required(VERSION 3.20)

# ================== Project meta ==================
set(APP_NAME Faterial)
project(${APP_NAME} C CXX)

# ================== MSVC runtime & common defs ==================
if (MSVC)
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>DLL" CACHE STRING "" FORCE)
    add_compile_definitions(_CRT_SECURE_NO_WARNINGS NOMINMAX)
    add_compile_options(/MP /utf-8)
endif()

# ================== Cocos2d-x engine ==================
if(NOT DEFINED BUILD_ENGINE_DONE)
    set(COCOS2DX_ROOT_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cocos2d)
    set(CMAKE_MODULE_PATH ${COCOS2DX_ROOT_PATH}/cmake/Modules/)
    include(CocosBuildSet)
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos ${ENGINE_BINARY_PATH}/cocos/core)
endif()

# ================== Resources ==================
set(GAME_RES_FOLDER "${CMAKE_CURRENT_SOURCE_DIR}/Resources")
if(APPLE OR WINDOWS)
    cocos_mark_multi_resources(common_res_files RES_TO "Resources" FOLDERS ${GAME_RES_FOLDER})
endif()

# ================== Game headers & sources ==================
set(GAME_HEADER
    # core
    Classes/core/AppDelegate.h
    Classes/core/CrashGuard.h

    # physics
    Classes/physics/PhysicsDefs.h

    # ui
    Classes/ui/HUDLayer.h

    # scenes
    Classes/scenes/MenuScene.h
    Classes/scenes/GameScene.h

    # game base
    Classes/game/Entity.h
    Classes/game/Player.h
    Classes/game/Enemy.h

    # enemies / bosses
    Classes/game/enemies/Goomba.h
    Classes/game/enemies/Spiker.h
    Classes/game/bosses/BossGolem.h

    # objects
    Classes/game/objects/Coin.h
    Classes/game/objects/Star.h
    Classes/game/objects/Upgrade.h
    Classes/game/objects/Crate.h
    Classes/game/objects/Gate.h
    Classes/game/objects/PressurePlate.h
    Classes/game/objects/Chest.h

    # weapon
    Classes/game/weapon/Bullet.h
    Classes/game/weapon/Slash.h

    # loot & map
    Classes/game/loot/LootTable.h
    Classes/game/map/LevelBuilder.h
)

set(GAME_SRC
    # core
    Classes/core/AppDelegate.cpp

    # ui
    Classes/ui/HUDLayer.cpp

    # scenes
    Classes/scenes/MenuScene.cpp
    Classes/scenes/GameScene.cpp

    # game base
    Classes/game/Entity.cpp
    Classes/game/Player.cpp
    Classes/game/Enemy.cpp

    # enemies / bosses
    Classes/game/enemies/Goomba.cpp
    Classes/game/enemies/Spiker.cpp
    Classes/game/bosses/BossGolem.cpp

    # objects
    Classes/game/objects/Coin.cpp
    Classes/game/objects/Star.cpp
    Classes/game/objects/Upgrade.cpp
    Classes/game/objects/Crate.cpp
    Classes/game/objects/Gate.cpp
    Classes/game/objects/PressurePlate.cpp
    Classes/game/objects/Chest.cpp

    # weapon
    Classes/game/weapon/Bullet.cpp
    Classes/game/weapon/Slash.cpp

    # loot & map
    Classes/game/loot/LootTable.cpp
    Classes/game/map/LevelBuilder.cpp
)

# ================== Platform glue ==================
if(ANDROID)
    list(APPEND GAME_SRC proj.android/app/jni/hellocpp/main.cpp)

elseif(LINUX)
    list(APPEND GAME_SRC proj.linux/main.cpp)

elseif(WINDOWS)
    list(APPEND GAME_HEADER
        proj.win32/main.h
        proj.win32/resource.h
    )
    list(APPEND GAME_SRC
        proj.win32/main.cpp
        proj.win32/game.rc
        ${common_res_files}
    )

elseif(APPLE)
    if(IOS)
        list(APPEND GAME_HEADER
            proj.ios_mac/ios/AppController.h
            proj.ios_mac/ios/RootViewController.h
        )
        set(APP_UI_RES
            proj.ios_mac/ios/LaunchScreen.storyboard
            proj.ios_mac/ios/LaunchScreenBackground.png
            proj.ios_mac/ios/Images.xcassets
        )
        list(APPEND GAME_SRC
            proj.ios_mac/ios/main.m
            proj.ios_mac/ios/AppController.mm
            proj.ios_mac/ios/RootViewController.mm
            proj.ios_mac/ios/Prefix.pch
            ${APP_UI_RES}
        )
    elseif(MACOSX)
        set(APP_UI_RES
            proj.ios_mac/mac/Icon.icns
            proj.ios_mac/mac/Info.plist
        )
        list(APPEND GAME_SRC
            proj.ios_mac/mac/main.cpp
            proj.ios_mac/mac/Prefix.pch
            ${APP_UI_RES}
        )
    endif()
    list(APPEND GAME_SRC ${common_res_files})
endif()

# ================== Target ==================
set(all_code_files ${GAME_HEADER} ${GAME_SRC})

if(NOT ANDROID)
    add_executable(${APP_NAME} ${all_code_files})
else()
    add_library(${APP_NAME} SHARED ${all_code_files})
    add_subdirectory(${COCOS2DX_ROOT_PATH}/cocos/platform/android ${ENGINE_BINARY_PATH}/cocos/platform)
    target_link_libraries(${APP_NAME} PRIVATE -Wl,--whole-archive cpp_android_spec -Wl,--no-whole-archive)
endif()

# ================== Include paths ==================
target_include_directories(${APP_NAME}
    PRIVATE Classes
    PRIVATE Classes/core
    PRIVATE Classes/physics
    PRIVATE Classes/ui
    PRIVATE Classes/scenes
    PRIVATE Classes/game
    PRIVATE Classes/game/enemies
    PRIVATE Classes/game/bosses
    PRIVATE Classes/game/objects
    PRIVATE Classes/game/weapon
    PRIVATE Classes/game/loot
    PRIVATE Classes/game/map
    PRIVATE ${COCOS2DX_ROOT_PATH}/cocos/audio/include/  # AudioEngine
)

# ================== Link engine + system libs ==================
target_link_libraries(${APP_NAME} PRIVATE cocos2d)
if (MSVC)
    target_link_options(${APP_NAME} PRIVATE /NODEFAULTLIB:LIBCMT /IGNORE:4098)
    target_link_libraries(${APP_NAME} PRIVATE winmm DbgHelp legacy_stdio_definitions)
endif()

# ================== App config & copy resources/DLL ==================
setup_cocos_app_config(${APP_NAME})

# Ép exe & dll vào build/bin (không tạo Debug/Release con)
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib)
foreach(cfg Debug Release RelWithDebInfo MinSizeRel)
    set_target_properties(${APP_NAME} PROPERTIES
        RUNTIME_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        LIBRARY_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/bin
        ARCHIVE_OUTPUT_DIRECTORY_${cfg} ${CMAKE_BINARY_DIR}/lib
    )
endforeach()

# Windows: copy DLL engine (glew, glfw, openal, …) về cạnh .exe
if(WINDOWS)
    cocos_copy_target_dll(${APP_NAME})
endif()

# Copy Resources vào cạnh .exe (Windows/Linux/macOS)
if(LINUX OR WINDOWS)
    cocos_get_resource_path(APP_RES_DIR ${APP_NAME})
    cocos_copy_target_res(${APP_NAME} LINK_TO ${APP_RES_DIR} FOLDERS ${GAME_RES_FOLDER})
endif()

# (macOS/iOS) gán tài nguyên UI
if(APPLE)
    set_target_properties(${APP_NAME} PROPERTIES RESOURCE "${APP_UI_RES}")
    if(MACOSX)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/mac/Info.plist")
    elseif(IOS)
        set_xcode_property(${APP_NAME} INFOPLIST_FILE "${CMAKE_CURRENT_SOURCE_DIR}/proj.ios_mac/ios/Info.plist")
        set_xcode_property(${APP_NAME} ASSETCATALOG_COMPILER_APPICON_NAME "AppIcon")
    endif()
endif()


Folder Classes
File main.cpp
#include "core/AppDelegate.h"
#include "cocos2d.h"

USING_NS_CC;

int main(int argc, char** argv) {
    AppDelegate app;
    return Application::getInstance()->run();
}


Folder Classes/core
File AppDelegate.cpp
// AppDelegate.cpp
#include "core/AppDelegate.h"
#include "base/CCDirector.h"
#include "platform/CCGLView.h"
#include "scenes/MenuScene.h"
USING_NS_CC;

AppDelegate::AppDelegate() {}
AppDelegate::~AppDelegate() {}

void AppDelegate::initGLContextAttrs(){
    GLContextAttrs a{8,8,8,8,24,8};
    GLView::setGLContextAttrs(a);
}

bool AppDelegate::applicationDidFinishLaunching(){
    auto* director = Director::getInstance();
    auto* glview = director->getOpenGLView();
    if(!glview){
#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)
        glview = GLViewImpl::createWithRect("Faterial", Rect(0,0,1920,1080));
#else
        glview = GLViewImpl::create("Faterial");
#endif
        director->setOpenGLView(glview);
    }
    director->setAnimationInterval(1.0f/60.0f);
#if COCOS2D_DEBUG
    director->setDisplayStats(true);
#endif
    glview->setDesignResolutionSize(1280, 720, ResolutionPolicy::NO_BORDER);
    director->runWithScene(MenuScene::createScene());
    return true;
}
void AppDelegate::applicationDidEnterBackground(){ Director::getInstance()->stopAnimation(); }
void AppDelegate::applicationWillEnterForeground(){ Director::getInstance()->startAnimation(); }

File AppDelegate.h
// AppDelegate.h
#pragma once
#include "cocos2d.h"
class AppDelegate : private cocos2d::Application {
public:
    AppDelegate();
    virtual ~AppDelegate();
    virtual void initGLContextAttrs();
    virtual bool applicationDidFinishLaunching();
    virtual void applicationDidEnterBackground();
    virtual void applicationWillEnterForeground();
};

File CrashGuard.h
#pragma once
#include <cstdio>
#define CG_LOGF(path, fmt, ...) \
  do { FILE* f=nullptr; fopen_s(&f, (path), "a"); if(f){std::fprintf(f, fmt "\n", ##__VA_ARGS__); std::fclose(f);} } while(0)


Folder Classes/game
File Enemy.cpp
#include "game/Enemy.h"
#include "game/Player.h"

#include "game/objects/Coin.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Chest.h"
#include "game/loot/LootTable.h"

#include "physics/PhysicsDefs.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"

#include "2d/CCDrawNode.h"
#include "base/ccRandom.h"

USING_NS_CC;

static inline float sgn(float x) { return (x > 0.f) ? 1.f : (x < 0.f ? -1.f : 0.f); }

bool Enemy::init() {
    if (!Entity::init()) return false;
    setTagEx((int)phys::Tag::ENEMY);

    _sprite = Sprite::create();
    _sprite->setTextureRect(Rect(0, 0, 42, 42));
    _sprite->setColor(Color3B(200, 70, 70));
    addChild(_sprite);

    _hpbar = DrawNode::create();
    addChild(_hpbar, 2);

    schedule([this](float dt) { updateEnemy(dt); }, "enemy.tick");
    return true;
}

void Enemy::enablePhysics(const Vec2& pos, const Size& bodySize) {
    _body = buildOrUpdateBody(bodySize);
    applyEnemyMasks();
    setPosition(pos);
    _updateHpBar();
}

PhysicsBody* Enemy::buildOrUpdateBody(const Size& szIn) {
    Size box = (szIn.width < 1 || szIn.height < 1) ? Size(42, 42) : szIn;
    PhysicsBody* body = _body;

    if (!body) {
        body = PhysicsBody::createBox(box, PhysicsMaterial(0.2f, 0.0f, 0.4f));
        body->setDynamic(true);
        body->setRotationEnable(false);
        addComponent(body);
    } else {
        auto shapes = body->getShapes();
        for (auto s : shapes) body->removeShape(s);
        body->addShape(PhysicsShapeBox::create(box, PhysicsMaterial(0.2f, 0.0f, 0.4f)));
    }

    body->setLinearDamping(0.1f);
    body->setMass(1.0f);
    return body;
}

void Enemy::applyEnemyMasks() {
    if (!_body) return;
    _body->setCategoryBitmask((int)phys::CAT_ENEMY);
    _body->setCollisionBitmask((int)(phys::CAT_WORLD | phys::CAT_PLAYER | phys::CAT_CRATE | phys::CAT_GATE));
    _body->setContactTestBitmask((int)phys::CAT_ALL);
}

void Enemy::setPatrol(const Vec2& a, const Vec2& b) {
    _pA = a; _pB = b;
    if (_pA.x > _pB.x) std::swap(_pA, _pB);
    if (getPosition().fuzzyEquals(Vec2::ZERO, 0.1f))
        setPosition((_pA + _pB) * 0.5f);
}

void Enemy::updateEnemy(float) {
    if (!_body) return;

    Vec2 v = _body->getVelocity();

    // Đuổi khi bật aggro + trong tầm (giới hạn lệch Y để không “hút xuyên tầng”)
    bool chasing = false;
    if (_aggroEnabled && _target) {
        float dx = _target->getPositionX() - getPositionX();
        float dy = _target->getPositionY() - getPositionY();
        if (std::abs(dx) <= _aggroRange && std::abs(dy) <= 160.f) {
            _dir = (dx >= 0 ? +1 : -1);
            v.x = _dir * _chaseSpeed;
            chasing = true;
        }
    }

    // Không đuổi -> tuần tra giữa 2 mốc
    if (!chasing && _pA != _pB) {
        float x = getPositionX();
        if (_dir > 0 && x >= _pB.x) _dir = -1;
        else if (_dir < 0 && x <= _pA.x) _dir = +1;
        v.x = _dir * _moveSpeed;
    }

    v.y = std::max(v.y, -900.0f);
    _body->setVelocity(v);
}

void Enemy::_updateHpBar() {
    _hpbar->clear();
    const float w = 46.f, h = 4.f;
    const float t = std::max(0.f, std::min(1.f, _hp / (float)_maxHp));
    Vec2 base(-w * 0.5f, 28.f);
    _hpbar->drawSolidRect(base, base + Vec2(w, h), Color4F(0, 0, 0, 0.6f));
    _hpbar->drawSolidRect(base + Vec2(1, 1), base + Vec2(1 + (w - 2) * t, h - 1),
                          Color4F(0.9f, 0.2f, 0.2f, 0.95f));
}

// Rơi đồ: đẩy về LootTable (đã loại STAR)
void Enemy::_dropLoot() {
    if (auto parent = getParent())
        LootTable::dropAt(parent, getPosition());
}

void Enemy::takeHit(int dmg) {
    if (_dead) return;

    _hp -= std::max(1, dmg);
    _updateHpBar();

    if (_hp <= 0) {
        _dead = true;

        // Ngắt tương tác vật lý rồi rơi đồ đúng 1 lần
        scheduleOnce([this](float) {
            if (_body) {
                _body->setVelocity(Vec2::ZERO);
                _body->setDynamic(false);
                _body->setCategoryBitmask(0);
                _body->setCollisionBitmask(0);
                _body->setContactTestBitmask(0);
            }

            _dropLoot(); // <- duy nhất chỗ này, KHÔNG Star

            runAction(Sequence::create(
                FadeOut::create(0.08f),
                CallFunc::create([this] { removeFromParent(); }),
                nullptr
            ));
        }, 0.0f, "enemy_die_defer");
        return;
    }

    if (_sprite) {
        _sprite->runAction(Sequence::create(
            TintTo::create(0.0f, 255, 120, 120),
            DelayTime::create(0.05f),
            TintTo::create(0.0f, 200, 70, 70),
            nullptr
        ));
    }
}

File Enemy.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Player;

class Enemy : public Entity {
public:
    CREATE_FUNC(Enemy);
    bool init() override;

    void enablePhysics(const cocos2d::Vec2& pos,
                       const cocos2d::Size& bodySize = cocos2d::Size(42,42));
    void setPatrol(const cocos2d::Vec2& a, const cocos2d::Vec2& b);

    // Target + Aggro
    void setTarget(Player* p)             { _target = p; }
    void setAggroEnabled(bool on)         { _aggroEnabled = on; }
    void setAggroRange(float r)           { _aggroRange = std::max(0.f, r); }
    void setChaseSpeed(float v)           { _chaseSpeed = std::max(10.f, v); }

    virtual void takeHit(int dmg);
    virtual void updateEnemy(float dt);   // có chase theo aggro

    void setMoveSpeed(float v) { _moveSpeed = v; }
    void setMaxHp(int v) { _maxHp = _hp = std::max(1, v); _updateHpBar(); }

protected:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& sz);
    void applyEnemyMasks();

    void _updateHpBar();
    void _dropLoot();

protected:
    cocos2d::Sprite*      _sprite  = nullptr;
    cocos2d::PhysicsBody* _body    = nullptr;
    cocos2d::DrawNode*    _hpbar   = nullptr;

    // AI
    Player* _target = nullptr;
    cocos2d::Vec2 _pA, _pB;
    int   _dir = +1;
    float _moveSpeed = 90.f;      // tuần tra
    float _chaseSpeed = 140.f;    // đuổi
    float _aggroRange = 220.f;    // tầm phát hiện (theo X, kèm giới hạn Y)
    bool  _aggroEnabled = true;

    // Stat
    int _hp = 2, _maxHp = 2;
    bool _dead = false;
};

File Entity.cpp
#include "game/Entity.h"
// Hiện giờ mọi thứ đã làm trong header (inline) để đơn giản hoá.
// Nếu cần mở rộng logic chung cho mọi Entity, thêm ở đây.

File Entity.h
// Classes/game/Entity.h
#pragma once
#include "cocos2d.h"
#include "physics/PhysicsDefs.h"

// Alias toàn cục để code cũ dùng Tag::XYZ vẫn hợp lệ
using Tag = phys::Tag;

class Entity : public cocos2d::Node {
public:
    CREATE_FUNC(Entity);

    // Node::init() mặc định
    bool init() override { return cocos2d::Node::init(); }

    // Tag gameplay mở rộng (không đụng tới Node::setTag(int) của cocos2d)
    void setTagEx(Tag t)           { _gtag = t; }
    void setTagExInt(int t)        { _gtag = static_cast<Tag>(t); }  // back-compat
    void setTagEx(int t)           { _gtag = static_cast<Tag>(t); }  // back-compat: setTagEx(1)
    Tag  getTagEx() const          { return _gtag; }

protected:
    Tag _gtag = Tag::NONE;
};

File Player.cpp
#include "game/Player.h"
#include "2d/CCDrawNode.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include <algorithm>
#include <cmath>
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
#include "GameScene.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"

using namespace cocos2d;

static inline float approach(float cur, float target, float delta) {
    if (cur < target) return std::min(target, cur + delta);
    if (cur > target) return std::max(target, cur - delta);
    return cur;
}

bool Player::init() {
    if (!Entity::init()) return false;
    CCLOG("Player::init");

    _sprite = Sprite::create("sprites/player/idle/idle_1.png");
    _sprite->setAnchorPoint(Vec2(0.5f, 0.5f));
    _sprite->setPositionY(_colSize.height * 0.5f);
    _sprite->setScale(1.4f);
    addChild(_sprite, 1);

    scheduleUpdate();
    return true;
}

void Player::refreshVisual() {
    // debug draw collider nếu cần
}

void Player::enablePhysics(const Vec2& feetPos, const Size& bodySize) {
    if (bodySize.width > 0 && bodySize.height > 0) _colSize = bodySize;
    setPosition(feetPos);

    _body = buildOrUpdateBody(_colSize);
    applyPlayerMasks();

    // LƯU Ý: Cocos2d-x dùng setEnabled (đúng chính tả)
    _body->setEnabled(true);
    _body->setGravityEnable(true);
    _body->setDynamic(true);
    _body->setVelocity(Vec2::ZERO);
}

PhysicsBody* Player::buildOrUpdateBody(const Size& bodySize) {
    Size sz = bodySize;
    sz.width  = std::max(18.f, sz.width  * 0.90f);
    sz.height = std::max(30.f, sz.height * 1.5f);

    if (!_body) {
        _body = PhysicsBody::create();
        _body->setDynamic(true);
        _body->setRotationEnable(false);
        addComponent(_body);
    } else {
        auto shapes = _body->getShapes();
        for (auto s : shapes) _body->removeShape(s);
    }

    auto mainBox = PhysicsShapeBox::create(
        sz, PhysicsMaterial(0.1f, 0.0f, 0.5f),
        Vec2(0, +sz.height * 0.5f)
    );
    _body->addShape(mainBox);

    const float footH = std::max(4.0f, sz.height * 0.08f);
    const Size  footSize(sz.width * 0.60f, footH);
    const Vec2  footOffset(0, -footH * 0.5f);
    auto foot = PhysicsShapeBox::create(footSize, PhysicsMaterial(0,0,0), footOffset);
    foot->setSensor(true);
    foot->setTag((int)phys::ShapeTag::FOOT);
    _body->addShape(foot);

    _body->setMass(1.0f);
    _body->setLinearDamping(0.1f);
    return _body;
}

void Player::applyPlayerMasks() {
    if (!_body) return;

    // va chạm cứng: như cũ
    const phys::Mask collide =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_SOLID |
        phys::CAT_GATE  | phys::CAT_CRATE;

    // LIÊN HỆ (contact) — THÊM CAT_ENEMY_PROJ  ⬇⬇⬇
    const phys::Mask contact =
        phys::CAT_WORLD | phys::CAT_ENEMY | phys::CAT_ENEMY_PROJ |
        phys::CAT_ITEM  | phys::CAT_BULLET | phys::CAT_SENSOR;

    phys::setMasks(_body, phys::CAT_PLAYER, collide, contact);
}

void Player::setMoveDir(const Vec2& dir) {
    _moveDir = dir;
    if (_moveDir.x < 0) _facing = -1;
    else if (_moveDir.x > 0) _facing = +1;
}

void Player::jump() {
    if (!_body) return;
    const float m = _body->getMass();
    const float impulse = _jumpImpulse * m;

    if (_footContacts > 0) {
        _body->applyImpulse(Vec2(0, impulse));
        return;
    }
    if (_airJumpsMax > 0 && _airJumpsUsed < _airJumpsMax) {
        _airJumpsUsed++;
        _body->setVelocity(Vec2(_body->getVelocity().x, 0));
        _body->applyImpulse(Vec2(0, impulse * 0.92f));
    }
}

void Player::incFoot(int delta) {
    int prev = _footContacts;
    _footContacts = std::max(0, _footContacts + delta);
    if (prev==0 && _footContacts>0) _airJumpsUsed = 0; // chạm đất -> reset
}

void Player::heal(int v) { _hp = std::min(_maxHp, _hp + std::max(0, v)); }
void Player::restoreFullHP() { _hp = _maxHp; }

void Player::hurt(int dmg) {
    if (invincible() || !_body) return;
    _hp = std::max(0, _hp - std::max(1, dmg));
    _invincibleT = 0.8f;

    const float dir = (_facing > 0 ? -1.f : +1.f);
    _body->applyImpulse(Vec2(200.f * dir, 260.f));
}

void Player::doShoot(){
    if (_shooting) return;
    _shooting = true;

    int dir = facing();
    runAction(Sequence::create(
        DelayTime::create(0.35f),
        CallFunc::create([this, dir]() {
            int count = 1 + std::max(0, _extraBullets);
            float spread = 0.08f;
            for (int i=0;i<count;i++){
                float offY = (i - (count-1)*0.5f) * 8.0f;
                Vec2 origin = getPosition() + Vec2(dir * 18.f, halfH() * 0.25f + offY);
                Vec2 vel(700.f * dir, (i - (count-1)*0.5f) * 120.f * spread);
                auto b = Bullet::create(origin, vel, 1.5f);
                if (getParent() && b) getParent()->addChild(b, 6);
            }
        }),
        DelayTime::create(0.36f),
        CallFunc::create([this]() { _shooting = false; }),
        nullptr
    ));
}

void Player::doSlash(){
    if (_attacking) return;
    _attacking = true;
    const int dir = facing();

    runAction(Sequence::create(
        DelayTime::create(0.20f),
        CallFunc::create([this, dir]() {
            Vec2 origin = getPosition() + Vec2(dir*28.f, halfH()*0.1f);
            float angle = (dir > 0) ? 0.0f : 3.14159265f;
            auto s = Slash::create(origin, angle, _slashRange, 0.12f);
            if (auto p=getParent()) p->addChild(s, 6);
        }),
        DelayTime::create(0.30f),
        CallFunc::create([this]{ _attacking = false; }),
        nullptr));
}

void Player::applyUpgrade(int type, float duration){
    float factor = 1.f;
    switch(type){
        case 0: factor = 1.25f; _moveSpeed   *= factor; break; // SPEED
        case 1: factor = 1.15f; _jumpImpulse *= factor; break; // JUMP
        case 2: _atkBonus += 1; break;                           // DAMAGE (+1)
        case 3: _extraBullets += 1; break;                       // BULLET
        case 4: /* RANGE tăng tầm, xử lý trong Slash.create bằng _slashRange */ break;
        case 5: _airJumpsMax = std::max(_airJumpsMax, 1); break; // DOUBLEJUMP
        default: break;
    }
    _buffs.push_back({type, std::max(0.1f, duration), factor, -1});
}

cocos2d::Vector<cocos2d::SpriteFrame*> Player::buildFrames(const std::string& animName, int frameCount) {
    Vector<SpriteFrame*> frames;
    for (int i = 1; i <= frameCount; ++i) {
        std::string path = StringUtils::format("sprites/player/%s/%s_%d.png", animName.c_str(), animName.c_str(), i);
        auto tex = Director::getInstance()->getTextureCache()->addImage(path);
        if (!tex) break;
        Rect rect(0, 0, tex->getPixelsWide(), tex->getPixelsHigh());
        frames.pushBack(SpriteFrame::create(path, rect));
    }
    return frames;
}

void Player::playAnim(const std::string& animName, float delay, int frameCount) {
    if (_currentAnim == animName) return;
    auto frames = buildFrames(animName, frameCount);
    if (frames.empty()) return;

    _currentAnim = animName;
    auto animation = Animation::createWithSpriteFrames(frames, delay);
    auto act = RepeatForever::create(Animate::create(animation));
    if (_sprite) { _sprite->stopAllActions(); _sprite->runAction(act); }
}

void Player::update(float dt) {
    if (!_body) return;

    // blink invuln
    if (_invincibleT > 0.f) {
        _invincibleT -= dt;
        const bool blink = ((int)std::floor(_invincibleT * 20.f)) % 2 == 0;
        if (_sprite) _sprite->setOpacity(blink ? 140 : 255);
    } else if (_sprite) {
        _sprite->setOpacity(255);
    }

    const bool grounded = (_footContacts > 0);
    const float targetVx = _moveDir.x * _moveSpeed;

    Vec2 v = _body->getVelocity();
    const float accel = grounded ? _accelGround : _accelAir;

    if (grounded && std::abs(_moveDir.x) < 1e-3f) v.x = approach(v.x, 0.f, accel * dt);
    else v.x = approach(v.x, targetVx, accel * dt);

    v.y = std::max(v.y, -_maxFall);
    _body->setVelocity(v);

    // chọn anim
    if (isDead()) nextAnim = "die";
    else if (_attacking) nextAnim = "attack";
    else if (_shooting)  nextAnim = "shoot";
    else if (!grounded)  nextAnim = "jump";
    else if (std::abs(_moveDir.x) > 1e-3f) nextAnim = "run";
    else nextAnim = "idle";

    if (_currentAnim != nextAnim){
        if (nextAnim == "die")      playAnim("die",   0.12f, 6);
        else if (nextAnim == "jump")playAnim("jump",  0.23f, 4);
        else if (nextAnim == "run") playAnim("run",   0.06f, 8);
        else if (nextAnim == "attack") playAnim("attack", 0.06f, 6);
        else if (nextAnim == "shoot")  playAnim("shoot",  0.08f, 6);
        else playAnim("idle", 0.12f, 8);
    }

    if (_sprite) _sprite->setScaleX(_facing);

    // đếm buff & revert
    for (int i=(int)_buffs.size()-1; i>=0; --i){
        _buffs[i].remain -= dt;
        if (_buffs[i].remain <= 0.f){
            int type = _buffs[i].type; float factor = _buffs[i].factor;
            switch(type){
                case 0: _moveSpeed   /= factor; break;
                case 1: _jumpImpulse /= factor; break;
                case 2: _atkBonus    = std::max(0, _atkBonus-1); break;
                case 3: _extraBullets= std::max(0, _extraBullets-1); break;
                case 5: _airJumpsMax = 0; _airJumpsUsed = 0; break;
                default: break;
            }
            _buffs.erase(_buffs.begin()+i);
        }
    }
}

File Player.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"
#include <vector>
#include <string>

class Player : public Entity {
public:
    CREATE_FUNC(Player);
    bool init() override;

    // Vật lý
    void enablePhysics(const cocos2d::Vec2& feetPos,
                       const cocos2d::Size& bodySize = cocos2d::Size::ZERO);

    // Điều khiển
    void setMoveDir(const cocos2d::Vec2& dir);
    void jump();
    void doShoot();
    void doSlash();

    // Trạng thái gameplay
    void incFoot(int delta);
    void hurt(int dmg);
    bool invincible() const { return _invincibleT > 0.f; }

    // HP
    int  hp() const { return _hp; }
    int  maxHp() const { return _maxHp; }
    void heal(int v);
    void restoreFullHP();
    bool isDead() const { return _hp <= 0; }

    // Trợ giúp
    int   facing() const { return _facing; } // -1 / +1
    float halfH() const { return _colSize.height * 0.5f; }
    cocos2d::Size colliderSize() const { return _colSize; }

    // Buff/Upgrade
    void applyUpgrade(int type, float durationSec); // map từ Upgrade::Type
    int  atkBonus() const { return _atkBonus; }

    // Debug/anim state
    std::string nextAnim;

    // (giữ public cho tương thích code cũ)
    bool _attacking = false;
    bool _shooting  = false;

protected:
    void update(float dt) override;

private:
    cocos2d::PhysicsBody* buildOrUpdateBody(const cocos2d::Size& bodySize);
    void applyPlayerMasks();
    void refreshVisual();

    // Animation helpers (để Player.cpp gọi)
    void playAnim(const std::string& name, float delay, int frames);
    cocos2d::Vector<cocos2d::SpriteFrame*> buildFrames(const std::string& animName, int frameCount);

private:
    // Visual
    cocos2d::Sprite* _sprite = nullptr;
    std::string _currentAnim;

    // Body/collider
    cocos2d::PhysicsBody* _body = nullptr;
    cocos2d::Size _colSize{28.f, 44.f};
    cocos2d::Vec2 _moveDir{0,0};
    int _facing = +1;
    int _footContacts = 0;

    // Di chuyển
    float _moveSpeed   = 180.f;
    float _accelGround = 1200.f;
    float _accelAir    = 650.f;
    // float _jumpImpulse = 420.f;
    float _jumpImpulse = 600.f;
    float _maxFall     = 1200.f;

    // HP/invuln
    int _hp = 100;
    int _maxHp = 100;
    float _invincibleT = 0.f;

    // Buff core (chỉ khai 1 lần, không trùng!)
    int   _extraBullets = 0;   // bắn thêm N viên
    float _slashRange   = 60.f;
    float _dmgScale     = 1.0f; // nếu muốn dùng dạng nhân
    int   _atkBonus     = 0;    // đang dùng cộng thẳng

    // Double jump
    int _airJumpsMax  = 0;
    int _airJumpsUsed = 0;

    // Buff runtime (đếm ngược & revert)
    struct ActiveBuff { int type; float remain; float factor; int hudId; };
    std::vector<ActiveBuff> _buffs;
};


Folder Classes/game/bosses
File BossGolem.cpp
#include "game/bosses/BossGolem.h"
#include "game/Player.h"                  // dùng Player* cho target
#include "game/objects/Star.h"            // rơi Star khi chết

#include "physics/PhysicsDefs.h"
#include "2d/CCDrawNode.h"
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "base/ccRandom.h"

#include <vector>
#include <algorithm>
#include <cmath>

using namespace cocos2d;

BossGolem* BossGolem::create() {
    auto p = new (std::nothrow) BossGolem();
    if (p && p->init()) { p->autorelease(); return p; }
    CC_SAFE_DELETE(p); return nullptr;
}

bool BossGolem::init() {
    if (!Enemy::init()) return false;

    setMaxHp(36);
    setMoveSpeed(70.f);
    _cd = 1.0f;

    if (_sprite) {
        _sprite->setTextureRect(Rect(0,0,72,72));
        _sprite->setColor(Color3B(120,170,255));
        _sprite->setScale(1.2f);
    }

    // hitbox thân boss
    enablePhysics(getPosition(), Size(72,72));

    // AI tick
    schedule([this](float dt){ this->_tickBoss(dt); }, "boss.ai");
    return true;
}

void BossGolem::takeHit(int dmg){
    if (_dead || _dying) return;

    const int hit = std::max(1, dmg);
    const int finalHp = _hp - hit;

    // hiệu ứng trúng đòn
    if (_sprite) {
        _sprite->runAction(Sequence::create(
            TintTo::create(0.0f, 255,150,150),
            DelayTime::create(0.06f),
            TintTo::create(0.0f, 120,170,255),
            nullptr
        ));
    }

    // chưa chết -> dùng logic Enemy thường (giảm máu + cập nhật thanh HP)
    if (finalHp > 0) { Enemy::takeHit(dmg); return; }

    // ====== chết: KHÔNG gọi Enemy::takeHit để né LootTable (coin/upgrade) ======
    _hp = 0;
    _dead  = true;
    _dying = true;

    // tắt AI và "đóng băng" body (không tháo shape ngay trong step hiện tại)
    unschedule("boss.ai");
    if (_body) {
        _body->setVelocity(Vec2::ZERO);
        _body->setContactTestBitmask(0);
        _body->setCollisionBitmask((int)phys::CAT_WORLD); // vẫn đứng yên nếu còn thấy
        _body->setEnabled(false);                         // tách khỏi physics world
    }

    // Hoãn 1 nhịp ngắn để thoát contact, rồi spawn Star + xóa boss
    this->runAction(Sequence::create(
        FadeOut::create(0.05f),
        DelayTime::create(0.02f),                 // QUAN TRỌNG: hoãn 1 frame
        CallFunc::create([this](){
            if (auto parent = getParent()) {
                auto star = Star::create();
                if (star) {
                    star->setPosition(getPosition() + Vec2(0, 24.f));
                    parent->addChild(star, 7);
                }
            }
            removeFromParent();
        }),
        nullptr
    ));
}

// =====================
// Helpers nội bộ
// =====================
namespace {
    // projectile mask cho ĐẠN ĐỊCH (đã định nghĩa CAT_ENEMY_PROJ trong PhysicsDefs)
    inline void setEnemyProjMasks(cocos2d::PhysicsBody* b) {
        b->setCategoryBitmask((int)phys::CAT_ENEMY_PROJ);
        b->setCollisionBitmask((int)(phys::CAT_WORLD | phys::CAT_PLAYER));
        b->setContactTestBitmask((int)(phys::CAT_PLAYER | phys::CAT_BULLET | phys::CAT_SENSOR));
    }

    // AOE vòng tròn sensor, tự huỷ nhanh
    Node* makeAoeRing(const Vec2& center, float radius, float lifeSec = 0.25f) {
        auto n = Node::create(); n->setPosition(center);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawCircle(Vec2::ZERO, radius, 0, 28, false, 1.8f, 1.8f, Color4F(1.f,0.8f,0.4f,0.7f));
        dn->drawSolidCircle(Vec2::ZERO, radius*0.85f, 0, 24, Color4F(1,0.8f,0.4f,0.10f));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(radius, PhysicsMaterial(0,0,0));
        body->setDynamic(false);
        for (auto s : body->getShapes()) s->setSensor(true);
        setEnemyProjMasks(body);
        n->addComponent(body);

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }

    // Đạn thường: bay thẳng
    Node* makeBullet(const Vec2& origin, const Vec2& velocity, float lifeSec = 1.8f) {
        auto n = Node::create(); n->setPosition(origin);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawSolidCircle(Vec2::ZERO, 6.f, 0, 18, Color4F(0.95f,0.4f,0.2f,1));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(6.f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);
        setEnemyProjMasks(body);
        n->addComponent(body);
        body->setVelocity(velocity);
        body->setLinearDamping(0.02f);

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }

    // Đạn homing: bẻ lái dần
    Node* makeHoming(const Vec2& origin, Node* target,
                     float speed = 240.f, float turnRate = 6.0f, float lifeSec = 2.2f) {
        auto n = Node::create(); n->setPosition(origin);
        n->setName("enemy_proj");

        auto dn = DrawNode::create();
        dn->drawSolidCircle(Vec2::ZERO, 5.f, 0, 18, Color4F(0.9f,0.9f,1.f,1));
        n->addChild(dn);

        auto body = PhysicsBody::createCircle(5.f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);
        setEnemyProjMasks(body);
        n->addComponent(body);

        n->schedule([n, target, speed, turnRate](float dt){
            auto b = n->getPhysicsBody(); if (!b || !target || !target->getParent()) return;
            Vec2 from = n->getPosition(), to = target->getPosition();
            Vec2 dir  = (to - from).getNormalized();
            Vec2 desired = dir * speed;
            Vec2 v = b->getVelocity();
            float alpha = cocos2d::clampf(turnRate * dt, 0.f, 1.f);
            v = v * (1.f - alpha) + desired * alpha;
            if (v.lengthSquared() < speed*speed*0.25f) v = desired;
            b->setVelocity(v);
        }, "enemy.homing");

        n->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([n]{ n->removeFromParent(); }),
            nullptr));
        return n;
    }
} // namespace (helpers)

// =====================
// AI patterns
// =====================
void BossGolem::_tickBoss(float dt){
    if (_dead || !_body) return;

    // KHÓA HOÀN TOÀN khi chưa aggro (bật ở mini cuối trong GameScene)
    if (!_aggroEnabled) {
        Vec2 v = _body->getVelocity();
        v.x = 0.f;
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        return;
    }

    Player* p = (_target ? dynamic_cast<Player*>(_target) : nullptr);
    if (!p) return;

    Vec2 bp = getPosition();
    Vec2 pp = p->getPosition();
    float dist = bp.distance(pp);
    float dx   = pp.x - bp.x;

    const float AGGRO = 520.f;
    if (dist > AGGRO) {
        // di chuyển nhẹ khi chưa vào tầm
        Vec2 v = _body->getVelocity();
        v.x = (dx > 0 ? +1 : -1) * std::min(_moveSpeed * 0.6f, 80.f);
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        _cd -= dt * 0.5f;
        return;
    }

    _cd -= dt;
    if (_cd > 0.f) {
        Vec2 v = _body->getVelocity();
        v.x *= 0.9f;
        v.y = std::max(v.y, -900.f);
        _body->setVelocity(v);
        return;
    }

    // Ưu tiên Radial; máu thấp thì hung hăng hơn
    int r = (_hp <= _maxHp/2) ? RandomHelper::random_int(0, 3)
                              : RandomHelper::random_int(0, 2);
    if (r <= 1) _radialBurst(pp);
    else        _blinkStrike(pp);

    _cd = 1.5f + RandomHelper::random_real(0.2f, 0.9f);
}

void BossGolem::_blinkStrike(const Vec2& playerPos){
    auto parent = getParent(); if (!parent) return;
    Vec2 bp = getPosition();
    int dir = (playerPos.x >= bp.x) ? +1 : -1;

    if (_sprite) _sprite->runAction(TintTo::create(0.0f, 200,240,255));
    runAction(Sequence::create(
        DelayTime::create(0.12f), // telegraph ngắn
        CallFunc::create([=](){
            setPosition(bp + Vec2(dir * 180.f, 0));
            auto aoe = makeAoeRing(getPosition(), 90.f, 0.24f);
            if (aoe) parent->addChild(aoe, 7);
            if (_sprite) _sprite->runAction(TintTo::create(0.0f, 120,170,255));
        }),
        nullptr
    ));
}

void BossGolem::_radialBurst(const Vec2& /*playerPos*/){
    auto parent = getParent(); if (!parent) return;

    const int N = RandomHelper::random_int(12, 16);
    const int K = RandomHelper::random_int(2, 4); // số viên homing
    const float S = 260.f;

    std::vector<int> homingIdx; homingIdx.reserve(K);
    for (int i=0; i<K; ++i) homingIdx.push_back(RandomHelper::random_int(0, N-1));

    float ang0 = RandomHelper::random_real(0.f, 3.1415926f);
    for (int i=0; i<N; ++i){
        float a = ang0 + i * (2*3.1415926f / N);
        Vec2 dir(std::cos(a), std::sin(a));
        bool isHoming = (std::find(homingIdx.begin(), homingIdx.end(), i) != homingIdx.end());

        Node* b = isHoming ? makeHoming(getPosition(), _target, 240.f, 6.0f, 2.2f)
                           : makeBullet(getPosition(), dir * S, 1.8f);
        if (b) parent->addChild(b, 6);
    }

    if (_sprite) _sprite->runAction(Sequence::create(
        TintTo::create(0.0f, 255,230,140),
        DelayTime::create(0.18f),
        TintTo::create(0.0f, 120,170,255),
        nullptr
    ));
}

File BossGolem.h
#pragma once
#include "game/Enemy.h"
class Player;

class BossGolem : public Enemy {
public:
    static BossGolem* create();
    bool init() override;

    // Ghi đè để xử lý chết an toàn + rơi Star (không dùng LootTable)
    void takeHit(int dmg) override;

private:
    void _tickBoss(float dt);
    void _blinkStrike(const cocos2d::Vec2& playerPos); // dịch chuyển + AOE
    void _radialBurst(const cocos2d::Vec2& playerPos); // vòng đạn + vài viên homing

    float _cd = 1.0f;   // cooldown nội bộ luân phiên pattern
    bool  _dying = false; // tránh gọi chết nhiều lần trong cùng 1 frame
};


Folder Classes/game/enemies
File Goomba.cpp
// Goomba.cpp
#include "game/enemies/Goomba.h"
USING_NS_CC;
Goomba* Goomba::create(){ auto p=new(std::nothrow) Goomba(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Goomba::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(200,120,60));
    return true;
}

File Goomba.h
// Goomba.h
#pragma once
#include "game/Enemy.h"
class Goomba : public Enemy {
public:
    static Goomba* create();
    bool init() override;
};

File Spiker.cpp
// Spiker.cpp
#include "game/enemies/Spiker.h"
USING_NS_CC;
Spiker* Spiker::create(){ auto p=new(std::nothrow) Spiker(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Spiker::init(){
    if(!Enemy::init()) return false;
    setColor(Color3B(180,200,255));
    return true;
}

File Spiker.h
// Spiker.h
#pragma once
#include "game/Enemy.h"
class Spiker : public Enemy {
public:
    static Spiker* create();
    bool init() override;
};


Folder Classes/game/loot
File LootTable.cpp
#include "game/loot/LootTable.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "physics/CCPhysicsBody.h"
#include "physics/PhysicsDefs.h"   // <-- thêm dòng này


using namespace cocos2d;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

const std::vector<DropSpec>& LootTable::defaultEnemyTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    60.f, 1, 3 },
        { DropKind::UPGRADE, 25.f, 1, 1 },
        { DropKind::STAR,     5.f, 1, 1 },
        { DropKind::NONE,    10.f, 0, 0 }
    };
    return T;
}
const std::vector<DropSpec>& LootTable::defaultChestTable(){
    static std::vector<DropSpec> T = {
        { DropKind::COIN,    40.f, 3, 6 },
        { DropKind::UPGRADE, 45.f, 1, 2 },
        { DropKind::STAR,    10.f, 1, 1 },
        { DropKind::NONE,     5.f, 0, 0 }
    };
    return T;
}

DropKind LootTable::rollOne(const std::vector<DropSpec>& table, int& outCount){
    float sumW = 0.f;
    for (auto& e : table) sumW += e.weight;
    float r = frand(0.f, sumW), acc = 0.f;
    for (auto& e : table){
        acc += e.weight;
        if (r <= acc){
            outCount = (e.maxCount>=e.minCount)? irand(e.minCount, e.maxCount) : e.minCount;
            return e.kind;
        }
    }
    outCount = 0; return DropKind::NONE;
}

static void asSensorItem(Node* n){
    if (!n) return;
    auto* b = n->getPhysicsBody();
    if (!b){
        const float r = std::max(n->getContentSize().width, n->getContentSize().height) * 0.4f;
        b = PhysicsBody::createCircle(r, PhysicsMaterial(0,0,0));
        b->setDynamic(false);
        n->setPhysicsBody(b);
    }
    b->setGravityEnable(false);

    // mask ITEM sensor chuẩn theo PhysicsDefs
    b->setCategoryBitmask((int)phys::CAT_ITEM);
    b->setCollisionBitmask(0);                 // sensor-only
    b->setContactTestBitmask((int)phys::CAT_ALL);
    for (auto s : b->getShapes()) s->setSensor(true);
}


void LootTable::spawn(Node* root, const Vec2& p, DropKind k, int count){
    if (!root || k==DropKind::NONE || count<=0) return;
    const float spread = 28.f;

    for (int i=0;i<count;++i){
        Node* item=nullptr;
        switch (k){
            case DropKind::COIN:    item = Coin::create();    break;
            case DropKind::UPGRADE: item = Upgrade::create(); break;
            case DropKind::STAR:    item = Star::create();    break;
            default: break;
        }
        if (!item) continue;
        item->setPosition(p);
        root->addChild(item, 6);

        // sensor & hiệu ứng "bật" nhẹ
        asSensorItem(item);
        Vec2 dir = Vec2(frand(-1.f,1.f), 1.f).getNormalized();
        float dist = frand(spread*0.4f, spread);
        item->runAction(Sequence::create(
            MoveBy::create(0.25f, dir * dist),
            nullptr
        ));
    }
}

void LootTable::rollAndSpawn(Node* root, const Vec2& p, const std::vector<DropSpec>& table){
    int cnt=0; DropKind k = rollOne(table, cnt);
    spawn(root, p, k, cnt);
}

void LootTable::dropAt(Node* root, const Vec2& p, int count) {
    if (!root) return;
    count = std::max(1, count);
    for (int i = 0; i < count; ++i) {
        rollAndSpawn(root, p, defaultEnemyTable());
    }
}

File LootTable.h
#pragma once
#include <vector>
#include "cocos2d.h"

enum class DropKind { NONE, COIN, UPGRADE, STAR };

struct DropSpec {
    DropKind kind;
    float    weight;    // trọng số bốc thăm
    int      minCount;
    int      maxCount;
};

class LootTable {
public:
    static const std::vector<DropSpec>& defaultEnemyTable();
    static const std::vector<DropSpec>& defaultChestTable();

    // Roll & spawn tại vị trí p (CENTER của đối tượng chết/vỡ)
    static void rollAndSpawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                             const std::vector<DropSpec>& table = defaultEnemyTable());

    // Giữ tương thích code cũ: Enemy.cpp có thể gọi dropAt(...)
    static void dropAt(cocos2d::Node* root, const cocos2d::Vec2& p, int count = 1);

private:
    static DropKind rollOne(const std::vector<DropSpec>& table, int& outCount);
    static void     spawn(cocos2d::Node* root, const cocos2d::Vec2& p,
                          DropKind k, int count);
};


Folder Classes/game/map
File LevelBuilder.cpp
// Classes/game/map/LevelBuilder.cpp
#include "game/map/LevelBuilder.h"
#include "physics/PhysicsDefs.h"

#include "game/Enemy.h"
#include "game/enemies/Goomba.h"
#include "game/enemies/Spiker.h"
#include "game/bosses/BossGolem.h"

#include "game/objects/Coin.h"
#include "game/objects/Chest.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Star.h"
#include "2d/CCDrawNode.h"

USING_NS_CC;
namespace levels {

// ===== tuning =====
static const int   HP_BY_SEG[5]   = {3, 4, 5, 7, 36}; // boss ở seg5 dùng trong BossGolem
static const float SPD_BY_SEG[5]  = {70.f, 85.f, 95.f, 110.f, 0.f};
static const Upgrade::Type UPG_BY_SEG[5] = {
    Upgrade::Type::SPEED,
    Upgrade::Type::JUMP,
    Upgrade::Type::DAMAGE,
    Upgrade::Type::BULLET,
    Upgrade::Type::DOUBLEJUMP
};
// ===================

// nền rắn + body tĩnh
static Node* makeSolid(Node* root, const Rect& r, const Color4F& col) {
    auto dn = DrawNode::create();
    dn->drawSolidRect(r.origin, r.origin + r.size, col);
    root->addChild(dn, 1);

    auto n = Node::create();
    n->setPosition(Vec2::ZERO);
    auto body = PhysicsBody::createBox(r.size, PhysicsMaterial(0.1f,0,0.6f), r.origin + r.size*0.5f);
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_WORLD);
    body->setCollisionBitmask((int)(phys::CAT_ALL & ~phys::CAT_BULLET));
    body->setContactTestBitmask((int)phys::CAT_ALL);
    n->addComponent(body);
    root->addChild(n, 2);
    return n;
}

static void coinLine(Node* root, const Vec2& start, int n, float stepX){
    for (int i=0;i<n;i++){
        auto c = Coin::create();
        c->setPosition(start + Vec2(i*stepX,0));
        root->addChild(c,5);
    }
}
static void placeChest(Node* root, const Vec2& p){
    if (auto ch = Chest::create()){ ch->setPosition(p); root->addChild(ch,5); }
}
// CHỈ tạo đúng loại, KHÔNG set duration ở đây
static void placeUpgrade(Node* root, Upgrade::Type t, const Vec2& p){
    Upgrade* u = Upgrade::create(t);
    if (!u) u = Upgrade::createRandom();
    if (u) { u->setPosition(p); root->addChild(u, 5); }
}

// Spawns
static Enemy* spawnGoomba(Node* root, const Vec2& pos, const Vec2& pa, const Vec2& pb, int hp, float spd){
    auto e = Goomba::create();
    e->enablePhysics(pos, Size(38,38));
    e->setPatrol(pa, pb);
    e->setMaxHp(hp);
    e->setMoveSpeed(spd);
    root->addChild(e, 4);
    return e;
}
static Enemy* spawnSpiker(Node* root, const Vec2& pos, const Vec2& pa, const Vec2& pb, int hp, float spd){
    auto e = Spiker::create();
    e->enablePhysics(pos, Size(40,40));
    e->setPatrol(pa, pb);
    e->setMaxHp(hp);
    e->setMoveSpeed(spd);
    root->addChild(e, 4);
    return e;
}

BuildResult buildLevel1(Node* root, const Size& vs, const Vec2& origin) {
    BuildResult L;
    L.segments     = 5;
    L.segmentWidth = vs.width;
    L.groundTop    = origin.y + 28.f;
    L.playerSpawn  = origin + Vec2(80.f, L.groundTop + 40.f);

    // ground dài
    makeSolid(root, Rect(origin.x, origin.y, vs.width*L.segments, 24.f),
              Color4F(0.20f,0.85f,0.20f,1));

    const float JUMP_DY = 70.f;
    const float GAP_X   = 130.f;
    const float P_W     = 180.f;
    const float P_H     = 16.f;

    for (int s=0; s<L.segments; ++s) {
        float baseX = origin.x + s*vs.width;
        float g     = L.groundTop;

        auto platform = [&](float xPix, float y, float w){
            return makeSolid(root, Rect(xPix, g+y, w, P_H),
                             Color4F(0.55f,0.58f,0.95f,1));
        };

        int   EHP = HP_BY_SEG[s];
        float ESP = SPD_BY_SEG[s];
        auto  UT  = UPG_BY_SEG[s];

        switch (s) {
        // ===== Segment 1 — tutorial, Goomba chậm, nhảy bậc thang
        case 0: {
            float x1 = baseX + vs.width*0.22f, y1 =  80.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.42f), y2 = y1 + JUMP_DY;
            float x3 = std::min(x2 + GAP_X, baseX + vs.width*0.62f), y3 = y2 + JUMP_DY;
            platform(x1, y1, P_W);
            platform(x2, y2, P_W);
            platform(x3, y3, P_W-10.f);

            // trụ cản nho nhỏ cho đỡ trống
            makeSolid(root, Rect(baseX+vs.width*0.78f, g, 20, 70), Color4F(0.25f,0.8f,0.25f,1));

            coinLine(root, {baseX + 140, g+120}, 4, 36.f);
            placeUpgrade(root, UT, {x2 + P_W*0.5f, g + y2 + 26.f});
            placeChest(root, {baseX + vs.width*0.84f, g+36});

            auto e = spawnGoomba(root, {x2 + P_W*0.5f, g+y2 + 22.f},
                                 {x2-80.f, g+y2 + 22.f}, {x2+80.f, g+y2 + 22.f},
                                 EHP, ESP);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x3 + P_W*0.5f, g+y3 + 34.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 2 — Spiker, nhảy chéo
        case 1: {
            float x1 = baseX + vs.width*0.24f, y1 =  90.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.54f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W-10.f);
            platform(x2, y2, P_W);

            // cột đôi
            makeSolid(root, Rect(baseX+vs.width*0.68f, g, 18, 76), Color4F(0.25f,0.8f,0.25f,1));
            makeSolid(root, Rect(baseX+vs.width*0.73f, g, 18, 60), Color4F(0.25f,0.8f,0.25f,1));

            coinLine(root, {baseX + 160, g+180}, 4, 36.f);
            placeUpgrade(root, UT, {x1 + P_W*0.5f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.82f, g+36});

            auto e = spawnSpiker(root, {x2 + P_W*0.5f, g+y2 + 22.f},
                                 {x2-90.f, g+y2 + 22.f}, {x2+90.f, g+y2 + 22.f},
                                 EHP, ESP);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.3f, g+y2 + 60.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 3 — Mix: goomba + spiker, platform rộng
        case 2: {
            float x1 = baseX + vs.width*0.18f, y1 =  90.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.48f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W-20.f);
            platform(x2, y2, P_W+30.f);

            coinLine(root, {baseX + 160, g+165}, 5, 34.f);
            placeUpgrade(root, UT, {x1 + P_W*0.3f, g+y1 + 24.f});
            placeChest(root, {baseX + vs.width*0.80f, g+36});

            auto e1 = spawnGoomba(root, {x1 + P_W*0.3f, g+y1 + 20.f},
                                  {x1-60.f, g+y1 + 20.f}, {x1+60.f, g+y1 + 20.f},
                                  EHP, ESP-10.f);
            auto e2 = spawnSpiker(root, {x2 + P_W*0.4f, g+y2 + 22.f},
                                  {x2-90.f, g+y2 + 22.f}, {x2+90.f, g+y2 + 22.f},
                                  EHP+1, ESP);
            L.enemies.pushBack(e1); L.enemies.pushBack(e2);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.55f, g+y2 + 60.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 4 — Spiker nhanh, trụ cao dạng “cánh cổng”
        case 3: {
            float x1 = baseX + vs.width*0.30f, y1 = 120.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.64f), y2 = y1 + JUMP_DY;
            platform(x1, y1, P_W);
            platform(x2, y2, P_W-20.f);

            // cổng
            makeSolid(root, Rect(baseX+vs.width*0.20f, g, 22, 96), Color4F(0.25f,0.8f,0.25f,1));
            makeSolid(root, Rect(baseX+vs.width*0.86f, g, 22, 96), Color4F(0.25f,0.8f,0.25f,1));

            coinLine(root, {baseX + 120, g+210}, 6, 30.f);
            placeUpgrade(root, UT, {x1 + P_W*0.4f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.84f, g+36});

            auto e = spawnSpiker(root, {x1 + P_W*0.4f, g+y1 + 22.f},
                                 {x1-90.f, g+y1 + 22.f}, {x1+90.f, g+y1 + 22.f},
                                 EHP+2, ESP+8.f);
            L.enemies.pushBack(e);

            auto star = Star::create();
            star->setPosition({x2 + P_W*0.4f, g+y2 + 65.f});
            root->addChild(star, 6);
        } break;

        // ===== Segment 5 — BOSS (không đặt Star tĩnh; Star rơi từ boss)
        default: {
            float x1 = baseX + vs.width*0.22f, y1 = 110.f;
            float x2 = std::min(x1 + GAP_X, baseX + vs.width*0.48f), y2 = y1 + JUMP_DY;
            float x3 = std::min(x2 + GAP_X, baseX + vs.width*0.74f), y3 = y2 + JUMP_DY;
            platform(x1, y1, P_W-10.f);
            platform(x2, y2, P_W+10.f);
            platform(x3, y3, P_W-20.f);

            coinLine(root, {baseX + 140, g+150}, 6, 34.f);
            placeUpgrade(root, UT, {x1 + P_W*0.4f, g+y1 + 26.f});
            placeChest(root, {baseX + vs.width*0.60f, g+36});

            auto boss = BossGolem::create();
            boss->enablePhysics({baseX + vs.width*0.68f, g + 40.f}, Size(72,72));
            // Mặc định boss “ngủ”, GameScene sẽ bật aggro ở khúc cuối
            boss->setAggroEnabled(false);
            root->addChild(boss, 4);
            L.enemies.pushBack(boss);
            // KHÔNG tạo Star tĩnh ở segment boss
        } break;
        }
    }
    return L;
}

} // namespace levels

File LevelBuilder.h
#pragma once

#include "cocos2d.h"

class Enemy;

namespace levels {

struct BuildResult {
    float groundTop = 0.f;
    int   segments  = 5;
    float segmentWidth = 0.f;
    cocos2d::Vec2 playerSpawn{0,0};
    cocos2d::Vector<Enemy*> enemies;
};

BuildResult buildLevel1(cocos2d::Node* root,
                        const cocos2d::Size& vs,
                        const cocos2d::Vec2& origin);

} // namespace levels


Folder Classes/game/objects
File Chest.cpp
#include "game/objects/Chest.h"
#include "game/objects/Coin.h"
#include "game/objects/Upgrade.h"

#include "physics/PhysicsDefs.h"
#include "physics/CCPhysicsBody.h"

#include "2d/CCDrawNode.h"
#include "base/ccRandom.h"

USING_NS_CC;

bool Chest::init() {
    if (!Entity::init()) return false;

    // Hộp đơn giản (debug visual)
    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-14, -10), Vec2(14, 10), Color4F(0.6f, 0.35f, 0.1f, 1));
    dn->drawRect(Vec2(-14, -10), Vec2(14, 10), Color4F::WHITE);
    addChild(dn);

    // Vật lý: item-sensor, chỉ cần contact với Player
    auto body = PhysicsBody::createBox(Size(28, 20));
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask((int)phys::CAT_PLAYER);
    setPhysicsBody(body);

    return true;
}

void Chest::open() {
    if (_opened) return;
    _opened = true;

    auto* parent = getParent();
    if (!parent) { removeFromParent(); return; }

    // Rơi 3–5 coin rải xung quanh
    int nCoin = RandomHelper::random_int(3, 5);
    for (int i = 0; i < nCoin; ++i) {
        if (auto* c = Coin::create()) {
            c->setPosition(getPosition() + Vec2(
                RandomHelper::random_real(-12.f, 12.f),
                RandomHelper::random_real(6.f, 16.f)
            ));
            parent->addChild(c, 5);
        }
    }

    // 1 Upgrade (hoặc bạn chỉnh tỉ lệ nếu muốn)
    if (auto* u = Upgrade::createRandom()) {
        u->setPosition(getPosition() + Vec2(0, 18));
        parent->addChild(u, 5);
    }

    // KHÔNG spawn Star ở đây
    runAction(Sequence::create(
        FadeOut::create(0.05f),
        CallFunc::create([this] { removeFromParent(); }),
        nullptr
    ));
}

File Chest.h
#pragma once
#include "game/Entity.h"

class Chest : public Entity {
public:
    CREATE_FUNC(Chest);
    bool init() override;

    // Mở rương: nhả loot xong tự hủy
    void open();

private:
    bool _opened = false;
};

File Coin.cpp
// Coin.cpp
#include "game/objects/Coin.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Coin* Coin::create(){ auto p=new(std::nothrow) Coin(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Coin::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::COIN);

    _sprite = Sprite::create("sprites/objects/coin/coin_1.png"); // frame đầu tiên
    _sprite->setScale(1.5f); // tùy chỉnh kích cỡ hiển thị
    addChild(_sprite, 1);

    Vector<SpriteFrame*> frames;
    auto firstSize = _sprite->getContentSize();
    for (int i = 1; i <= 4; i++) { // giả sử bạn có coin_1.png -> coin_5.png
        std::string framePath = StringUtils::format("sprites/objects/coin/coin_%d.png", i);
        auto frame = SpriteFrame::create(framePath, Rect(0, 0, firstSize.width, firstSize.height));
        frame->setOriginalSize(firstSize);
        frames.pushBack(frame);
    }

    auto animation = Animation::createWithSpriteFrames(frames, 0.2f); // 0.4s mỗi frame
    auto animate = Animate::create(animation);
    _sprite->runAction(RepeatForever::create(animate));

    // auto dn = DrawNode::create();
    // dn->drawSolidCircle(Vec2::ZERO, 10, 0, 24, Color4F(1,0.85f,0,1));
    // addChild(dn);
    auto body = PhysicsBody::createCircle(10);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);               // sensor-only
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Coin.h
// Coin.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"
#include "2d/CCAnimation.h"
#include "2d/CCAnimationCache.h"
class Coin : public Entity {
public:
    static Coin* create();
    bool init() override;
    cocos2d::Sprite* _sprite = nullptr;
};

File Crate.cpp
// Crate.cpp
#include "game/objects/Crate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Crate* Crate::create(){ auto p=new(std::nothrow) Crate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Crate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::CRATE);
    auto dn = DrawNode::create();
    dn->drawSolidRect({-16,-16},{16,16}, Color4F(0.6f,0.4f,0.2f,1));
    addChild(dn);
    auto b = PhysicsBody::createBox(Size(32,32), PhysicsMaterial(0.3f,0,0.9f));
    b->setDynamic(true);
    b->setCategoryBitmask(phys::CAT_CRATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}

File Crate.h
// Crate.h
#pragma once
#include "game/Entity.h"
class Crate : public Entity {
public:
    static Crate* create();
    bool init() override;
};

File Gate.cpp
// Gate.cpp
#include "game/objects/Gate.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Gate* Gate::create(){ auto p=new(std::nothrow) Gate(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Gate::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::GATE);
    _dn = DrawNode::create();
    _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
    addChild(_dn);
    auto b = PhysicsBody::createBox(Size(24,80));
    b->setDynamic(false);
    b->setCategoryBitmask(phys::CAT_GATE);
    b->setCollisionBitmask(phys::CAT_WORLD|phys::CAT_PLAYER|phys::CAT_ENEMY|phys::CAT_CRATE);
    b->setContactTestBitmask(phys::all());
    setPhysicsBody(b);
    return true;
}
void Gate::open(bool on){
    _open = on;
    if(auto* b=getPhysicsBody()){
        b->setEnabled(!on);
    }
    _dn->clear();
    if(on) _dn->drawRect({-12,-40},{12,40}, Color4F(0.2f,1,0.2f,1));     // khung trống
    else   _dn->drawSolidRect({-12,-40},{12,40}, Color4F(0.7f,0.7f,0.9f,1));
}

File Gate.h
// Gate.h
#pragma once
#include "game/Entity.h"
class Gate : public Entity {
public:
    static Gate* create();
    bool init() override;
    void open(bool on);
    bool isOpen() const { return _open; }
private:
    bool _open=false;
    cocos2d::DrawNode* _dn=nullptr;
};

File PressurePlate.cpp
#include "game/objects/PressurePlate.h"
#include "physics/PhysicsDefs.h"
#include "cocos2d.h"

USING_NS_CC;

bool PressurePlate::init(){
    if(!Node::init()) return false;

    const float ww = 48.f, hh = 10.f;
    auto body = PhysicsBody::createBox(Size(ww, hh));
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_SENSOR);
    body->setCollisionBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    body->setContactTestBitmask(phys::CAT_PLAYER | phys::CAT_ENEMY);
    setPhysicsBody(body);

    setTagEx(phys::Tag::PLATE);

    auto dn = DrawNode::create();
    dn->drawSolidRect(Vec2(-ww/2,-hh/2), Vec2(ww/2,hh/2), Color4F(0.9f,0.2f,0.2f,0.9f));
    addChild(dn);

    return true;
}

File PressurePlate.h
// PressurePlate.h
#pragma once
#include "game/Entity.h"
class PressurePlate : public Entity {
public:
    static PressurePlate* create();
    bool init() override;
    void setCallback(const std::function<void(bool)>& cb){ _cb = cb; }
private:
    std::function<void(bool)> _cb;
    int _pressCount = 0;
};

File Star.cpp
// Star.cpp
#include "game/objects/Star.h"
#include "physics/PhysicsDefs.h"
USING_NS_CC;
Star* Star::create(){ auto p=new(std::nothrow) Star(); if(p && p->init()){p->autorelease(); return p;} CC_SAFE_DELETE(p); return nullptr; }
bool Star::init(){
    if(!Entity::init()) return false;
    setTagEx(phys::Tag::STAR);
    auto dn = DrawNode::create();
    Vec2 pts[5];
    for(int i=0;i<5;++i){ float a = CC_DEGREES_TO_RADIANS(72*i-90); pts[i]=Vec2(0,14).rotateByAngle(Vec2::ZERO,a); }
    dn->drawPoly(pts,5,true,Color4F(1,1,0.2f,1));
    addChild(dn);
    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask(phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask(phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

File Star.h
// Star.h
#pragma once
#include "game/Entity.h"
class Star : public Entity {
public:
    static Star* create();
    bool init() override;
};

File Upgrade.cpp
#include "game/objects/Upgrade.h"
#include "physics/PhysicsDefs.h"
#include "base/ccRandom.h"
USING_NS_CC;

// ======= BẢNG THỜI LƯỢNG CỐ ĐỊNH (đổi 1 chỗ là xong) =======
static constexpr float DUR_SPEED      = 45.f;
static constexpr float DUR_JUMP       = 45.f;
static constexpr float DUR_DAMAGE     = 30.f;
static constexpr float DUR_BULLET     = 40.f;
static constexpr float DUR_RANGE      = 35.f;
static constexpr float DUR_DOUBLEJUMP = 60.f;
static constexpr float DUR_EXTRALIFE  = 3.f;  // chỉ để HUD hiển thị
// ===========================================================

float Upgrade::durationFor(Upgrade::Type t){
    switch(t){
        case Type::SPEED:      return DUR_SPEED;
        case Type::JUMP:       return DUR_JUMP;
        case Type::DAMAGE:     return DUR_DAMAGE;
        case Type::BULLET:     return DUR_BULLET;
        case Type::RANGE:      return DUR_RANGE;
        case Type::DOUBLEJUMP: return DUR_DOUBLEJUMP;
        case Type::EXTRA_LIFE: return DUR_EXTRALIFE;
        default: return 30.f;
    }
}

Upgrade* Upgrade::create(){ return createRandom(); }

Upgrade* Upgrade::create(Upgrade::Type t){
    auto p = new(std::nothrow) Upgrade();
    if (p && p->init()){
        p->autorelease();
        p->set(t);                           // <— luôn gán duration chuẩn
        return p;
    }
    CC_SAFE_DELETE(p); return nullptr;
}

Upgrade* Upgrade::createRandom(){
    // Tỉ lệ loại — thời lượng sẽ tự lấy từ durationFor()
    int roll = RandomHelper::random_int(1,100);
    Type t;
    if      (roll<=18) t=Type::SPEED;
    else if (roll<=36) t=Type::JUMP;
    else if (roll<=54) t=Type::DAMAGE;
    else if (roll<=70) t=Type::BULLET;
    else if (roll<=82) t=Type::RANGE;
    else if (roll<=92) t=Type::DOUBLEJUMP;
    else               t=Type::EXTRA_LIFE;
    return create(t);
}

bool Upgrade::init(){
    if(!Entity::init()) return false;
    setTagEx((int)phys::Tag::UPGRADE);

    _sprite = Sprite::create("sprites/objects/upgrade/upgrade_generic.png");
    if(!_sprite){ _sprite = Sprite::create(); _sprite->setTextureRect(Rect(0,0,20,20)); }
    _sprite->setScale(1.2f);
    addChild(_sprite);

    auto body = PhysicsBody::createCircle(12);
    body->setDynamic(false);
    body->setCategoryBitmask((int)phys::CAT_ITEM);
    body->setCollisionBitmask(0);
    body->setContactTestBitmask((int)phys::CAT_PLAYER);
    setPhysicsBody(body);
    return true;
}

void Upgrade::set(Type t){
    _type = t;
    _duration = durationFor(t);     // <— Ở ĐÂY: chốt duration
    _refreshVisual();
}

void Upgrade::_refreshVisual(){
    const char* name = "upgrade_generic.png";
    switch(_type){
        case Type::SPEED:      name="upgrade_speed.png"; break;
        case Type::JUMP:       name="upgrade_jump.png"; break;
        case Type::DAMAGE:     name="upgrade_damage.png"; break;
        case Type::BULLET:     name="upgrade_bullet.png"; break;
        case Type::RANGE:      name="upgrade_range.png"; break;
        case Type::DOUBLEJUMP: name="upgrade_doublejump.png"; break;
        case Type::EXTRA_LIFE: name="upgrade_extralife.png"; break;
    }
    auto path = std::string("sprites/objects/upgrade/") + name;
    if (FileUtils::getInstance()->isFileExist(path)) _sprite->setTexture(path);
}

File Upgrade.h
#pragma once
#include "game/Entity.h"
#include "2d/CCSprite.h"

class Upgrade : public Entity {
public:
    enum class Type {
        SPEED = 0, JUMP = 1, DAMAGE = 2, BULLET = 3,
        RANGE = 4, DOUBLEJUMP = 5, EXTRA_LIFE = 6
    };

    static Upgrade* create();               // random theo bảng loại, nhưng thời lượng cố định
    static Upgrade* create(Type t);         // tạo đúng loại, tự gán duration chuẩn
    static Upgrade* createRandom();         // pick loại, gán duration chuẩn

    bool init() override;

    Type  type()     const { return _type; }
    float duration() const { return _duration; }   // EXTRA_LIFE => 3s chỉ để HUD báo
    static float durationFor(Type t);              // <— HÀM CHUẨN HOÁ DUY NHẤT

    void  set(Type t);                             // gán loại + duration chuẩn

private:
    cocos2d::Sprite* _sprite = nullptr;
    Type   _type      = Type::SPEED;
    float  _duration  = 0.f;

    void   _refreshVisual();
};


Folder Classes/game/upgrades
File UpgradeSystem.cpp
#include "game/upgrades/UpgradeSystem.h"
using namespace cocos2d;
using namespace upgrades;

static float frand(float a, float b){
    return RandomHelper::random_real(std::min(a,b), std::max(a,b));
}
static int irand(int a, int b){
    return RandomHelper::random_int(std::min(a,b), std::max(a,b));
}

UpgradeSystem::Effect UpgradeSystem::roll(int segIndex, const RollSpec& spec) {
    // Chọn type
    Type T;
    switch (irand(0,4)) {
        case 0: T = Type::MOVE_SPEED;  break;
        case 1: T = Type::JUMP_POWER;  break;
        case 2: T = Type::DAMAGE_MULT; break;
        case 3: T = Type::BULLET_COUNT;break;
        default:T = Type::SLASH_RANGE; break;
    }

    // Biên độ “mềm tay”
    float mag = 0.f;
    switch (T) {
        case Type::MOVE_SPEED:   mag = frand(18.f, 40.f);   break;
        case Type::JUMP_POWER:   mag = frand(24.f, 60.f);   break;
        case Type::DAMAGE_MULT:  mag = frand(1.15f, 1.45f); break;
        case Type::BULLET_COUNT: mag = (float)irand(1,2);   break;
        case Type::SLASH_RANGE:  mag = frand(1.15f, 1.40f); break;
    }

    // 50% TIMED, còn lại theo defaultScope
    Scope sc  = spec.defaultScope;
    float dur = 0.f;
    if (spec.allowTimed && RandomHelper::random_int(0,1)==1) {
        sc  = Scope::TIMED;
        dur = spec.timedDuration + segIndex * 3.f; // mini sau lâu hơn chút
    }

    return Effect{ T, mag, sc, dur };
}

File UpgradeSystem.h
#pragma once
#include "cocos2d.h"

namespace upgrades {

// Thời hạn hiệu lực
enum class Scope : int { TIMED, SEGMENT, PERSIST };

// Loại nâng cấp
enum class Type  : int {
    MOVE_SPEED,     // +px/s
    JUMP_POWER,     // +impulse
    DAMAGE_MULT,    // × sát thương (đạn + chém)
    BULLET_COUNT,   // +số đạn mỗi phát
    SLASH_RANGE     // × tầm chém
};

// Hiệu ứng cụ thể
struct Effect {
    Type  type;
    float magnitude;    // + hoặc × (tuỳ loại)
    Scope scope;
    float durationSec;  // dùng khi TIMED; SEGMENT/PERSIST = 0
};

// Tham số roll gacha
struct RollSpec {
    Scope defaultScope  = Scope::SEGMENT; // mặc định hết mini thì hết
    float timedDuration = 20.f;           // base thời gian khi TIMED
    bool  allowTimed    = true;           // 50% ra TIMED nếu true
};

class UpgradeSystem {
public:
    // Trả về 1 hiệu ứng ngẫu nhiên theo mini (segIndex) và rule
    static Effect roll(int segIndex, const RollSpec& spec = {});
};

} // namespace upgrades


Folder Classes/game/weapon
File Bullet.cpp
#include "game/weapon/Bullet.h"
#include "physics/PhysicsDefs.h"          // <-- cần để dùng phys::CAT_*, MASK_*, Tag
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include <algorithm>                       // <-- std::max

using namespace cocos2d;

Bullet* Bullet::create(const Vec2& origin, const Vec2& velocity, float lifeSec) {
    auto p = new (std::nothrow) Bullet();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay + name cho dễ debug / lọc va chạm
        p->setTagEx(phys::Tag::BULLET);
        p->setName("player_proj");

        // Vị trí ban đầu
        p->setPosition(origin);

        // Vẽ dấu chấm nhỏ cho dễ nhìn
        auto dot = DrawNode::create();
        dot->drawSolidCircle(Vec2::ZERO, 4.5f, 0, 12, Color4F(1.f, 0.95f, 0.2f, 1.f));
        p->addChild(dot);

        // Thân vật lý
        auto body = PhysicsBody::createCircle(4.5f, PhysicsMaterial(0,0,0));
        body->setDynamic(true);
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Masks: để đạn người chơi có thể "đụng" ENEMY + ENEMY_PROJ (đã có trong MASK_BULLET)
        body->setCategoryBitmask(static_cast<int>(phys::CAT_BULLET));
        body->setCollisionBitmask(static_cast<int>(phys::MASK_BULLET));
        body->setContactTestBitmask(static_cast<int>(phys::MASK_BULLET));

        // Gắn tag lên shape để contact listener nhận diện nhanh
        if (!body->getShapes().empty())
            body->getShapes().front()->setTag(static_cast<int>(phys::Tag::BULLET));

        p->addComponent(body);

        // Bay theo vận tốc đầu vào
        body->setVelocity(velocity);

        // Tự hủy sau lifeSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, lifeSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Bullet.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

class Bullet : public Entity {
public:
    CREATE_FUNC(Bullet);

    // Tạo bullet tại origin, bay với velocity, tự hủy sau lifeSec
    static Bullet* create(const cocos2d::Vec2& origin,
                          const cocos2d::Vec2& velocity,
                          float lifeSec);

protected:
    bool init() override { return Entity::init(); }
};

File Slash.cpp
#include "game/weapon/Slash.h"
#include "physics/PhysicsDefs.h"          // <-- CAT_SENSOR, MASK_SENSOR, ShapeTag::SLASH
#include "physics/CCPhysicsBody.h"
#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include <algorithm>
#include <cmath>

using namespace cocos2d;

Slash* Slash::create(const Vec2& origin, float angleRad, float sizeOrRange, float durationSec) {
    auto p = new (std::nothrow) Slash();
    if (p && p->init()) {
        p->autorelease();

        // Tag gameplay + name để phân biệt trong onContact
        p->setTagEx(phys::Tag::SLASH);
        p->setName("player_slash");

        p->setPosition(origin);

        // (Optional) Visual debug — giữ nguyên tắt đi để gọn
        // auto dn = DrawNode::create();
        float r  = std::max(8.0f, sizeOrRange);

        Vec2 a( std::cos(angleRad), std::sin(angleRad) );
        Vec2 p0 = Vec2::ZERO;
        Vec2 p1 = a * r;
        Vec2 p2 = a.rotateByAngle(Vec2::ZERO, 0.35f) * (r * 0.75f);
        Vec2 tri[3] = { p0, p1, p2 };
        // dn->drawSolidPoly(tri, 3, Color4F(1.f, 1.f, 0.4f, 0.35f));
        // p->addChild(dn);

        // Body sensor hình hộp mỏng, đặt lệch về hướng tấn công
        auto body = PhysicsBody::create();
        body->setDynamic(false);
        body->setGravityEnable(false);
        body->setRotationEnable(false);

        // Hộp mỏng theo hướng chém (offset theo vector a)
        const float boxW = r * 0.9f;
        const float boxH = std::max(10.0f, r * 0.35f);
        Vec2 offset = a * (r * 0.45f);

        auto shape = PhysicsShapeBox::create(Size(boxW, boxH), PhysicsMaterial(0,0,0), offset);
        shape->setSensor(true);
        shape->setTag(static_cast<int>(phys::ShapeTag::SLASH));
        body->addShape(shape);

        // Masks: sensor chỉ cần contact (MASK_SENSOR = CAT_ALL) để bắt ENEMY và ENEMY_PROJ
        body->setCategoryBitmask(static_cast<int>(phys::CAT_SENSOR));
        body->setCollisionBitmask(0);
        body->setContactTestBitmask(static_cast<int>(phys::MASK_SENSOR));

        p->addComponent(body);

        // Xoay để visual khớp hướng
        p->setRotation(-CC_RADIANS_TO_DEGREES(angleRad));

        // Tự hủy sau durationSec
        p->runAction(Sequence::create(
            DelayTime::create(std::max(0.05f, durationSec)),
            CallFunc::create([p]{ p->removeFromParent(); }),
            nullptr
        ));
        return p;
    }
    CC_SAFE_DELETE(p);
    return nullptr;
}

File Slash.h
#pragma once
#include "cocos2d.h"
#include "game/Entity.h"
#include "physics/PhysicsDefs.h"

#pragma once
#include "game/Entity.h"

class Slash : public Entity {
public:
    static Slash* create(const cocos2d::Vec2& origin, float angleRad,
                         float sizeOrRange, float durationSec = 0.15f);
    bool init() override { return Entity::init(); }
};


Folder Classes/physics
File PhysicsDefs.h
#pragma once
#include <cstdint>
#include <initializer_list>
#include "cocos2d.h"

namespace phys {

// ==============================
// Bit/Mask cơ bản
// ==============================
using Mask = std::uint32_t;

enum : Mask {
    CAT_NONE       = 0u,
    CAT_WORLD      = 1u << 0,  // ground/map/platform
    CAT_PLAYER     = 1u << 1,
    CAT_ENEMY      = 1u << 2,
    CAT_ITEM       = 1u << 3,  // coin/star/upgrade…
    CAT_BULLET     = 1u << 4,  // projectile của người chơi
    CAT_SENSOR     = 1u << 5,  // generic sensors
    CAT_CRATE      = 1u << 6,
    CAT_GATE       = 1u << 7,
    CAT_SOLID      = 1u << 8,  // tường/vật thể rắn khác

    // TÁCH BIT RIÊNG cho đạn/aoe của kẻ địch (không đè CRATE)
    CAT_ENEMY_PROJ = 1u << 9,

    CAT_ALL        = 0xFFFFFFFFu
};

// ==============================
// Tag gameplay cho Entity
// ==============================
enum class Tag : int {
    NONE    = 0,
    COIN    = 1,
    STAR    = 2,
    UPGRADE = 3,
    GATE    = 4,
    CRATE   = 5,
    BULLET  = 6,
    SLASH   = 7,
    PLATE   = 8,
    PLAYER  = 9,
    ENEMY   = 10
};

// ==============================
// Tag cho PhysicsShape (sensor/fixture)
// ==============================
enum class ShapeTag : int {
    NONE  = 0,
    FOOT  = 1,  // chân player để bắt tiếp đất
    SLASH = 2   // hitbox chém
};

// Alias số nguyên để code cũ gọi phys::FOOT/SLASH vẫn chạy
constexpr int FOOT  = static_cast<int>(ShapeTag::FOOT);
constexpr int SLASH = static_cast<int>(ShapeTag::SLASH);

// ==============================
// Masks giữ lại cho back-compat
// ==============================
// CHÚ Ý: Bullet của player sẽ contact với ENEMY_PROJ để bắn nổ đạn quái
constexpr Mask MASK_BULLET = (CAT_WORLD | CAT_ENEMY | CAT_ENEMY_PROJ | CAT_GATE | CAT_CRATE);
constexpr Mask MASK_SENSOR = CAT_ALL;

// ==============================
// Helpers cho mask
// ==============================
inline Mask all() { return CAT_ALL; }

// all({ A, B, C }) — C++14, không dùng fold-expression
inline Mask all(std::initializer_list<Mask> xs) {
    Mask m = 0u;
    for (Mask v : xs) m |= v;
    return m;
}

inline bool any(Mask m, Mask flags) { return (m & flags) != 0u; }

// ==============================
// Helpers thao tác với PhysicsBody / Node
// ==============================
inline bool hasCat(const cocos2d::PhysicsBody* body, Mask cat) {
    return body && ((static_cast<Mask>(body->getCategoryBitmask()) & cat) != 0u);
}
inline bool hasCat(const cocos2d::Node* node, Mask cat) {
    return node && hasCat(node->getPhysicsBody(), cat);
}

inline void setMasks(cocos2d::PhysicsBody* body, Mask category, Mask collide, Mask contact) {
    if (!body) return;
    body->setCategoryBitmask(static_cast<int>(category));
    body->setCollisionBitmask(static_cast<int>(collide));
    body->setContactTestBitmask(static_cast<int>(contact));
}
inline void setMasks(cocos2d::Node* node, Mask category, Mask collide, Mask contact) {
    if (!node) return;
    setMasks(node->getPhysicsBody(), category, collide, contact);
}

// đặt TÂM thân ở ngay phía trên mép trên topY, có skin nhỏ để không "lún"
inline float yOnTop(float topY, float bodyH, float skin = 0.5f) {
    return topY + bodyH * 0.5f + skin;
}

} // namespace phys

// ------------------------------------------------------------
// Legacy forwarders: cho những chỗ gọi all(...) không có tiền tố phys::
// ------------------------------------------------------------
inline phys::Mask all() { return phys::all(); }
inline phys::Mask all(std::initializer_list<phys::Mask> xs) { return phys::all(xs); }


Folder Classes/scenes
File GameScene.cpp
#include "scenes/GameScene.h"
#include "ui/HUDLayer.h"
#include "game/map/LevelBuilder.h"

#include "game/Enemy.h"
#include "game/bosses/BossGolem.h"
#include "game/weapon/Bullet.h"
#include "game/weapon/Slash.h"
#include "game/objects/Coin.h"
#include "game/objects/Star.h"
#include "game/objects/Upgrade.h"
#include "game/objects/Chest.h"

#include "physics/CCPhysicsShape.h"
#include "2d/CCDrawNode.h"
#include "physics/PhysicsDefs.h"
#include <algorithm>
#include <vector>

USING_NS_CC;

// ---------------------------
// Helpers file-scope
// ---------------------------
static inline bool isSlashShape(cocos2d::PhysicsShape* s) {
    return s && s->getTag() == (int)phys::ShapeTag::SLASH;
}

static bool hasCat(cocos2d::Node* n, phys::Mask catMask){
    if (!n) return false;
    auto* body = n->getPhysicsBody();
    return body && ((static_cast<phys::Mask>(body->getCategoryBitmask()) & catMask) != 0u);
}

// ======================================================================

Scene* GameScene::createScene() {
    auto scene = Scene::createWithPhysics();
    auto layer = GameScene::create();
    layer->setPhysicsWorld(scene->getPhysicsWorld());
    scene->addChild(layer);
    return scene;
}

bool GameScene::init() {
    if (!Layer::init()) return false;

    _vs     = Director::getInstance()->getVisibleSize();
    _origin = Director::getInstance()->getVisibleOrigin();

    buildUICamera();
    buildHUD();

    // build map 5 mini
    auto L = levels::buildLevel1(this, _vs, _origin);
    _groundTop    = L.groundTop;
    _segmentCount = L.segments;
    _segmentWidth = L.segmentWidth;

    _segment = 0;
    _camL = _origin.x + _segment * _segmentWidth;
    _camR = _camL + _segmentWidth;

    // Player
    _player = Player::create();
    addChild(_player, 5);
    _player->enablePhysics({ L.playerSpawn.x, _groundTop + 220.f });

    // GÁN TARGET + cấu hình aggro (boss mặc định ngủ)
    for (auto* e : L.enemies) {
        _enemies.pushBack(e);
        e->setTarget(_player);
        e->setAggroEnabled(true);
        e->setAggroRange(220.f);
        e->setChaseSpeed(130.f);
        if (auto boss = dynamic_cast<BossGolem*>(e)) {
            boss->setAggroEnabled(false);    // chỉ bật ở mini cuối
            boss->setAggroRange(320.f);
            boss->setChaseSpeed(110.f);
        }
    }

    // HUD
    _lives = 3; _score = 0; _starsHave = 0;
    _starsNeed = _segmentCount;      // 1 sao / mini
    if (_hud) {
        _hud->setZone(1, _segmentCount);
        _hud->setLives(_lives);
        _hud->setScore(_score);
        _hud->setStars(_starsHave, _starsNeed);
        _hud->setHP(_player->hp(), _player->maxHp());
    }

    // --- Sao theo mini + barrier + portal ---
    _starsSeg.assign(_segmentCount, 0);

    // Barrier khoá giữa các mini
    for (int i=0; i<_segmentCount-1; ++i) {
        float x = _origin.x + (i+1)*_segmentWidth - 3.f;
        auto n = Node::create();
        auto body = PhysicsBody::createBox(Size(6, _vs.height));
        body->setDynamic(false);
        body->setCategoryBitmask((int)phys::CAT_GATE);
        body->setCollisionBitmask((int)(phys::CAT_PLAYER | phys::CAT_ENEMY));   // thay dòng cũ chỉ có PLAYER
        body->setContactTestBitmask((int)(phys::CAT_PLAYER | phys::CAT_ENEMY)); // thay dòng cũ chỉ có PLAYER

        n->addComponent(body);
        n->setPosition({x, _groundTop + _vs.height*0.5f});
        addChild(n, 2);
        _locks.push_back(n);
    }

    // Portal cuối (visual)
    auto dn = DrawNode::create();
    dn->drawSolidCircle(Vec2::ZERO, 24, 0, 28, Color4F(0.7f,0.9f,1.f,0.85f));
    _endPortal = dn;
    _endPortal->setPosition(_origin + Vec2(_segmentCount*_segmentWidth - 64.f, _groundTop + 64.f));
    addChild(_endPortal, 3);

    _bindInput();

    auto cl = EventListenerPhysicsContact::create();
    cl->onContactBegin    = CC_CALLBACK_1(GameScene::_onContactBegin, this);
    cl->onContactSeparate = CC_CALLBACK_1(GameScene::_onContactSeparate, this);
    _eventDispatcher->addEventListenerWithSceneGraphPriority(cl, this);
    _contact = cl;

    scheduleUpdate();
    return true;
}

void GameScene::onEnter() {
    Layer::onEnter();
    if (!_world && getScene()) _world = getScene()->getPhysicsWorld();
    CCASSERT(_world, "GameScene must be under a Scene with physics");
    _world->setGravity(Vec2(0, -980));
}

void GameScene::onExit() { Layer::onExit(); }

// ======================================================================
// UI
// ======================================================================
void GameScene::buildUICamera() {
    _uiCam = Camera::createOrthographic(_vs.width, _vs.height, 1.0f, 1024.0f);
    _uiCam->setCameraFlag(CameraFlag::USER1);
    _uiCam->setPosition(_origin + Vec2(_vs.width*0.5f, _vs.height*0.5f));
    addChild(_uiCam, 999);
}

void GameScene::buildHUD() {
    _hud = HUDLayer::create();
    _hud->setCameraMask((unsigned short)CameraFlag::USER1);
    addChild(_hud, 100);
}

// ======================================================================
// Input
// ======================================================================
void GameScene::_bindInput() {
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin) {
            if (c==EventKeyboard::KeyCode::KEY_R && _gameOver) _restartLevel();
            if ((c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) && _gameWin) _returnMenu();
            return;
        }
        if (!_player) return;
        switch (c) {
            case EventKeyboard::KeyCode::KEY_A:
            case EventKeyboard::KeyCode::KEY_LEFT_ARROW:  _player->setMoveDir({-1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_D:
            case EventKeyboard::KeyCode::KEY_RIGHT_ARROW: _player->setMoveDir({ 1.f,0.f}); break;
            case EventKeyboard::KeyCode::KEY_W:
            case EventKeyboard::KeyCode::KEY_UP_ARROW:
            case EventKeyboard::KeyCode::KEY_SPACE: _player->jump(); break;
            case EventKeyboard::KeyCode::KEY_J: _player->doShoot(); break;
            case EventKeyboard::KeyCode::KEY_K: _player->doSlash(); break;
            default: break;
        }
    };
    l->onKeyReleased = [this](EventKeyboard::KeyCode c, Event*) {
        if (_gameOver || _gameWin || !_player) return;
        if (c==EventKeyboard::KeyCode::KEY_A || c==EventKeyboard::KeyCode::KEY_LEFT_ARROW ||
            c==EventKeyboard::KeyCode::KEY_D || c==EventKeyboard::KeyCode::KEY_RIGHT_ARROW)
            _player->setMoveDir({0.f,0.f});
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;
}

// ======================================================================
// Contact
// ======================================================================
bool GameScene::_onContactBegin(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();

    // FOOT ↔ WORLD
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(1);
        return true;
    }

    // Player ↔ Item
    Node* item = nullptr;
    if (hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ITEM)) item=b;
    else if (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ITEM)) item=a;

    if (item) {
        int segByItem = (int)((item->getPositionX() - _origin.x) / _segmentWidth);
        segByItem = std::max(0, std::min(segByItem, _segmentCount-1));

        if (auto star = dynamic_cast<Star*>(item)) {
            _starsSeg[segByItem] += 1;
            _setStars(_starsHave+1, _starsNeed);
            _addScore(50);

            // mở barrier của mini này (nếu chưa là mini cuối)
            if (segByItem < _segmentCount-1 && segByItem >= 0 && segByItem < (int)_locks.size()) {
                if (_locks[segByItem]) {
                    _locks[segByItem]->removeFromParent();
                    _locks[segByItem] = nullptr;
                    _showOverlay("Gate opened!");
                }
            }

            item->removeFromParent();
            _checkWin();
            return false;
        }

        if (auto coin = dynamic_cast<Coin*>(item)) {
            _addScore(10);
            item->removeFromParent();
            return false;
        }

        if (auto up = dynamic_cast<Upgrade*>(item)) {
            using T = Upgrade::Type;
            const auto t = up->type();
            _addScore(25);

            if (_player) {
                if (t == T::EXTRA_LIFE) {
                    _setLives(_lives + 1);
                    if (_hud) _hud->addBuff("Extra Life +1", 3.f);
                } else {
                    _player->applyUpgrade((int)t, up->duration());
                    if (_hud) {
                        std::string n;
                        switch (t) {
                            case T::SPEED:      n="Speed +25%"; break;
                            case T::JUMP:       n="Jump +15%"; break;
                            case T::DAMAGE:     n="Damage +1"; break;
                            case T::BULLET:     n="Bullet +1"; break;
                            case T::RANGE:      n="Range +"; break;
                            case T::DOUBLEJUMP: n="Double Jump"; break;
                            default:            n="Upgrade"; break;
                        }
                        _hud->addBuff(n, std::max(0.1f, up->duration()));
                    }
                }
            }
            item->removeFromParent();
            return false;
        }

        if (auto chest = dynamic_cast<Chest*>(item)) {
            chest->open();
            return false;
        }
    }

    // Player Bullet/Slash ↔ Enemy Projectile => phá cả hai
    if ( ((hasCat(a, phys::CAT_BULLET) || isSlashShape(A)) && hasCat(b, phys::CAT_ENEMY_PROJ)) ||
         ((hasCat(b, phys::CAT_BULLET) || isSlashShape(B)) && hasCat(a, phys::CAT_ENEMY_PROJ)) ) {

        if (hasCat(a, phys::CAT_ENEMY_PROJ)) a->removeFromParent();
        if (hasCat(b, phys::CAT_ENEMY_PROJ)) b->removeFromParent();
        if (hasCat(a, phys::CAT_BULLET))     a->removeFromParent();
        if (hasCat(b, phys::CAT_BULLET))     b->removeFromParent();
        return false; // chặn phản ứng vật lý mặc định
    }

    // Player ↔ Enemy Projectile => player mất máu + xoá đạn quái
    if ( (hasCat(a, phys::CAT_PLAYER) && hasCat(b, phys::CAT_ENEMY_PROJ)) ||
         (hasCat(b, phys::CAT_PLAYER) && hasCat(a, phys::CAT_ENEMY_PROJ)) ) {

        if (_player && !_player->invincible()) {
            _player->hurt(10);
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
            if (_player->isDead()) {
                _setLives(_lives - 1);
                if (_lives <= 0) {
                    _gameOver = true; _showOverlay("YOU DIED\nPress [R] to restart");
                } else {
                    _player->restoreFullHP();
                    if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
                    if (auto body = _player->getPhysicsBody()) body->setVelocity(Vec2::ZERO);
                    _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f, _groundTop + 40.f));
                }
            }
        }
        if (hasCat(a, phys::CAT_ENEMY_PROJ)) a->removeFromParent();
        if (hasCat(b, phys::CAT_ENEMY_PROJ)) b->removeFromParent();
        return false;
    }

    // Bullet/Slash ↔ Enemy
    Node* enemyNode = nullptr;
    if ((hasCat(a,phys::CAT_BULLET) || isSlashShape(A)) && hasCat(b,phys::CAT_ENEMY)) enemyNode = b;
    else if ((hasCat(b,phys::CAT_BULLET) || isSlashShape(B)) && hasCat(a,phys::CAT_ENEMY)) enemyNode = a;

    if (enemyNode) {
        // Va chạm có thể rơi vào node con (hurtbox). Leo lên cha để tìm Enemy thật.
        Node* cur = enemyNode;
        Enemy* e = nullptr;
        while (cur && !(e = dynamic_cast<Enemy*>(cur))) cur = cur->getParent();

        if (e) {
            int base = (isSlashShape(A) || isSlashShape(B)) ? 2 : 1;
            int dmg  = base + (_player ? _player->atkBonus() : 0);
            e->takeHit(dmg);
            _addScore(20);
        }

        // Dọn đạn của player
        if (hasCat(a,phys::CAT_BULLET)) a->removeFromParent();
        if (hasCat(b,phys::CAT_BULLET)) b->removeFromParent();

        return false; // chặn phản ứng vật lý mặc định
    }

    // Enemy (thân) ↔ Player
    if ((hasCat(a,phys::CAT_PLAYER) && hasCat(b,phys::CAT_ENEMY)) ||
        (hasCat(b,phys::CAT_PLAYER) && hasCat(a,phys::CAT_ENEMY)) ) {
        if (_player && !_player->invincible()) {
            _player->hurt(10);
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());

            // nếu node là projectile gắn tên "enemy_proj" thì dọn luôn
            if (a && a->getName()=="enemy_proj") a->removeFromParent();
            if (b && b->getName()=="enemy_proj") b->removeFromParent();

            if (_player->isDead()) {
                _setLives(_lives-1);
                if (_lives<=0) {
                    _gameOver=true; _showOverlay("YOU DIED\nPress [R] to restart");
                } else {
                    _player->restoreFullHP();
                    if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
                    if (auto body = _player->getPhysicsBody()) body->setVelocity(Vec2::ZERO);
                    _player->setPosition(_origin + Vec2(_segment * _segmentWidth + _vs.width*0.15f,
                                                        _groundTop + 40.f));
                }
            }
        }
        return true;
    }

    // đảm bảo mọi đường đi đều return cho hàm bool
    return true;
}

void GameScene::_onContactSeparate(PhysicsContact& c) {
    auto A = c.getShapeA(); auto B = c.getShapeB();
    auto a = A->getBody()->getNode(); auto b = B->getBody()->getNode();
    if ((A->getTag()==(int)phys::ShapeTag::FOOT && hasCat(b,phys::CAT_WORLD)) ||
        (B->getTag()==(int)phys::ShapeTag::FOOT && hasCat(a,phys::CAT_WORLD))) {
        if (_player) _player->incFoot(-1);
    }
}

// ======================================================================
// Update
// ======================================================================
void GameScene::update(float dt) {
    if (_gameOver || _gameWin || !_player) return;

    if (_hud) _hud->tick(dt);

    // Camera follow trong biên của đoạn hiện tại
    if (auto* scene = this->getScene()) {
        if (auto* cam = scene->getDefaultCamera()) {
            float x      = _player->getPositionX();
            float halfW  = _vs.width * 0.5f;
            float target = cocos2d::clampf(x, _camL + halfW, _camR - halfW);
            cam->setPositionX(target);
        }
    }

    // Sang đoạn kế
    if (_player->getPositionX() > _camR - 4.0f && _segment < _segmentCount - 1) {
        _segment++;
        _camL = _origin.x + _segment * _segmentWidth;
        _camR = _camL + _segmentWidth;
        if (_hud) _hud->setZone(_segment + 1, _segmentCount);
    }

    // Khi vào mini cuối => bật boss
    if (!_bossAggroOn && _segment == _segmentCount - 1) {
        for (auto* e : _enemies)
            if (auto b = dynamic_cast<BossGolem*>(e)) b->setAggroEnabled(true);
        _bossAggroOn = true;
    }

    // Rơi khỏi map => trừ mạng + respawn
    if (_player->getPositionY() < _groundTop - 200.f) {
        _setLives(_lives - 1);
        if (_lives <= 0) {
            _gameOver = true;
            _showOverlay("YOU DIED\nPress [R] to restart");
        } else {
            _player->restoreFullHP();
            if (_hud) _hud->setHP(_player->hp(), _player->maxHp());
            if (auto body = _player->getPhysicsBody())
                body->setVelocity(Vec2::ZERO);
            _player->setPosition(_origin + Vec2(
                _segment * _segmentWidth + _vs.width * 0.15f,
                _groundTop + 40.f
            ));
        }
    }

    // Đủ sao → đến gần portal để Win
    if (!_gameWin && _starsHave >= _starsNeed && _endPortal && _player) {
        float dist = _player->getPosition().distance(_endPortal->getPosition());
        if (dist < 36.f) {
            _gameWin = true;
            _showOverlay("YOU WIN!\nPress [Enter] to Menu");
        }
    }
}

// ======================================================================
// HUD helpers
// ======================================================================
void GameScene::_setLives(int v){ _lives = std::max(0, v); if (_hud) _hud->setLives(_lives); }
void GameScene::_addScore(int v){ _score += v; if (_hud) _hud->setScore(_score); }
void GameScene::_setStars(int have, int need){ _starsHave = have; _starsNeed = need; if (_hud) _hud->setStars(_starsHave, _starsNeed); }
void GameScene::_checkWin(){
    if (_starsHave >= _starsNeed && !_gameWin){
        _gameWin = true;
        _showOverlay("YOU WIN!\nPress [Enter] to Menu");
    }
}
void GameScene::_restartLevel(){ Director::getInstance()->replaceScene(GameScene::createScene()); }
void GameScene::_returnMenu(){ Director::getInstance()->replaceScene(TransitionFade::create(0.25f, Scene::create())); }
void GameScene::_showOverlay(const std::string& text){
    if(!_overlay){
        _overlay = Label::createWithSystemFont(text, "Arial", 46);
        _overlay->setAlignment(TextHAlignment::CENTER);
        _overlay->setAnchorPoint({0.5f,0.5f});
        _overlay->setColor(Color3B::WHITE);
        _overlay->enableShadow();
        addChild(_overlay, 99);
    }
    _overlay->setString(text);
    _overlay->setPosition(_origin + Vec2(_camL + _segmentWidth*0.5f, _vs.height*0.6f));
}

File GameScene.h
#pragma once
#include "cocos2d.h"
#include "game/Player.h"
#include "game/Enemy.h"
#include "game/map/LevelBuilder.h"

class HUDLayer;

class GameScene : public cocos2d::Layer {
public:
    static cocos2d::Scene* createScene();
    CREATE_FUNC(GameScene);

    bool init() override;
    void onEnter() override;
    void onExit() override;
    void update(float dt) override;

    void setPhysicsWorld(cocos2d::PhysicsWorld* w) { _world = w; }

private:
    // world / view
    cocos2d::PhysicsWorld* _world = nullptr;
    cocos2d::Size _vs{};
    cocos2d::Vec2 _origin{};

    // UI
    cocos2d::Camera* _uiCam = nullptr;
    HUDLayer*        _hud   = nullptr;
    cocos2d::Label*  _overlay = nullptr;

    // actors
    Player* _player = nullptr;
    cocos2d::Vector<Enemy*> _enemies;

    // level state
    float _groundTop = 0.f;
    int   _segment = 0, _segmentCount = 1;
    float _segmentWidth = 0.f;
    float _camL = 0.f, _camR = 0.f;

    int  _score=0, _lives=3, _starsHave=0, _starsNeed=5;
    bool _gameOver=false, _gameWin=false;
    bool _bossAggroOn=false; // chỉ bật khi vào mini cuối

    // listeners
    cocos2d::EventListenerKeyboard*       _kb      = nullptr;
    cocos2d::EventListenerPhysicsContact* _contact = nullptr;

    // UI helpers
    void buildUICamera();
    void buildHUD();
    void _showOverlay(const std::string& text);

    // input
    void _bindInput();

    // contact
    bool _onContactBegin(cocos2d::PhysicsContact& c);
    void _onContactSeparate(cocos2d::PhysicsContact& c);

    // HUD/state
    void _setLives(int v);
    void _addScore(int v);
    void _setStars(int have, int need);
    void _checkWin();
    void _restartLevel();
    void _returnMenu();

    // stars by segment + gates + end portal
    std::vector<int> _starsSeg;
    std::vector<cocos2d::Node*> _locks;
    cocos2d::Node* _endPortal = nullptr;
};

File MenuScene.cpp
#include "scenes/MenuScene.h"
#include "scenes/GameScene.h"
USING_NS_CC;

Scene* MenuScene::createScene(){ return MenuScene::create(); }

bool MenuScene::init(){
    if(!Scene::init()) return false;

    auto vs = Director::getInstance()->getVisibleSize();
    auto origin = Director::getInstance()->getVisibleOrigin();

    auto title = Label::createWithSystemFont("MyGame", "Arial", 48);
    title->setPosition(origin + Vec2(vs.width/2, vs.height*0.65f));
    auto hint  = Label::createWithSystemFont("[ENTER] New Game   |   [ESC] Quit","Arial",24);
    hint->setPosition(origin + Vec2(vs.width/2, vs.height*0.45f));
    addChild(title); addChild(hint);

    // Dự phòng: nếu có Menu* close từ template bị add nhầm
    for (auto ch : getChildren())
        if (auto m = dynamic_cast<Menu*>(ch)) m->setEnabled(false);

    _bindInput();
    return true;
}

void MenuScene::_bindInput(){
    auto l = EventListenerKeyboard::create();
    l->onKeyPressed = [this](EventKeyboard::KeyCode c, Event*){
        if (c==EventKeyboard::KeyCode::KEY_ENTER || c==EventKeyboard::KeyCode::KEY_KP_ENTER) _goGame();
        else if (c==EventKeyboard::KeyCode::KEY_ESCAPE) Director::getInstance()->end();
    };
    _eventDispatcher->addEventListenerWithSceneGraphPriority(l, this);
    _kb = l;  // lưu lại để gỡ
}

void MenuScene::onExit(){
    if (_kb) {
        _eventDispatcher->removeEventListener(_kb);
        _kb = nullptr;
    }
    Scene::onExit();
}

void MenuScene::_goGame(){
    Director::getInstance()->replaceScene(TransitionFade::create(0.25f, GameScene::createScene()));
}

File MenuScene.h
#pragma once
#include "cocos2d.h"

class MenuScene : public cocos2d::Scene {
public:
    CREATE_FUNC(MenuScene);
    static cocos2d::Scene* createScene();
    bool init() override;
    void onExit() override;                // <-- thêm

private:
    void _bindInput();
    void _goGame();

    cocos2d::EventListenerKeyboard* _kb = nullptr;  // <-- thêm
};


Folder Classes/ui
File HUDLayer.cpp
#include "ui/HUDLayer.h"
using namespace cocos2d;

bool HUDLayer::init(){
    if(!Layer::init()) return false;

    // text góc
    _lLives = Label::createWithSystemFont("HP: ❤❤❤", "Arial", 22);
    _lScore = Label::createWithSystemFont("Score: 0", "Arial", 22);
    _lStars = Label::createWithSystemFont("★ 0/5", "Arial", 22);
    _lZone  = Label::createWithSystemFont("Zone 1/5", "Arial", 22);
    for(auto* L : {_lLives,_lScore,_lStars,_lZone}){
        L->setColor(Color3B::WHITE);
        L->enableShadow(Color4B(0,0,0,128), Size(1,-1), 1);
        addChild(L);
    }

    // HP bar (trên cùng, trái)
    _hpBarBG = DrawNode::create(); addChild(_hpBarBG);
    _hpBarFG = DrawNode::create(); addChild(_hpBarFG);
    _lHPText = Label::createWithSystemFont("100/100", "Arial", 18);
    _lHPText->enableShadow();
    addChild(_lHPText);

    schedule([this](float dt){ tick(dt); }, "hud.tick");
    _layout();
    _redrawHP();
    return true;
}

void HUDLayer::onEnter(){
    Layer::onEnter();
    _layout();
}

void HUDLayer::_layout(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();

    // text
    _lLives->setAnchorPoint({0,1});  _lLives->setPosition(org + Vec2(16, vs.height-12));
    _lScore->setAnchorPoint({0,1});  _lScore->setPosition(org + Vec2(16, vs.height-40));

    _lStars->setAnchorPoint({1,1});  _lStars->setPosition(org + Vec2(vs.width-16, vs.height-12));
    _lZone ->setAnchorPoint({1,1});  _lZone ->setPosition(org + Vec2(vs.width-16, vs.height-40));

    // HP bar
    const float x = org.x + 16;
    const float y = org.y + vs.height - 72;
    const Size  sz(220, 14);
    _hpBarBG->clear();
    _hpBarBG->drawSolidRect({x-2,y-2}, {x+sz.width+2, y+sz.height+2}, Color4F(0,0,0,0.6f));
    _hpBarFG->setPosition(Vec2::ZERO);
    _lHPText->setAnchorPoint({0,0.5f});
    _lHPText->setPosition({x, y-18});
    _redrawHP();

    // Buff strip
    _layoutBuffs();
}

void HUDLayer::_redrawHP(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();
    const float x = org.x + 16;
    const float y = org.y + vs.height - 72;
    const Size  sz(220, 14);

    float t = (_hpMax>0) ? std::max(0.f, std::min(1.f, _hpCur/(float)_hpMax)) : 0.f;
    _hpBarFG->clear();
    _hpBarFG->drawSolidRect({x,y}, {x+sz.width*t, y+sz.height}, Color4F(0.9f,0.2f,0.2f,1.f));
    _lHPText->setString(StringUtils::format("%d/%d", _hpCur,_hpMax));
}

void HUDLayer::setLives(int v){
    _lives = std::max(0,v);
    std::string hearts;
    for(int i=0;i<_lives;i++) hearts += u8"❤";
    if(hearts.empty()) hearts="0";
    _lLives->setString("HP: " + hearts);
}
void HUDLayer::setScore(int v){ _lScore->setString("Score: " + std::to_string(v)); }
void HUDLayer::setStars(int have, int need){ _lStars->setString("★ " + std::to_string(have)+"/"+std::to_string(need)); }
void HUDLayer::setZone(int cur, int total){ _lZone->setString("Zone " + std::to_string(cur)+"/"+std::to_string(total)); }

void HUDLayer::setHP(int cur, int max){
    _hpCur=std::max(0,cur); _hpMax=std::max(1,max); _redrawHP();
}

// ===== Buff strip =====
int HUDLayer::addBuff(const std::string& name, float dur){
    BuffUI ui; ui.id=_nextBuffId++; ui.dur=dur; ui.remain=dur;
    ui.root = Node::create(); addChild(ui.root);
    ui.name = Label::createWithSystemFont(name, "Arial", 18);
    ui.name->enableShadow();
    ui.bar  = DrawNode::create();
    ui.root->addChild(ui.name);
    ui.root->addChild(ui.bar);
    _buffs.push_back(ui);
    _layoutBuffs();
    return ui.id;
}
void HUDLayer::removeBuff(int id){
    for(size_t i=0;i<_buffs.size();++i){
        if(_buffs[i].id==id){
            _buffs[i].root->removeFromParent();
            _buffs.erase(_buffs.begin()+i);
            break;
        }
    }
    _layoutBuffs();
}
void HUDLayer::_layoutBuffs(){
    const auto vs  = Director::getInstance()->getVisibleSize();
    const auto org = Director::getInstance()->getVisibleOrigin();
    const float startY = org.y + vs.height - 110;
    const float centerX= org.x + vs.width * 0.5f;

    const float itemW=220, itemH=18, gap=6;
    float totalW = (float)_buffs.size()*itemW + std::max(0,(int)_buffs.size()-1)*gap;

    float x0 = centerX - totalW*0.5f;
    for(size_t i=0;i<_buffs.size();++i){
        auto& b = _buffs[i];
        b.root->setPosition({x0 + i*(itemW+gap), startY});
        b.name->setAnchorPoint({0,0.5f});
        b.name->setPosition({0, itemH+6});
        // redraw bar: co dần từ trái -> phải (tua "ngược")
        b.bar->clear();
        b.bar->drawSolidRect({0,0}, {itemW, itemH}, Color4F(0,0,0,0.55f));
        float t = (b.dur>0)? (b.remain / b.dur) : 0.f;
        t = std::max(0.f,std::min(1.f,t));
        b.bar->drawSolidRect({0,0}, {itemW*t, itemH}, Color4F(0.2f,0.8f,1.f,0.9f));
    }
}
void HUDLayer::tick(float dt){
    bool changed=false;
    for(auto& b : _buffs){
        if(b.dur>0){
            b.remain -= dt;
            if(b.remain < 0) b.remain = 0;
        }
    }
    for(int i=(int)_buffs.size()-1;i>=0;--i){
        if(_buffs[i].dur>0 && _buffs[i].remain<=0.f){
            _buffs[i].root->removeFromParent();
            _buffs.erase(_buffs.begin()+i);
            changed=true;
        }
    }
    // luôn vẽ lại độ dài bar (mượt theo từng frame)
    _layoutBuffs();
}

File HUDLayer.h
#pragma once
#include <vector>
#include <string>
#include "cocos2d.h"

class HUDLayer : public cocos2d::Layer {
public:
    CREATE_FUNC(HUDLayer);
    bool init() override;
    void onEnter() override;

    // ===== API từ GameScene/Player =====
    void setLives(int v);
    void setScore(int v);
    void setStars(int have, int need);
    void setZone(int cur, int total);
    void setHP(int cur, int max);

    // Buff UI: trả về id nếu muốn quản lý thủ công; bình thường cứ để HUD tự đếm
    int  addBuff(const std::string& name, float durationSec);
    void removeBuff(int id);
    void tick(float dt);

private:
    cocos2d::Label* _lLives = nullptr;
    cocos2d::Label* _lScore = nullptr;
    cocos2d::Label* _lStars = nullptr;
    cocos2d::Label* _lZone  = nullptr;

    // HP bar (trên trái)
    cocos2d::DrawNode* _hpBarBG = nullptr;
    cocos2d::DrawNode* _hpBarFG = nullptr;
    cocos2d::Label*    _lHPText = nullptr;
    int _hpCur = 100, _hpMax = 100;

    // Buff strip (trên cùng, giữa)
    struct BuffUI {
        int id;
        cocos2d::Node*     root;
        cocos2d::Label*    name;
        cocos2d::DrawNode* bar;
        float dur, remain;
    };
    std::vector<BuffUI> _buffs;
    int _nextBuffId = 1;

    int _lives = 3;

    void _layout();
    void _layoutBuffs();
    void _redrawHP();
};


